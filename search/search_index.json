{"config":{"lang":["en"],"separator":"[\\s\\-]+"},"docs":[{"title":"Debug notes","text":"<p>These are just some personal notes of things and command i need during debugging:</p> <p>extension build debug</p> <pre><code>sudo phpize &amp;&amp; ./configure --enable-glfw --enable-debug\nsudo make install\n</code></pre> <p>php from source debug on my mac</p> <pre><code>export PATH=\"/usr/local/opt/bison/bin:$PATH\"\nexport PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH:/usr/local/opt/openssl@1.1/lib/pkgconfig\"\nexport PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH:/usr/local/opt/krb5/lib/pkgconfig\"\nexport PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH:/usr/local/opt/libffi/lib/pkgconfig\"\nexport PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH:/usr/local/opt/libxml2/lib/pkgconfig\"\nexport PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH:/usr/local/opt/libxslt/lib/pkgconfig\"\nexport PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH:/usr/local/opt/zlib/lib/pkgconfig\"\nexport PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH:/usr/local/opt/icu4c/lib/pkgconfig\"\n\n./configure --enable-debug --without-iconv --with-config-file-path=/usr/local/etc/php/8.1/ --disable-all --enable-mbstring  --enable-cli --enable-opcache --disable-cgi --enable-opcache --with-gmp\n</code></pre>","location":"DEBUG.html"},{"title":"ByteBuffer","text":"<p>The class <code>GL\\Buffer\\ByteBuffer</code> comes with the PHP-GLFW extension to more efficiently  handle large arrays of <code>GLbyte</code> values (<code>int</code> in php).</p> <p>Don't confuse these objects with actual GPU buffers.</p> <p><code>ByteBuffer</code> stores an array of real <code>GLbyte</code> values internally, which saves a lot of memory and makes interaction with the GL API a lot easier. An instance of this object can be used similarly to an array but comes with obvious limitations. The internal implementation is similar to c++ std::vector, this means you do not have to  specify the exact size / num of elements when constructing the object.</p> <pre><code>namespace GL\\Buffer\n{\n    class ByteBuffer implements BufferInterface {}\n}\n</code></pre>","location":"API/Buffer/ByteBuffer.html"},{"title":"Usage","text":"<p>Again the object can be used similarly to an array, but it's not a hash map,  so all keys have to be of type <code>int</code>. They also have to be in order and explicitly created.</p> <pre><code>use GL\\Buffer\\ByteBuffer;\n\n$buffer = new ByteBuffer;\n\n// values can be pushed into the array using subscript\n$buffer[] = 42;\n$buffer[] = 123;\n\n// values can be accessed like an array\necho $buffer[0]; // 42 \n\n// values can be modifed like an array\n// just make sure the used index actually exists, \n// it will NOT be created implicitly!\n$buffer[0] = 8;\n\n// dumping the buffer will display the first 127 value\nvar_dump($buffer);\n</code></pre>  <p>Note</p> <p>The buffer object resizes itself logarithmically, so if you are planning to insert 10 million elements, be sure to call the <code>reserve</code> method on the object first. As you might guess, it will reserve the  given space, ensuring that the internal buffers are not unnecessarily resized multiple times.</p>","location":"API/Buffer/ByteBuffer.html#usage"},{"title":"Construct from PHP Array","text":"<p>For ease of use, the <code>ByteBuffer</code> constructor accepts a PHP array which will be pushed  value by value into the buffer. The constructor does a sanity check, so you will receive an error when  your array contains invalid values.</p> <pre><code>$buffer = new ByteBuffer([\n    42, 123, 8 \n]);\n</code></pre>","location":"API/Buffer/ByteBuffer.html#construct-from-php-array"},{"title":"Methods","text":"<p>The <code>ByteBuffer</code> class exposes the following methods to userland.</p>","location":"API/Buffer/ByteBuffer.html#methods"},{"title":"<code>push</code>","text":"<p>pushes a value into the buffer, this is exactly the same as when you would write <code>$buffer[] = 123</code>.</p> <pre><code>function push(int $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$value</code> The value to be pushed into the buffer.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/ByteBuffer.html#push"},{"title":"<code>pushArray</code>","text":"<p>pushes an array of values into the buffer. This works the same as when you pass inital data to the constructor.</p> <pre><code>function pushArray(array $values) : void\n</code></pre>  arguments  <ol> <li><code>int[]</code> <code>$values</code> The values to be pushed into the buffer.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/ByteBuffer.html#pusharray"},{"title":"<code>fill</code>","text":"<p>Fills the buffer with <code>$count</code> amount of values. The second argument is the value that is filled in.</p> <pre><code>function fill(int $count, int $value) : void\n</code></pre>  arguments  <ol> <li><code>int $count</code> The number of elements to fill.</li> <li><code>int $value</code> That value that will be filled in.</li> </ol>  returns   <p><code>void</code></p>   <p>Example:</p> <pre><code>$buffer = new ByteBuffer;\n$buffer-&gt;fill(5, 3);\nvar_dump($buffer); // [3, 3, 3, 3, 3]\n</code></pre>  <p>Note</p> <p>Fill will never shrink a buffer down, meaing when you aleady pushed 10 values in,  and then decide to fill 4 values, the other 6 values will remain at the end.</p>","location":"API/Buffer/ByteBuffer.html#fill"},{"title":"<code>reserve</code>","text":"<p>Reserves the $size amount of space. Values are still undefined.</p> <pre><code>function reserve(int $size) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$size</code> The number of elements to reserve space for.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/ByteBuffer.html#reserve"},{"title":"<code>clear</code>","text":"<p>Will clear the Buffer, internally this will release all allocated data. Meaning any reserved space will be freed.</p> <pre><code>function clear() : void\n</code></pre>  returns  <p><code>void</code> </p>","location":"API/Buffer/ByteBuffer.html#clear"},{"title":"<code>size</code>","text":"<p>Returns the actual size / number of elements of the buffer.</p> <pre><code>function size() : int\n</code></pre>  returns  <p><code>int</code> buffer size in element count (not bytes)</p>","location":"API/Buffer/ByteBuffer.html#size"},{"title":"<code>capacity</code>","text":"<p>Returns the current reserved space of the buffer.</p> <pre><code>function capacity() : int\n</code></pre>  returns  <p><code>int</code> buffer space in element count (not bytes)</p>","location":"API/Buffer/ByteBuffer.html#capacity"},{"title":"DoubleBuffer","text":"<p>The class <code>GL\\Buffer\\DoubleBuffer</code> comes with the PHP-GLFW extension to more efficiently  handle large arrays of <code>GLdouble</code> values (<code>float</code> in php).</p> <p>Don't confuse these objects with actual GPU buffers.</p> <p><code>DoubleBuffer</code> stores an array of real <code>GLdouble</code> values internally, which saves a lot of memory and makes interaction with the GL API a lot easier. An instance of this object can be used similarly to an array but comes with obvious limitations. The internal implementation is similar to c++ std::vector, this means you do not have to  specify the exact size / num of elements when constructing the object.</p> <pre><code>namespace GL\\Buffer\n{\n    class DoubleBuffer implements BufferInterface {}\n}\n</code></pre>","location":"API/Buffer/DoubleBuffer.html"},{"title":"Usage","text":"<p>Again the object can be used similarly to an array, but it's not a hash map,  so all keys have to be of type <code>int</code>. They also have to be in order and explicitly created.</p> <pre><code>use GL\\Buffer\\DoubleBuffer;\n\n$buffer = new DoubleBuffer;\n\n// values can be pushed into the array using subscript\n$buffer[] = 42.69;\n$buffer[] = 3.14;\n\n// values can be accessed like an array\necho $buffer[0]; // 42.69 \n\n// values can be modifed like an array\n// just make sure the used index actually exists, \n// it will NOT be created implicitly!\n$buffer[0] = 1.23;\n\n// dumping the buffer will display the first 127 value\nvar_dump($buffer);\n</code></pre>  <p>Note</p> <p>The buffer object resizes itself logarithmically, so if you are planning to insert 10 million elements, be sure to call the <code>reserve</code> method on the object first. As you might guess, it will reserve the  given space, ensuring that the internal buffers are not unnecessarily resized multiple times.</p>","location":"API/Buffer/DoubleBuffer.html#usage"},{"title":"Construct from PHP Array","text":"<p>For ease of use, the <code>DoubleBuffer</code> constructor accepts a PHP array which will be pushed  value by value into the buffer. The constructor does a sanity check, so you will receive an error when  your array contains invalid values.</p> <pre><code>$buffer = new DoubleBuffer([\n    42.69, 3.14, 1.23 \n]);\n</code></pre>","location":"API/Buffer/DoubleBuffer.html#construct-from-php-array"},{"title":"Methods","text":"<p>The <code>DoubleBuffer</code> class exposes the following methods to userland.</p>","location":"API/Buffer/DoubleBuffer.html#methods"},{"title":"<code>push</code>","text":"<p>pushes a value into the buffer, this is exactly the same as when you would write <code>$buffer[] = 3.14</code>.</p> <pre><code>function push(float $value) : void\n</code></pre>  arguments  <ol> <li><code>float</code> <code>$value</code> The value to be pushed into the buffer.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/DoubleBuffer.html#push"},{"title":"<code>pushArray</code>","text":"<p>pushes an array of values into the buffer. This works the same as when you pass inital data to the constructor.</p> <pre><code>function pushArray(array $values) : void\n</code></pre>  arguments  <ol> <li><code>float[]</code> <code>$values</code> The values to be pushed into the buffer.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/DoubleBuffer.html#pusharray"},{"title":"<code>fill</code>","text":"<p>Fills the buffer with <code>$count</code> amount of values. The second argument is the value that is filled in.</p> <pre><code>function fill(int $count, float $value) : void\n</code></pre>  arguments  <ol> <li><code>int $count</code> The number of elements to fill.</li> <li><code>float $value</code> That value that will be filled in.</li> </ol>  returns   <p><code>void</code></p>   <p>Example:</p> <pre><code>$buffer = new DoubleBuffer;\n$buffer-&gt;fill(5, 3);\nvar_dump($buffer); // [3, 3, 3, 3, 3]\n</code></pre>  <p>Note</p> <p>Fill will never shrink a buffer down, meaing when you aleady pushed 10 values in,  and then decide to fill 4 values, the other 6 values will remain at the end.</p>","location":"API/Buffer/DoubleBuffer.html#fill"},{"title":"<code>reserve</code>","text":"<p>Reserves the $size amount of space. Values are still undefined.</p> <pre><code>function reserve(int $size) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$size</code> The number of elements to reserve space for.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/DoubleBuffer.html#reserve"},{"title":"<code>clear</code>","text":"<p>Will clear the Buffer, internally this will release all allocated data. Meaning any reserved space will be freed.</p> <pre><code>function clear() : void\n</code></pre>  returns  <p><code>void</code> </p>","location":"API/Buffer/DoubleBuffer.html#clear"},{"title":"<code>size</code>","text":"<p>Returns the actual size / number of elements of the buffer.</p> <pre><code>function size() : int\n</code></pre>  returns  <p><code>int</code> buffer size in element count (not bytes)</p>","location":"API/Buffer/DoubleBuffer.html#size"},{"title":"<code>capacity</code>","text":"<p>Returns the current reserved space of the buffer.</p> <pre><code>function capacity() : int\n</code></pre>  returns  <p><code>int</code> buffer space in element count (not bytes)</p>","location":"API/Buffer/DoubleBuffer.html#capacity"},{"title":"FloatBuffer","text":"<p>The class <code>GL\\Buffer\\FloatBuffer</code> comes with the PHP-GLFW extension to more efficiently  handle large arrays of <code>GLfloat</code> values (<code>float</code> in php).</p> <p>Don't confuse these objects with actual GPU buffers.</p> <p><code>FloatBuffer</code> stores an array of real <code>GLfloat</code> values internally, which saves a lot of memory and makes interaction with the GL API a lot easier. An instance of this object can be used similarly to an array but comes with obvious limitations. The internal implementation is similar to c++ std::vector, this means you do not have to  specify the exact size / num of elements when constructing the object.</p> <pre><code>namespace GL\\Buffer\n{\n    class FloatBuffer implements BufferInterface {}\n}\n</code></pre>","location":"API/Buffer/FloatBuffer.html"},{"title":"Usage","text":"<p>Again the object can be used similarly to an array, but it's not a hash map,  so all keys have to be of type <code>int</code>. They also have to be in order and explicitly created.</p> <pre><code>use GL\\Buffer\\FloatBuffer;\n\n$buffer = new FloatBuffer;\n\n// values can be pushed into the array using subscript\n$buffer[] = 42.69;\n$buffer[] = 3.14;\n\n// values can be accessed like an array\necho $buffer[0]; // 42.69 \n\n// values can be modifed like an array\n// just make sure the used index actually exists, \n// it will NOT be created implicitly!\n$buffer[0] = 1.23;\n\n// dumping the buffer will display the first 127 value\nvar_dump($buffer);\n</code></pre>  <p>Note</p> <p>The buffer object resizes itself logarithmically, so if you are planning to insert 10 million elements, be sure to call the <code>reserve</code> method on the object first. As you might guess, it will reserve the  given space, ensuring that the internal buffers are not unnecessarily resized multiple times.</p>","location":"API/Buffer/FloatBuffer.html#usage"},{"title":"Construct from PHP Array","text":"<p>For ease of use, the <code>FloatBuffer</code> constructor accepts a PHP array which will be pushed  value by value into the buffer. The constructor does a sanity check, so you will receive an error when  your array contains invalid values.</p> <pre><code>$buffer = new FloatBuffer([\n    42.69, 3.14, 1.23 \n]);\n</code></pre>","location":"API/Buffer/FloatBuffer.html#construct-from-php-array"},{"title":"Methods","text":"<p>The <code>FloatBuffer</code> class exposes the following methods to userland.</p>","location":"API/Buffer/FloatBuffer.html#methods"},{"title":"<code>push</code>","text":"<p>pushes a value into the buffer, this is exactly the same as when you would write <code>$buffer[] = 3.14</code>.</p> <pre><code>function push(float $value) : void\n</code></pre>  arguments  <ol> <li><code>float</code> <code>$value</code> The value to be pushed into the buffer.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/FloatBuffer.html#push"},{"title":"<code>pushArray</code>","text":"<p>pushes an array of values into the buffer. This works the same as when you pass inital data to the constructor.</p> <pre><code>function pushArray(array $values) : void\n</code></pre>  arguments  <ol> <li><code>float[]</code> <code>$values</code> The values to be pushed into the buffer.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/FloatBuffer.html#pusharray"},{"title":"<code>pushVec2</code>","text":"<p>Pushes the values of a Vec2 object into the buffer</p> <pre><code>function pushVec2(\\GL\\Math\\Vec2 $vec) : void\n</code></pre>","location":"API/Buffer/FloatBuffer.html#pushvec2"},{"title":"<code>pushVec3</code>","text":"<p>Pushes the values of a Vec3 object into the buffer</p> <pre><code>function pushVec3(\\GL\\Math\\Vec3 $vec) : void\n</code></pre>","location":"API/Buffer/FloatBuffer.html#pushvec3"},{"title":"<code>pushVec4</code>","text":"<p>Pushes the values of a Vec4 object into the buffer</p> <pre><code>function pushVec4(\\GL\\Math\\Vec4 $vec) : void\n</code></pre>","location":"API/Buffer/FloatBuffer.html#pushvec4"},{"title":"<code>pushMat4</code>","text":"<p>Pushes the values of a Mat4 (16) object into the buffer</p> <pre><code>function pushMat4(\\GL\\Math\\Mat4 $matrix) : void\n</code></pre>","location":"API/Buffer/FloatBuffer.html#pushmat4"},{"title":"<code>fill</code>","text":"<p>Fills the buffer with <code>$count</code> amount of values. The second argument is the value that is filled in.</p> <pre><code>function fill(int $count, float $value) : void\n</code></pre>  arguments  <ol> <li><code>int $count</code> The number of elements to fill.</li> <li><code>float $value</code> That value that will be filled in.</li> </ol>  returns   <p><code>void</code></p>   <p>Example:</p> <pre><code>$buffer = new FloatBuffer;\n$buffer-&gt;fill(5, 3);\nvar_dump($buffer); // [3, 3, 3, 3, 3]\n</code></pre>  <p>Note</p> <p>Fill will never shrink a buffer down, meaing when you aleady pushed 10 values in,  and then decide to fill 4 values, the other 6 values will remain at the end.</p>","location":"API/Buffer/FloatBuffer.html#fill"},{"title":"<code>reserve</code>","text":"<p>Reserves the $size amount of space. Values are still undefined.</p> <pre><code>function reserve(int $size) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$size</code> The number of elements to reserve space for.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/FloatBuffer.html#reserve"},{"title":"<code>clear</code>","text":"<p>Will clear the Buffer, internally this will release all allocated data. Meaning any reserved space will be freed.</p> <pre><code>function clear() : void\n</code></pre>  returns  <p><code>void</code> </p>","location":"API/Buffer/FloatBuffer.html#clear"},{"title":"<code>size</code>","text":"<p>Returns the actual size / number of elements of the buffer.</p> <pre><code>function size() : int\n</code></pre>  returns  <p><code>int</code> buffer size in element count (not bytes)</p>","location":"API/Buffer/FloatBuffer.html#size"},{"title":"<code>capacity</code>","text":"<p>Returns the current reserved space of the buffer.</p> <pre><code>function capacity() : int\n</code></pre>  returns  <p><code>int</code> buffer space in element count (not bytes)</p>","location":"API/Buffer/FloatBuffer.html#capacity"},{"title":"HFloatBuffer","text":"<p>The class <code>GL\\Buffer\\HFloatBuffer</code> comes with the PHP-GLFW extension to more efficiently  handle large arrays of <code>GLhalf</code> values (<code>int</code> in php).</p> <p>Don't confuse these objects with actual GPU buffers.</p> <p><code>HFloatBuffer</code> stores an array of real <code>GLhalf</code> values internally, which saves a lot of memory and makes interaction with the GL API a lot easier. An instance of this object can be used similarly to an array but comes with obvious limitations. The internal implementation is similar to c++ std::vector, this means you do not have to  specify the exact size / num of elements when constructing the object.</p> <pre><code>namespace GL\\Buffer\n{\n    class HFloatBuffer implements BufferInterface {}\n}\n</code></pre>","location":"API/Buffer/HFloatBuffer.html"},{"title":"Usage","text":"<p>Again the object can be used similarly to an array, but it's not a hash map,  so all keys have to be of type <code>int</code>. They also have to be in order and explicitly created.</p> <pre><code>use GL\\Buffer\\HFloatBuffer;\n\n$buffer = new HFloatBuffer;\n\n// values can be pushed into the array using subscript\n$buffer[] = 42;\n$buffer[] = 123;\n\n// values can be accessed like an array\necho $buffer[0]; // 42 \n\n// values can be modifed like an array\n// just make sure the used index actually exists, \n// it will NOT be created implicitly!\n$buffer[0] = 8;\n\n// dumping the buffer will display the first 127 value\nvar_dump($buffer);\n</code></pre>  <p>Note</p> <p>The buffer object resizes itself logarithmically, so if you are planning to insert 10 million elements, be sure to call the <code>reserve</code> method on the object first. As you might guess, it will reserve the  given space, ensuring that the internal buffers are not unnecessarily resized multiple times.</p>","location":"API/Buffer/HFloatBuffer.html#usage"},{"title":"Construct from PHP Array","text":"<p>For ease of use, the <code>HFloatBuffer</code> constructor accepts a PHP array which will be pushed  value by value into the buffer. The constructor does a sanity check, so you will receive an error when  your array contains invalid values.</p> <pre><code>$buffer = new HFloatBuffer([\n    42, 123, 8 \n]);\n</code></pre>","location":"API/Buffer/HFloatBuffer.html#construct-from-php-array"},{"title":"Methods","text":"<p>The <code>HFloatBuffer</code> class exposes the following methods to userland.</p>","location":"API/Buffer/HFloatBuffer.html#methods"},{"title":"<code>push</code>","text":"<p>pushes a value into the buffer, this is exactly the same as when you would write <code>$buffer[] = 123</code>.</p> <pre><code>function push(int $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$value</code> The value to be pushed into the buffer.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/HFloatBuffer.html#push"},{"title":"<code>pushArray</code>","text":"<p>pushes an array of values into the buffer. This works the same as when you pass inital data to the constructor.</p> <pre><code>function pushArray(array $values) : void\n</code></pre>  arguments  <ol> <li><code>int[]</code> <code>$values</code> The values to be pushed into the buffer.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/HFloatBuffer.html#pusharray"},{"title":"<code>fill</code>","text":"<p>Fills the buffer with <code>$count</code> amount of values. The second argument is the value that is filled in.</p> <pre><code>function fill(int $count, int $value) : void\n</code></pre>  arguments  <ol> <li><code>int $count</code> The number of elements to fill.</li> <li><code>int $value</code> That value that will be filled in.</li> </ol>  returns   <p><code>void</code></p>   <p>Example:</p> <pre><code>$buffer = new HFloatBuffer;\n$buffer-&gt;fill(5, 3);\nvar_dump($buffer); // [3, 3, 3, 3, 3]\n</code></pre>  <p>Note</p> <p>Fill will never shrink a buffer down, meaing when you aleady pushed 10 values in,  and then decide to fill 4 values, the other 6 values will remain at the end.</p>","location":"API/Buffer/HFloatBuffer.html#fill"},{"title":"<code>reserve</code>","text":"<p>Reserves the $size amount of space. Values are still undefined.</p> <pre><code>function reserve(int $size) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$size</code> The number of elements to reserve space for.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/HFloatBuffer.html#reserve"},{"title":"<code>clear</code>","text":"<p>Will clear the Buffer, internally this will release all allocated data. Meaning any reserved space will be freed.</p> <pre><code>function clear() : void\n</code></pre>  returns  <p><code>void</code> </p>","location":"API/Buffer/HFloatBuffer.html#clear"},{"title":"<code>size</code>","text":"<p>Returns the actual size / number of elements of the buffer.</p> <pre><code>function size() : int\n</code></pre>  returns  <p><code>int</code> buffer size in element count (not bytes)</p>","location":"API/Buffer/HFloatBuffer.html#size"},{"title":"<code>capacity</code>","text":"<p>Returns the current reserved space of the buffer.</p> <pre><code>function capacity() : int\n</code></pre>  returns  <p><code>int</code> buffer space in element count (not bytes)</p>","location":"API/Buffer/HFloatBuffer.html#capacity"},{"title":"IntBuffer","text":"<p>The class <code>GL\\Buffer\\IntBuffer</code> comes with the PHP-GLFW extension to more efficiently  handle large arrays of <code>GLint</code> values (<code>int</code> in php).</p> <p>Don't confuse these objects with actual GPU buffers.</p> <p><code>IntBuffer</code> stores an array of real <code>GLint</code> values internally, which saves a lot of memory and makes interaction with the GL API a lot easier. An instance of this object can be used similarly to an array but comes with obvious limitations. The internal implementation is similar to c++ std::vector, this means you do not have to  specify the exact size / num of elements when constructing the object.</p> <pre><code>namespace GL\\Buffer\n{\n    class IntBuffer implements BufferInterface {}\n}\n</code></pre>","location":"API/Buffer/IntBuffer.html"},{"title":"Usage","text":"<p>Again the object can be used similarly to an array, but it's not a hash map,  so all keys have to be of type <code>int</code>. They also have to be in order and explicitly created.</p> <pre><code>use GL\\Buffer\\IntBuffer;\n\n$buffer = new IntBuffer;\n\n// values can be pushed into the array using subscript\n$buffer[] = 42;\n$buffer[] = 123;\n\n// values can be accessed like an array\necho $buffer[0]; // 42 \n\n// values can be modifed like an array\n// just make sure the used index actually exists, \n// it will NOT be created implicitly!\n$buffer[0] = 8;\n\n// dumping the buffer will display the first 127 value\nvar_dump($buffer);\n</code></pre>  <p>Note</p> <p>The buffer object resizes itself logarithmically, so if you are planning to insert 10 million elements, be sure to call the <code>reserve</code> method on the object first. As you might guess, it will reserve the  given space, ensuring that the internal buffers are not unnecessarily resized multiple times.</p>","location":"API/Buffer/IntBuffer.html#usage"},{"title":"Construct from PHP Array","text":"<p>For ease of use, the <code>IntBuffer</code> constructor accepts a PHP array which will be pushed  value by value into the buffer. The constructor does a sanity check, so you will receive an error when  your array contains invalid values.</p> <pre><code>$buffer = new IntBuffer([\n    42, 123, 8 \n]);\n</code></pre>","location":"API/Buffer/IntBuffer.html#construct-from-php-array"},{"title":"Methods","text":"<p>The <code>IntBuffer</code> class exposes the following methods to userland.</p>","location":"API/Buffer/IntBuffer.html#methods"},{"title":"<code>push</code>","text":"<p>pushes a value into the buffer, this is exactly the same as when you would write <code>$buffer[] = 123</code>.</p> <pre><code>function push(int $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$value</code> The value to be pushed into the buffer.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/IntBuffer.html#push"},{"title":"<code>pushArray</code>","text":"<p>pushes an array of values into the buffer. This works the same as when you pass inital data to the constructor.</p> <pre><code>function pushArray(array $values) : void\n</code></pre>  arguments  <ol> <li><code>int[]</code> <code>$values</code> The values to be pushed into the buffer.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/IntBuffer.html#pusharray"},{"title":"<code>fill</code>","text":"<p>Fills the buffer with <code>$count</code> amount of values. The second argument is the value that is filled in.</p> <pre><code>function fill(int $count, int $value) : void\n</code></pre>  arguments  <ol> <li><code>int $count</code> The number of elements to fill.</li> <li><code>int $value</code> That value that will be filled in.</li> </ol>  returns   <p><code>void</code></p>   <p>Example:</p> <pre><code>$buffer = new IntBuffer;\n$buffer-&gt;fill(5, 3);\nvar_dump($buffer); // [3, 3, 3, 3, 3]\n</code></pre>  <p>Note</p> <p>Fill will never shrink a buffer down, meaing when you aleady pushed 10 values in,  and then decide to fill 4 values, the other 6 values will remain at the end.</p>","location":"API/Buffer/IntBuffer.html#fill"},{"title":"<code>reserve</code>","text":"<p>Reserves the $size amount of space. Values are still undefined.</p> <pre><code>function reserve(int $size) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$size</code> The number of elements to reserve space for.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/IntBuffer.html#reserve"},{"title":"<code>clear</code>","text":"<p>Will clear the Buffer, internally this will release all allocated data. Meaning any reserved space will be freed.</p> <pre><code>function clear() : void\n</code></pre>  returns  <p><code>void</code> </p>","location":"API/Buffer/IntBuffer.html#clear"},{"title":"<code>size</code>","text":"<p>Returns the actual size / number of elements of the buffer.</p> <pre><code>function size() : int\n</code></pre>  returns  <p><code>int</code> buffer size in element count (not bytes)</p>","location":"API/Buffer/IntBuffer.html#size"},{"title":"<code>capacity</code>","text":"<p>Returns the current reserved space of the buffer.</p> <pre><code>function capacity() : int\n</code></pre>  returns  <p><code>int</code> buffer space in element count (not bytes)</p>","location":"API/Buffer/IntBuffer.html#capacity"},{"title":"ShortBuffer","text":"<p>The class <code>GL\\Buffer\\ShortBuffer</code> comes with the PHP-GLFW extension to more efficiently  handle large arrays of <code>GLshort</code> values (<code>int</code> in php).</p> <p>Don't confuse these objects with actual GPU buffers.</p> <p><code>ShortBuffer</code> stores an array of real <code>GLshort</code> values internally, which saves a lot of memory and makes interaction with the GL API a lot easier. An instance of this object can be used similarly to an array but comes with obvious limitations. The internal implementation is similar to c++ std::vector, this means you do not have to  specify the exact size / num of elements when constructing the object.</p> <pre><code>namespace GL\\Buffer\n{\n    class ShortBuffer implements BufferInterface {}\n}\n</code></pre>","location":"API/Buffer/ShortBuffer.html"},{"title":"Usage","text":"<p>Again the object can be used similarly to an array, but it's not a hash map,  so all keys have to be of type <code>int</code>. They also have to be in order and explicitly created.</p> <pre><code>use GL\\Buffer\\ShortBuffer;\n\n$buffer = new ShortBuffer;\n\n// values can be pushed into the array using subscript\n$buffer[] = 42;\n$buffer[] = 123;\n\n// values can be accessed like an array\necho $buffer[0]; // 42 \n\n// values can be modifed like an array\n// just make sure the used index actually exists, \n// it will NOT be created implicitly!\n$buffer[0] = 8;\n\n// dumping the buffer will display the first 127 value\nvar_dump($buffer);\n</code></pre>  <p>Note</p> <p>The buffer object resizes itself logarithmically, so if you are planning to insert 10 million elements, be sure to call the <code>reserve</code> method on the object first. As you might guess, it will reserve the  given space, ensuring that the internal buffers are not unnecessarily resized multiple times.</p>","location":"API/Buffer/ShortBuffer.html#usage"},{"title":"Construct from PHP Array","text":"<p>For ease of use, the <code>ShortBuffer</code> constructor accepts a PHP array which will be pushed  value by value into the buffer. The constructor does a sanity check, so you will receive an error when  your array contains invalid values.</p> <pre><code>$buffer = new ShortBuffer([\n    42, 123, 8 \n]);\n</code></pre>","location":"API/Buffer/ShortBuffer.html#construct-from-php-array"},{"title":"Methods","text":"<p>The <code>ShortBuffer</code> class exposes the following methods to userland.</p>","location":"API/Buffer/ShortBuffer.html#methods"},{"title":"<code>push</code>","text":"<p>pushes a value into the buffer, this is exactly the same as when you would write <code>$buffer[] = 123</code>.</p> <pre><code>function push(int $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$value</code> The value to be pushed into the buffer.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/ShortBuffer.html#push"},{"title":"<code>pushArray</code>","text":"<p>pushes an array of values into the buffer. This works the same as when you pass inital data to the constructor.</p> <pre><code>function pushArray(array $values) : void\n</code></pre>  arguments  <ol> <li><code>int[]</code> <code>$values</code> The values to be pushed into the buffer.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/ShortBuffer.html#pusharray"},{"title":"<code>fill</code>","text":"<p>Fills the buffer with <code>$count</code> amount of values. The second argument is the value that is filled in.</p> <pre><code>function fill(int $count, int $value) : void\n</code></pre>  arguments  <ol> <li><code>int $count</code> The number of elements to fill.</li> <li><code>int $value</code> That value that will be filled in.</li> </ol>  returns   <p><code>void</code></p>   <p>Example:</p> <pre><code>$buffer = new ShortBuffer;\n$buffer-&gt;fill(5, 3);\nvar_dump($buffer); // [3, 3, 3, 3, 3]\n</code></pre>  <p>Note</p> <p>Fill will never shrink a buffer down, meaing when you aleady pushed 10 values in,  and then decide to fill 4 values, the other 6 values will remain at the end.</p>","location":"API/Buffer/ShortBuffer.html#fill"},{"title":"<code>reserve</code>","text":"<p>Reserves the $size amount of space. Values are still undefined.</p> <pre><code>function reserve(int $size) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$size</code> The number of elements to reserve space for.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/ShortBuffer.html#reserve"},{"title":"<code>clear</code>","text":"<p>Will clear the Buffer, internally this will release all allocated data. Meaning any reserved space will be freed.</p> <pre><code>function clear() : void\n</code></pre>  returns  <p><code>void</code> </p>","location":"API/Buffer/ShortBuffer.html#clear"},{"title":"<code>size</code>","text":"<p>Returns the actual size / number of elements of the buffer.</p> <pre><code>function size() : int\n</code></pre>  returns  <p><code>int</code> buffer size in element count (not bytes)</p>","location":"API/Buffer/ShortBuffer.html#size"},{"title":"<code>capacity</code>","text":"<p>Returns the current reserved space of the buffer.</p> <pre><code>function capacity() : int\n</code></pre>  returns  <p><code>int</code> buffer space in element count (not bytes)</p>","location":"API/Buffer/ShortBuffer.html#capacity"},{"title":"UByteBuffer","text":"<p>The class <code>GL\\Buffer\\UByteBuffer</code> comes with the PHP-GLFW extension to more efficiently  handle large arrays of <code>GLubyte</code> values (<code>int</code> in php).</p> <p>Don't confuse these objects with actual GPU buffers.</p> <p><code>UByteBuffer</code> stores an array of real <code>GLubyte</code> values internally, which saves a lot of memory and makes interaction with the GL API a lot easier. An instance of this object can be used similarly to an array but comes with obvious limitations. The internal implementation is similar to c++ std::vector, this means you do not have to  specify the exact size / num of elements when constructing the object.</p> <pre><code>namespace GL\\Buffer\n{\n    class UByteBuffer implements BufferInterface {}\n}\n</code></pre>","location":"API/Buffer/UByteBuffer.html"},{"title":"Usage","text":"<p>Again the object can be used similarly to an array, but it's not a hash map,  so all keys have to be of type <code>int</code>. They also have to be in order and explicitly created.</p> <pre><code>use GL\\Buffer\\UByteBuffer;\n\n$buffer = new UByteBuffer;\n\n// values can be pushed into the array using subscript\n$buffer[] = 42;\n$buffer[] = 123;\n\n// values can be accessed like an array\necho $buffer[0]; // 42 \n\n// values can be modifed like an array\n// just make sure the used index actually exists, \n// it will NOT be created implicitly!\n$buffer[0] = 8;\n\n// dumping the buffer will display the first 127 value\nvar_dump($buffer);\n</code></pre>  <p>Note</p> <p>The buffer object resizes itself logarithmically, so if you are planning to insert 10 million elements, be sure to call the <code>reserve</code> method on the object first. As you might guess, it will reserve the  given space, ensuring that the internal buffers are not unnecessarily resized multiple times.</p>","location":"API/Buffer/UByteBuffer.html#usage"},{"title":"Construct from PHP Array","text":"<p>For ease of use, the <code>UByteBuffer</code> constructor accepts a PHP array which will be pushed  value by value into the buffer. The constructor does a sanity check, so you will receive an error when  your array contains invalid values.</p> <pre><code>$buffer = new UByteBuffer([\n    42, 123, 8 \n]);\n</code></pre>","location":"API/Buffer/UByteBuffer.html#construct-from-php-array"},{"title":"Methods","text":"<p>The <code>UByteBuffer</code> class exposes the following methods to userland.</p>","location":"API/Buffer/UByteBuffer.html#methods"},{"title":"<code>push</code>","text":"<p>pushes a value into the buffer, this is exactly the same as when you would write <code>$buffer[] = 123</code>.</p> <pre><code>function push(int $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$value</code> The value to be pushed into the buffer.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/UByteBuffer.html#push"},{"title":"<code>pushArray</code>","text":"<p>pushes an array of values into the buffer. This works the same as when you pass inital data to the constructor.</p> <pre><code>function pushArray(array $values) : void\n</code></pre>  arguments  <ol> <li><code>int[]</code> <code>$values</code> The values to be pushed into the buffer.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/UByteBuffer.html#pusharray"},{"title":"<code>fill</code>","text":"<p>Fills the buffer with <code>$count</code> amount of values. The second argument is the value that is filled in.</p> <pre><code>function fill(int $count, int $value) : void\n</code></pre>  arguments  <ol> <li><code>int $count</code> The number of elements to fill.</li> <li><code>int $value</code> That value that will be filled in.</li> </ol>  returns   <p><code>void</code></p>   <p>Example:</p> <pre><code>$buffer = new UByteBuffer;\n$buffer-&gt;fill(5, 3);\nvar_dump($buffer); // [3, 3, 3, 3, 3]\n</code></pre>  <p>Note</p> <p>Fill will never shrink a buffer down, meaing when you aleady pushed 10 values in,  and then decide to fill 4 values, the other 6 values will remain at the end.</p>","location":"API/Buffer/UByteBuffer.html#fill"},{"title":"<code>reserve</code>","text":"<p>Reserves the $size amount of space. Values are still undefined.</p> <pre><code>function reserve(int $size) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$size</code> The number of elements to reserve space for.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/UByteBuffer.html#reserve"},{"title":"<code>clear</code>","text":"<p>Will clear the Buffer, internally this will release all allocated data. Meaning any reserved space will be freed.</p> <pre><code>function clear() : void\n</code></pre>  returns  <p><code>void</code> </p>","location":"API/Buffer/UByteBuffer.html#clear"},{"title":"<code>size</code>","text":"<p>Returns the actual size / number of elements of the buffer.</p> <pre><code>function size() : int\n</code></pre>  returns  <p><code>int</code> buffer size in element count (not bytes)</p>","location":"API/Buffer/UByteBuffer.html#size"},{"title":"<code>capacity</code>","text":"<p>Returns the current reserved space of the buffer.</p> <pre><code>function capacity() : int\n</code></pre>  returns  <p><code>int</code> buffer space in element count (not bytes)</p>","location":"API/Buffer/UByteBuffer.html#capacity"},{"title":"UIntBuffer","text":"<p>The class <code>GL\\Buffer\\UIntBuffer</code> comes with the PHP-GLFW extension to more efficiently  handle large arrays of <code>GLuint</code> values (<code>int</code> in php).</p> <p>Don't confuse these objects with actual GPU buffers.</p> <p><code>UIntBuffer</code> stores an array of real <code>GLuint</code> values internally, which saves a lot of memory and makes interaction with the GL API a lot easier. An instance of this object can be used similarly to an array but comes with obvious limitations. The internal implementation is similar to c++ std::vector, this means you do not have to  specify the exact size / num of elements when constructing the object.</p> <pre><code>namespace GL\\Buffer\n{\n    class UIntBuffer implements BufferInterface {}\n}\n</code></pre>","location":"API/Buffer/UIntBuffer.html"},{"title":"Usage","text":"<p>Again the object can be used similarly to an array, but it's not a hash map,  so all keys have to be of type <code>int</code>. They also have to be in order and explicitly created.</p> <pre><code>use GL\\Buffer\\UIntBuffer;\n\n$buffer = new UIntBuffer;\n\n// values can be pushed into the array using subscript\n$buffer[] = 42;\n$buffer[] = 123;\n\n// values can be accessed like an array\necho $buffer[0]; // 42 \n\n// values can be modifed like an array\n// just make sure the used index actually exists, \n// it will NOT be created implicitly!\n$buffer[0] = 8;\n\n// dumping the buffer will display the first 127 value\nvar_dump($buffer);\n</code></pre>  <p>Note</p> <p>The buffer object resizes itself logarithmically, so if you are planning to insert 10 million elements, be sure to call the <code>reserve</code> method on the object first. As you might guess, it will reserve the  given space, ensuring that the internal buffers are not unnecessarily resized multiple times.</p>","location":"API/Buffer/UIntBuffer.html#usage"},{"title":"Construct from PHP Array","text":"<p>For ease of use, the <code>UIntBuffer</code> constructor accepts a PHP array which will be pushed  value by value into the buffer. The constructor does a sanity check, so you will receive an error when  your array contains invalid values.</p> <pre><code>$buffer = new UIntBuffer([\n    42, 123, 8 \n]);\n</code></pre>","location":"API/Buffer/UIntBuffer.html#construct-from-php-array"},{"title":"Methods","text":"<p>The <code>UIntBuffer</code> class exposes the following methods to userland.</p>","location":"API/Buffer/UIntBuffer.html#methods"},{"title":"<code>push</code>","text":"<p>pushes a value into the buffer, this is exactly the same as when you would write <code>$buffer[] = 123</code>.</p> <pre><code>function push(int $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$value</code> The value to be pushed into the buffer.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/UIntBuffer.html#push"},{"title":"<code>pushArray</code>","text":"<p>pushes an array of values into the buffer. This works the same as when you pass inital data to the constructor.</p> <pre><code>function pushArray(array $values) : void\n</code></pre>  arguments  <ol> <li><code>int[]</code> <code>$values</code> The values to be pushed into the buffer.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/UIntBuffer.html#pusharray"},{"title":"<code>fill</code>","text":"<p>Fills the buffer with <code>$count</code> amount of values. The second argument is the value that is filled in.</p> <pre><code>function fill(int $count, int $value) : void\n</code></pre>  arguments  <ol> <li><code>int $count</code> The number of elements to fill.</li> <li><code>int $value</code> That value that will be filled in.</li> </ol>  returns   <p><code>void</code></p>   <p>Example:</p> <pre><code>$buffer = new UIntBuffer;\n$buffer-&gt;fill(5, 3);\nvar_dump($buffer); // [3, 3, 3, 3, 3]\n</code></pre>  <p>Note</p> <p>Fill will never shrink a buffer down, meaing when you aleady pushed 10 values in,  and then decide to fill 4 values, the other 6 values will remain at the end.</p>","location":"API/Buffer/UIntBuffer.html#fill"},{"title":"<code>reserve</code>","text":"<p>Reserves the $size amount of space. Values are still undefined.</p> <pre><code>function reserve(int $size) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$size</code> The number of elements to reserve space for.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/UIntBuffer.html#reserve"},{"title":"<code>clear</code>","text":"<p>Will clear the Buffer, internally this will release all allocated data. Meaning any reserved space will be freed.</p> <pre><code>function clear() : void\n</code></pre>  returns  <p><code>void</code> </p>","location":"API/Buffer/UIntBuffer.html#clear"},{"title":"<code>size</code>","text":"<p>Returns the actual size / number of elements of the buffer.</p> <pre><code>function size() : int\n</code></pre>  returns  <p><code>int</code> buffer size in element count (not bytes)</p>","location":"API/Buffer/UIntBuffer.html#size"},{"title":"<code>capacity</code>","text":"<p>Returns the current reserved space of the buffer.</p> <pre><code>function capacity() : int\n</code></pre>  returns  <p><code>int</code> buffer space in element count (not bytes)</p>","location":"API/Buffer/UIntBuffer.html#capacity"},{"title":"UShortBuffer","text":"<p>The class <code>GL\\Buffer\\UShortBuffer</code> comes with the PHP-GLFW extension to more efficiently  handle large arrays of <code>GLushort</code> values (<code>int</code> in php).</p> <p>Don't confuse these objects with actual GPU buffers.</p> <p><code>UShortBuffer</code> stores an array of real <code>GLushort</code> values internally, which saves a lot of memory and makes interaction with the GL API a lot easier. An instance of this object can be used similarly to an array but comes with obvious limitations. The internal implementation is similar to c++ std::vector, this means you do not have to  specify the exact size / num of elements when constructing the object.</p> <pre><code>namespace GL\\Buffer\n{\n    class UShortBuffer implements BufferInterface {}\n}\n</code></pre>","location":"API/Buffer/UShortBuffer.html"},{"title":"Usage","text":"<p>Again the object can be used similarly to an array, but it's not a hash map,  so all keys have to be of type <code>int</code>. They also have to be in order and explicitly created.</p> <pre><code>use GL\\Buffer\\UShortBuffer;\n\n$buffer = new UShortBuffer;\n\n// values can be pushed into the array using subscript\n$buffer[] = 42;\n$buffer[] = 123;\n\n// values can be accessed like an array\necho $buffer[0]; // 42 \n\n// values can be modifed like an array\n// just make sure the used index actually exists, \n// it will NOT be created implicitly!\n$buffer[0] = 8;\n\n// dumping the buffer will display the first 127 value\nvar_dump($buffer);\n</code></pre>  <p>Note</p> <p>The buffer object resizes itself logarithmically, so if you are planning to insert 10 million elements, be sure to call the <code>reserve</code> method on the object first. As you might guess, it will reserve the  given space, ensuring that the internal buffers are not unnecessarily resized multiple times.</p>","location":"API/Buffer/UShortBuffer.html#usage"},{"title":"Construct from PHP Array","text":"<p>For ease of use, the <code>UShortBuffer</code> constructor accepts a PHP array which will be pushed  value by value into the buffer. The constructor does a sanity check, so you will receive an error when  your array contains invalid values.</p> <pre><code>$buffer = new UShortBuffer([\n    42, 123, 8 \n]);\n</code></pre>","location":"API/Buffer/UShortBuffer.html#construct-from-php-array"},{"title":"Methods","text":"<p>The <code>UShortBuffer</code> class exposes the following methods to userland.</p>","location":"API/Buffer/UShortBuffer.html#methods"},{"title":"<code>push</code>","text":"<p>pushes a value into the buffer, this is exactly the same as when you would write <code>$buffer[] = 123</code>.</p> <pre><code>function push(int $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$value</code> The value to be pushed into the buffer.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/UShortBuffer.html#push"},{"title":"<code>pushArray</code>","text":"<p>pushes an array of values into the buffer. This works the same as when you pass inital data to the constructor.</p> <pre><code>function pushArray(array $values) : void\n</code></pre>  arguments  <ol> <li><code>int[]</code> <code>$values</code> The values to be pushed into the buffer.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/UShortBuffer.html#pusharray"},{"title":"<code>fill</code>","text":"<p>Fills the buffer with <code>$count</code> amount of values. The second argument is the value that is filled in.</p> <pre><code>function fill(int $count, int $value) : void\n</code></pre>  arguments  <ol> <li><code>int $count</code> The number of elements to fill.</li> <li><code>int $value</code> That value that will be filled in.</li> </ol>  returns   <p><code>void</code></p>   <p>Example:</p> <pre><code>$buffer = new UShortBuffer;\n$buffer-&gt;fill(5, 3);\nvar_dump($buffer); // [3, 3, 3, 3, 3]\n</code></pre>  <p>Note</p> <p>Fill will never shrink a buffer down, meaing when you aleady pushed 10 values in,  and then decide to fill 4 values, the other 6 values will remain at the end.</p>","location":"API/Buffer/UShortBuffer.html#fill"},{"title":"<code>reserve</code>","text":"<p>Reserves the $size amount of space. Values are still undefined.</p> <pre><code>function reserve(int $size) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$size</code> The number of elements to reserve space for.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Buffer/UShortBuffer.html#reserve"},{"title":"<code>clear</code>","text":"<p>Will clear the Buffer, internally this will release all allocated data. Meaning any reserved space will be freed.</p> <pre><code>function clear() : void\n</code></pre>  returns  <p><code>void</code> </p>","location":"API/Buffer/UShortBuffer.html#clear"},{"title":"<code>size</code>","text":"<p>Returns the actual size / number of elements of the buffer.</p> <pre><code>function size() : int\n</code></pre>  returns  <p><code>int</code> buffer size in element count (not bytes)</p>","location":"API/Buffer/UShortBuffer.html#size"},{"title":"<code>capacity</code>","text":"<p>Returns the current reserved space of the buffer.</p> <pre><code>function capacity() : int\n</code></pre>  returns  <p><code>int</code> buffer space in element count (not bytes)</p>","location":"API/Buffer/UShortBuffer.html#capacity"},{"title":"glfwCreateStandardCursor","text":"<p>Creates a cursor with a standard shape.</p> <pre><code>function glfwCreateStandardCursor(int $shape) : \\GLFWcursor\n</code></pre> <p>Returns a cursor with a <code>standard shape</code>, that can be set for a window with <code>glfwSetCursor</code>.</p>  arguments  <ol> <li><code>int</code> <code>$shape</code> One of the <code>standard shapes</code>.</li> </ol>  returns  <p><code>\\GLFWcursor</code> A new cursor ready to use or <code>NULL</code> if an <code>error</code> occurred.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwCreateStandardCursor.html"},{"title":"glfwCreateWindow","text":"<p>Creates a window and its associated context.</p> <pre><code>function glfwCreateWindow(int $width, int $height, string $title, ?\\GLFWmonitor $monitor = \\NULL, ?\\GLFWwindow $share = \\NULL) : \\GLFWwindow\n</code></pre> <p>This function creates a window and its associated OpenGL or OpenGL ES context. Most of the options controlling how the window and its context should be created are specified with <code>window hints</code>.</p> <p>Successful creation does not change which context is current. Before you can use the newly created context, you need to <code>make it current</code>. For information about the <code>share</code> parameter, see <code>context_sharing</code>.</p> <p>The created window, framebuffer and context may differ from what you requested, as not all parameters and hints are <code>hard constraints</code>. This includes the size of the window, especially for full screen windows. To query the actual attributes of the created window, framebuffer and context, see @ref glfwGetWindowAttrib, <code>glfwGetWindowSize</code> and <code>glfwGetFramebufferSize</code>.</p> <p>To create a full screen window, you need to specify the monitor the window will cover. If no monitor is specified, the window will be windowed mode. Unless you have a way for the user to choose a specific monitor, it is recommended that you pick the primary monitor. For more information on how to query connected monitors, see <code>monitor_monitors</code>.</p> <p>For full screen windows, the specified size becomes the resolution of the window's desired video mode. As long as a full screen window is not iconified, the supported video mode most closely matching the desired video mode is set for the specified monitor. For more information about full screen windows, including the creation of so called windowed full screen or borderless full screen windows, see <code>window_windowed_full_screen</code>.</p> <p>Once you have created the window, you can switch it between windowed and full screen mode with <code>glfwSetWindowMonitor</code>. This will not affect its OpenGL or OpenGL ES context.</p> <p>By default, newly created windows use the placement recommended by the window system. To create the window at a specific position, make it initially invisible using the <code>GLFW_VISIBLE</code> window hint, set its <code>position](</code>window_pos<code>) and then [show</code> it.</p> <p>As long as at least one full screen window is not iconified, the screensaver is prohibited from starting.</p> <p>Window systems put limits on window sizes. Very large or very small window dimensions may be overridden by the window system on creation. Check the actual <code>size</code> after creation.</p> <p>The <code>swap interval</code> is not set during window creation and the initial value may vary depending on driver settings and defaults.</p>  arguments  <ol> <li><code>int</code> <code>$width</code> The desired width, in screen coordinates, of the window. This must be greater than zero.</li> <li><code>int</code> <code>$height</code> The desired height, in screen coordinates, of the window. This must be greater than zero.</li> <li><code>string</code> <code>$title</code> The initial, UTF-8 encoded window title.</li> <li><code>?\\GLFWmonitor</code> <code>$monitor</code> The monitor to use for full screen mode, or <code>NULL</code> for windowed mode.</li> <li><code>?\\GLFWwindow</code> <code>$share</code> The window whose context to share resources with, or <code>NULL</code> to not share resources.</li> </ol>  returns  <p><code>\\GLFWwindow</code> The handle of the created window, or <code>NULL</code> if an <code>error</code> occurred.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwCreateWindow.html"},{"title":"glfwDefaultWindowHints","text":"<p>Resets all window hints to their default values.</p> <pre><code>function glfwDefaultWindowHints() : void\n</code></pre> <p>This function resets all window hints to their <code>default values</code>.</p>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwDefaultWindowHints.html"},{"title":"glfwDestroyCursor","text":"<p>Destroys a cursor.</p> <pre><code>function glfwDestroyCursor(\\GLFWcursor $cursor) : void\n</code></pre> <p>This function destroys a cursor previously created with @ref glfwCreateCursor. Any remaining cursors will be destroyed by @ref glfwTerminate.</p> <p>If the specified cursor is current for any window, that window will be reverted to the default cursor. This does not affect the cursor mode.</p>  arguments  <ol> <li><code>\\GLFWcursor</code> <code>$cursor</code> The cursor object to destroy.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwDestroyCursor.html"},{"title":"glfwDestroyWindow","text":"<p>Destroys the specified window and its context.</p> <pre><code>function glfwDestroyWindow(\\GLFWwindow $window) : void\n</code></pre> <p>This function destroys the specified window and its context. On calling this function, no further callbacks will be called for that window.</p> <p>If the context of the specified window is current on the main thread, it is detached before being destroyed.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window to destroy.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwDestroyWindow.html"},{"title":"glfwExtensionSupported","text":"<p>Returns whether the specified extension is available.</p> <pre><code>function glfwExtensionSupported(string $extension) : int\n</code></pre> <p>This function returns whether the specified <code>API extension</code> is supported by the current OpenGL or OpenGL ES context. It searches both for client API extension and context creation API extensions.</p> <p>A context must be current on the calling thread. Calling this function without a current context will cause a <code>GLFW_NO_CURRENT_CONTEXT</code> error.</p> <p>As this functions retrieves and searches one or more extension strings each call, it is recommended that you cache its results if it is going to be used frequently. The extension strings will not change during the lifetime of a context, so there is no danger in doing this.</p> <p>This function does not apply to Vulkan. If you are using Vulkan, see @ref glfwGetRequiredInstanceExtensions, <code>vkEnumerateInstanceExtensionProperties</code> and <code>vkEnumerateDeviceExtensionProperties</code> instead.</p>  arguments  <ol> <li><code>string</code> <code>$extension</code> The ASCII encoded name of the extension.</li> </ol>  returns  <p><code>int</code> <code>GLFW_TRUE</code> if the extension is available, or <code>GLFW_FALSE</code> otherwise.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwExtensionSupported.html"},{"title":"glfwFocusWindow","text":"<p>Brings the specified window to front and sets input focus.</p> <pre><code>function glfwFocusWindow(\\GLFWwindow $window) : void\n</code></pre> <p>This function brings the specified window to front and sets input focus. The window should already be visible and not iconified.</p> <p>By default, both windowed and full screen mode windows are focused when initially created. Set the <code>GLFW_FOCUSED</code> to disable this behavior.</p> <p>Also by default, windowed mode windows are focused when shown with <code>glfwShowWindow</code>. Set the <code>GLFW_FOCUS_ON_SHOW</code> to disable this behavior.</p> <p>Do not use this function to steal focus from other applications unless you are certain that is what the user wants. Focus stealing can be extremely disruptive.</p> <p>For a less disruptive way of getting the user's attention, see <code>attention requests</code>.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window to give input focus.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwFocusWindow.html"},{"title":"glfwGetClipboardString","text":"<p>Returns the contents of the clipboard as a string.</p> <pre><code>function glfwGetClipboardString(\\GLFWwindow $window) : string\n</code></pre> <p>This function returns the contents of the system clipboard, if it contains or is convertible to a UTF-8 encoded string. If the clipboard is empty or if its contents cannot be converted, <code>NULL</code> is returned and a @ref GLFW_FORMAT_UNAVAILABLE error is generated.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> Deprecated. Any valid window or <code>NULL</code>.</li> </ol>  returns  <p><code>string</code> The contents of the clipboard as a UTF-8 encoded string, or <code>NULL</code> if an <code>error</code> occurred.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetClipboardString.html"},{"title":"glfwGetCurrentContext","text":"<p>Returns the window whose context is current on the calling thread.</p> <pre><code>function glfwGetCurrentContext() : \\GLFWwindow\n</code></pre> <p>This function returns the window whose OpenGL or OpenGL ES context is current on the calling thread.</p>  returns  <p><code>\\GLFWwindow</code> The window whose context is current, or <code>NULL</code> if no window's context is current.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetCurrentContext.html"},{"title":"glfwGetCursorPos","text":"<p>Retrieves the position of the cursor relative to the content area of the window.</p> <pre><code>function glfwGetCursorPos(\\GLFWwindow $window, float &amp;$xpos, float &amp;$ypos) : void\n</code></pre> <p>This function returns the position of the cursor, in screen coordinates, relative to the upper-left corner of the content area of the specified window.</p> <p>If the cursor is disabled (with <code>GLFW_CURSOR_DISABLED</code>) then the cursor position is unbounded and limited only by the minimum and maximum values of a <code>double</code>.</p> <p>The coordinate can be converted to their integer equivalents with the <code>floor</code> function. Casting directly to an integer type works for positive coordinates, but fails for negative ones.</p> <p>Any or all of the position arguments may be <code>NULL</code>. If an error occurs, all non-<code>NULL</code> position arguments will be set to zero.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The desired window.</li> <li><code>float</code> <code>$xpos</code> Where to store the cursor x-coordinate, relative to the left edge of the content area, or <code>NULL</code>.</li> <li><code>float</code> <code>$ypos</code> Where to store the cursor y-coordinate, relative to the to top edge of the content area, or <code>NULL</code>.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetCursorPos.html"},{"title":"glfwGetFramebufferSize","text":"<p>Retrieves the size of the framebuffer of the specified window.</p> <pre><code>function glfwGetFramebufferSize(\\GLFWwindow $window, int &amp;$width, int &amp;$height) : void\n</code></pre> <p>This function retrieves the size, in pixels, of the framebuffer of the specified window. If you wish to retrieve the size of the window in screen coordinates, see <code>glfwGetWindowSize</code>.</p> <p>Any or all of the size arguments may be <code>NULL</code>. If an error occurs, all non-<code>NULL</code> size arguments will be set to zero.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose framebuffer to query.</li> <li><code>int</code> <code>$width</code> Where to store the width, in pixels, of the framebuffer, or <code>NULL</code>.</li> <li><code>int</code> <code>$height</code> Where to store the height, in pixels, of the framebuffer, or <code>NULL</code>.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetFramebufferSize.html"},{"title":"glfwGetGamepadAxes","text":"<p>Returns the state of the specified gamepad's axes.</p> <pre><code>function glfwGetGamepadAxes(int $joystick) : array\n</code></pre> <p>If the gamepad is not present, or the given joystick is not a gamepad, this function will return an empty array.</p> <p>The returned array is indexed by the GLFW gamepad axis constants:  - <code>GLFW_GAMEPAD_AXIS_LEFT_X</code>  - <code>GLFW_GAMEPAD_AXIS_LEFT_Y</code>  - <code>GLFW_GAMEPAD_AXIS_RIGHT_X</code>  - <code>GLFW_GAMEPAD_AXIS_RIGHT_Y</code>  - <code>GLFW_GAMEPAD_AXIS_LEFT_TRIGGER</code>  - <code>GLFW_GAMEPAD_AXIS_RIGHT_TRIGGER</code></p>  arguments  <ol> <li><code>int</code> <code>$joystick</code> The joystick to query.</li> </ol>  returns  <p><code>array</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetGamepadAxes.html"},{"title":"glfwGetGamepadButtons","text":"<p>Returns the state of the specified gamepad's buttons.</p> <pre><code>function glfwGetGamepadButtons(int $joystick) : array\n</code></pre> <p>If the gamepad is not present, or the given joystick is not a gamepad, this function will return an empty array.</p> <p>The returned array is indexed by the GLFW gamepad button constants:  - <code>GLFW_GAMEPAD_BUTTON_A</code>  - <code>GLFW_GAMEPAD_BUTTON_B</code>  - <code>GLFW_GAMEPAD_BUTTON_X</code>  - <code>GLFW_GAMEPAD_BUTTON_Y</code>  - <code>GLFW_GAMEPAD_BUTTON_LEFT_BUMPER</code>  - <code>GLFW_GAMEPAD_BUTTON_RIGHT_BUMPER</code>  - <code>GLFW_GAMEPAD_BUTTON_BACK</code>  - <code>GLFW_GAMEPAD_BUTTON_START</code>  - <code>GLFW_GAMEPAD_BUTTON_GUIDE</code>  - <code>GLFW_GAMEPAD_BUTTON_LEFT_THUMB</code>  - <code>GLFW_GAMEPAD_BUTTON_RIGHT_THUMB</code>  - <code>GLFW_GAMEPAD_BUTTON_DPAD_UP</code>  - <code>GLFW_GAMEPAD_BUTTON_DPAD_RIGHT</code>  - <code>GLFW_GAMEPAD_BUTTON_DPAD_DOWN</code>  - <code>GLFW_GAMEPAD_BUTTON_DPAD_LEFT</code></p>  arguments  <ol> <li><code>int</code> <code>$joystick</code> The joystick to query.</li> </ol>  returns  <p><code>array</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetGamepadButtons.html"},{"title":"glfwGetGamepadName","text":"<p>Returns the human-readable gamepad name for the specified joystick.</p> <pre><code>function glfwGetGamepadName(int $jid) : string\n</code></pre> <p>This function returns the human-readable name of the gamepad from the gamepad mapping assigned to the specified joystick.</p> <p>If the specified joystick is not present or does not have a gamepad mapping this function will return <code>NULL</code> but will not generate an error. Call <code>glfwJoystickPresent</code> to check whether it is present regardless of whether it has a mapping.</p>  arguments  <ol> <li><code>int</code> <code>$jid</code> The <code>joystick</code> to query.</li> </ol>  returns  <p><code>string</code> The UTF-8 encoded name of the gamepad, or <code>NULL</code> if the joystick is not present, does not have a mapping or an <code>error</code> occurred.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetGamepadName.html"},{"title":"glfwGetInputMode","text":"<p>Returns the value of an input option for the specified window.</p> <pre><code>function glfwGetInputMode(\\GLFWwindow $window, int $mode) : int\n</code></pre> <p>This function returns the value of an input option for the specified window. The mode must be one of <code>GLFW_CURSOR</code>, <code>GLFW_STICKY_KEYS</code>, <code>GLFW_STICKY_MOUSE_BUTTONS</code>, <code>GLFW_LOCK_KEY_MODS</code> or <code>GLFW_RAW_MOUSE_MOTION</code>.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window to query.</li> <li><code>int</code> <code>$mode</code> One of <code>GLFW_CURSOR</code>, <code>GLFW_STICKY_KEYS</code>, <code>GLFW_STICKY_MOUSE_BUTTONS</code>, <code>GLFW_LOCK_KEY_MODS</code> or <code>GLFW_RAW_MOUSE_MOTION</code>.</li> </ol>  returns  <p><code>int</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetInputMode.html"},{"title":"glfwGetJoystickAxes","text":"<p>Returns the values of all axes of the specified joystick.</p> <pre><code>function glfwGetJoystickAxes(int $jid) : array\n</code></pre> <p>This function returns the values of all axes of the specified joystick. Each element in the array is a value between -1.0 and 1.0.</p> <p>If the specified joystick is not present this function will return <code>NULL</code> but will not generate an error. This can be used instead of first calling <code>glfwJoystickPresent</code>.</p>  arguments  <ol> <li><code>int</code> <code>$jid</code> The <code>joystick</code> to query.</li> </ol>  returns  <p><code>array</code> An array of axis values, or <code>NULL</code> if the joystick is not present or an <code>error</code> occurred.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetJoystickAxes.html"},{"title":"glfwGetJoystickButtons","text":"<p>Returns the state of all buttons of the specified joystick.</p> <pre><code>function glfwGetJoystickButtons(int $jid) : array\n</code></pre> <p>This function returns the state of all buttons of the specified joystick. Each element in the array is either <code>GLFW_PRESS</code> or <code>GLFW_RELEASE</code>.</p> <p>For backward compatibility with earlier versions that did not have @ref glfwGetJoystickHats, the button array also includes all hats, each represented as four buttons. The hats are in the same order as returned by glfwGetJoystickHats and are in the order up, right, down and left. To disable these extra buttons, set the @ref GLFW_JOYSTICK_HAT_BUTTONS init hint before initialization.</p> <p>If the specified joystick is not present this function will return <code>NULL</code> but will not generate an error. This can be used instead of first calling <code>glfwJoystickPresent</code>.</p>  arguments  <ol> <li><code>int</code> <code>$jid</code> The <code>joystick</code> to query.</li> </ol>  returns  <p><code>array</code> An array of button states, or <code>NULL</code> if the joystick is not present or an <code>error</code> occurred.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetJoystickButtons.html"},{"title":"glfwGetJoystickGUID","text":"<p>Returns the SDL compatible GUID of the specified joystick.</p> <pre><code>function glfwGetJoystickGUID(int $jid) : string\n</code></pre> <p>This function returns the SDL compatible GUID, as a UTF-8 encoded hexadecimal string, of the specified joystick. The returned string is allocated and freed by GLFW. You should not free it yourself.</p> <p>The GUID is what connects a joystick to a gamepad mapping. A connected joystick will always have a GUID even if there is no gamepad mapping assigned to it.</p> <p>If the specified joystick is not present this function will return <code>NULL</code> but will not generate an error. This can be used instead of first calling <code>glfwJoystickPresent</code>.</p> <p>The GUID uses the format introduced in SDL 2.0.5. This GUID tries to uniquely identify the make and model of a joystick but does not identify a specific unit, e.g. all wired Xbox 360 controllers will have the same GUID on that platform. The GUID for a unit may vary between platforms depending on what hardware information the platform specific APIs provide.</p>  arguments  <ol> <li><code>int</code> <code>$jid</code> The <code>joystick</code> to query.</li> </ol>  returns  <p><code>string</code> The UTF-8 encoded GUID of the joystick, or <code>NULL</code> if the joystick is not present or an <code>error</code> occurred.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetJoystickGUID.html"},{"title":"glfwGetJoystickName","text":"<p>Returns the name of the specified joystick.</p> <pre><code>function glfwGetJoystickName(int $jid) : string\n</code></pre> <p>This function returns the name, encoded as UTF-8, of the specified joystick. The returned string is allocated and freed by GLFW. You should not free it yourself.</p> <p>If the specified joystick is not present this function will return <code>NULL</code> but will not generate an error. This can be used instead of first calling <code>glfwJoystickPresent</code>.</p>  arguments  <ol> <li><code>int</code> <code>$jid</code> The <code>joystick</code> to query.</li> </ol>  returns  <p><code>string</code> The UTF-8 encoded name of the joystick, or <code>NULL</code> if the joystick is not present or an <code>error</code> occurred.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetJoystickName.html"},{"title":"glfwGetKey","text":"<p>Returns the last reported state of a keyboard key for the specified window.</p> <pre><code>function glfwGetKey(\\GLFWwindow $window, int $key) : int\n</code></pre> <p>This function returns the last state reported for the specified key to the specified window. The returned state is one of <code>GLFW_PRESS</code> or <code>GLFW_RELEASE</code>. The action <code>GLFW_REPEAT</code> is only reported to the key callback.</p> <p>If the <code>GLFW_STICKY_KEYS</code> input mode is enabled, this function returns <code>GLFW_PRESS</code> the first time you call it for a key that was pressed, even if that key has already been released.</p> <p>The key functions deal with physical keys, with <code>key tokens</code> named after their use on the standard US keyboard layout. If you want to input text, use the Unicode character callback instead.</p> <p>The <code>modifier key bit masks</code> are not key tokens and cannot be used with this function.</p> <p>Do not use this function to implement <code>text input</code>.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The desired window.</li> <li><code>int</code> <code>$key</code> The desired <code>keyboard key</code>. <code>GLFW_KEY_UNKNOWN</code> is not a valid key for this function.</li> </ol>  returns  <p><code>int</code> One of <code>GLFW_PRESS</code> or <code>GLFW_RELEASE</code>.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetKey.html"},{"title":"glfwGetKeyName","text":"<p>Returns the layout-specific name of the specified printable key.</p> <pre><code>function glfwGetKeyName(int $key, int $scancode) : string\n</code></pre> <p>This function returns the name of the specified printable key, encoded as UTF-8. This is typically the character that key would produce without any modifier keys, intended for displaying key bindings to the user. For dead keys, it is typically the diacritic it would add to a character.</p> <p>Do not use this function for <code>text input</code>. You will break text input for many languages even if it happens to work for yours.</p> <p>If the key is <code>GLFW_KEY_UNKNOWN</code>, the scancode is used to identify the key, otherwise the scancode is ignored. If you specify a non-printable key, or <code>GLFW_KEY_UNKNOWN</code> and a scancode that maps to a non-printable key, this function returns <code>NULL</code> but does not emit an error.</p> <p>This behavior allows you to always pass in the arguments in the <code>key callback</code> without modification.</p> <p>The printable keys are: - <code>GLFW_KEY_APOSTROPHE</code> - <code>GLFW_KEY_COMMA</code> - <code>GLFW_KEY_MINUS</code> - <code>GLFW_KEY_PERIOD</code> - <code>GLFW_KEY_SLASH</code> - <code>GLFW_KEY_SEMICOLON</code> - <code>GLFW_KEY_EQUAL</code> - <code>GLFW_KEY_LEFT_BRACKET</code> - <code>GLFW_KEY_RIGHT_BRACKET</code> - <code>GLFW_KEY_BACKSLASH</code> - <code>GLFW_KEY_WORLD_1</code> - <code>GLFW_KEY_WORLD_2</code> - <code>GLFW_KEY_0</code> to <code>GLFW_KEY_9</code> - <code>GLFW_KEY_A</code> to <code>GLFW_KEY_Z</code> - <code>GLFW_KEY_KP_0</code> to <code>GLFW_KEY_KP_9</code> - <code>GLFW_KEY_KP_DECIMAL</code> - <code>GLFW_KEY_KP_DIVIDE</code> - <code>GLFW_KEY_KP_MULTIPLY</code> - <code>GLFW_KEY_KP_SUBTRACT</code> - <code>GLFW_KEY_KP_ADD</code> - <code>GLFW_KEY_KP_EQUAL</code></p> <p>Names for printable keys depend on keyboard layout, while names for non-printable keys are the same across layouts but depend on the application language and should be localized along with other user interface text.</p>  arguments  <ol> <li><code>int</code> <code>$key</code> The key to query, or <code>GLFW_KEY_UNKNOWN</code>.</li> <li><code>int</code> <code>$scancode</code> The scancode of the key to query.</li> </ol>  returns  <p><code>string</code> The UTF-8 encoded, layout-specific name of the key, or <code>NULL</code>.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetKeyName.html"},{"title":"glfwGetKeyScancode","text":"<p>Returns the platform-specific scancode of the specified key.</p> <pre><code>function glfwGetKeyScancode(int $key) : int\n</code></pre> <p>This function returns the platform-specific scancode of the specified key.</p> <p>If the key is <code>GLFW_KEY_UNKNOWN</code> or does not exist on the keyboard this method will return <code>-1</code>.</p>  arguments  <ol> <li><code>int</code> <code>$key</code> Any <code>named key</code>.</li> </ol>  returns  <p><code>int</code> The platform-specific scancode for the key, or <code>-1</code> if an <code>error</code> occurred.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetKeyScancode.html"},{"title":"glfwGetMonitorContentScale","text":"<p>Retrieves the content scale for the specified monitor.</p> <pre><code>function glfwGetMonitorContentScale(\\GLFWmonitor $monitor, float &amp;$xscale, float &amp;$yscale) : void\n</code></pre> <p>This function retrieves the content scale for the specified monitor. The content scale is the ratio between the current DPI and the platform's default DPI. This is especially important for text and any UI elements. If the pixel dimensions of your UI scaled by this look appropriate on your machine then it should appear at a reasonable size on other machines regardless of their DPI and scaling settings. This relies on the system DPI and scaling settings being somewhat correct.</p> <p>The content scale may depend on both the monitor resolution and pixel density and on user settings. It may be very different from the raw DPI calculated from the physical size and current resolution.</p>  arguments  <ol> <li><code>\\GLFWmonitor</code> <code>$monitor</code> The monitor to query.</li> <li><code>float</code> <code>$xscale</code> Where to store the x-axis content scale, or <code>NULL</code>.</li> <li><code>float</code> <code>$yscale</code> Where to store the y-axis content scale, or <code>NULL</code>.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetMonitorContentScale.html"},{"title":"glfwGetMonitorName","text":"<p>Returns the name of the specified monitor.</p> <pre><code>function glfwGetMonitorName(\\GLFWmonitor $monitor) : string\n</code></pre> <p>This function returns a human-readable name, encoded as UTF-8, of the specified monitor. The name typically reflects the make and model of the monitor and is not guaranteed to be unique among the connected monitors.</p>  arguments  <ol> <li><code>\\GLFWmonitor</code> <code>$monitor</code> The monitor to query.</li> </ol>  returns  <p><code>string</code> The UTF-8 encoded name of the monitor, or <code>NULL</code> if an <code>error</code> occurred.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetMonitorName.html"},{"title":"glfwGetMonitorPhysicalSize","text":"<p>Returns the physical size of the monitor.</p> <pre><code>function glfwGetMonitorPhysicalSize(\\GLFWmonitor $monitor, int &amp;$widthMM, int &amp;$heightMM) : void\n</code></pre> <p>This function returns the size, in millimetres, of the display area of the specified monitor.</p> <p>Some systems do not provide accurate monitor size information, either because the monitor EDID data is incorrect or because the driver does not report it accurately.</p> <p>Any or all of the size arguments may be <code>NULL</code>. If an error occurs, all non-<code>NULL</code> size arguments will be set to zero.</p>  arguments  <ol> <li><code>\\GLFWmonitor</code> <code>$monitor</code> The monitor to query.</li> <li><code>int</code> <code>$widthMM</code> Where to store the width, in millimetres, of the monitor's display area, or <code>NULL</code>.</li> <li><code>int</code> <code>$heightMM</code> Where to store the height, in millimetres, of the monitor's display area, or <code>NULL</code>.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetMonitorPhysicalSize.html"},{"title":"glfwGetMonitorPos","text":"<p>Returns the position of the monitor's viewport on the virtual screen.</p> <pre><code>function glfwGetMonitorPos(\\GLFWmonitor $monitor, int &amp;$xpos, int &amp;$ypos) : void\n</code></pre> <p>This function returns the position, in screen coordinates, of the upper-left corner of the specified monitor.</p> <p>Any or all of the position arguments may be <code>NULL</code>. If an error occurs, all non-<code>NULL</code> position arguments will be set to zero.</p>  arguments  <ol> <li><code>\\GLFWmonitor</code> <code>$monitor</code> The monitor to query.</li> <li><code>int</code> <code>$xpos</code> Where to store the monitor x-coordinate, or <code>NULL</code>.</li> <li><code>int</code> <code>$ypos</code> Where to store the monitor y-coordinate, or <code>NULL</code>.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetMonitorPos.html"},{"title":"glfwGetMonitorWorkarea","text":"<p>Retrieves the work area of the monitor.</p> <pre><code>function glfwGetMonitorWorkarea(\\GLFWmonitor $monitor, int &amp;$xpos, int &amp;$ypos, int &amp;$width, int &amp;$height) : void\n</code></pre> <p>This function returns the position, in screen coordinates, of the upper-left corner of the work area of the specified monitor along with the work area size in screen coordinates. The work area is defined as the area of the monitor not occluded by the operating system task bar where present. If no task bar exists then the work area is the monitor resolution in screen coordinates.</p> <p>Any or all of the position and size arguments may be <code>NULL</code>. If an error occurs, all non-<code>NULL</code> position and size arguments will be set to zero.</p>  arguments  <ol> <li><code>\\GLFWmonitor</code> <code>$monitor</code> The monitor to query.</li> <li><code>int</code> <code>$xpos</code> Where to store the monitor x-coordinate, or <code>NULL</code>.</li> <li><code>int</code> <code>$ypos</code> Where to store the monitor y-coordinate, or <code>NULL</code>.</li> <li><code>int</code> <code>$width</code> Where to store the monitor width, or <code>NULL</code>.</li> <li><code>int</code> <code>$height</code> Where to store the monitor height, or <code>NULL</code>.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetMonitorWorkarea.html"},{"title":"glfwGetMouseButton","text":"<p>Returns the last reported state of a mouse button for the specified window.</p> <pre><code>function glfwGetMouseButton(\\GLFWwindow $window, int $button) : int\n</code></pre> <p>This function returns the last state reported for the specified mouse button to the specified window. The returned state is one of <code>GLFW_PRESS</code> or <code>GLFW_RELEASE</code>.</p> <p>If the <code>GLFW_STICKY_MOUSE_BUTTONS</code> input mode is enabled, this function returns <code>GLFW_PRESS</code> the first time you call it for a mouse button that was pressed, even if that mouse button has already been released.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The desired window.</li> <li><code>int</code> <code>$button</code> The desired <code>mouse button</code>.</li> </ol>  returns  <p><code>int</code> One of <code>GLFW_PRESS</code> or <code>GLFW_RELEASE</code>.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetMouseButton.html"},{"title":"glfwGetPrimaryMonitor","text":"<p>Returns the primary monitor.</p> <pre><code>function glfwGetPrimaryMonitor() : \\GLFWmonitor\n</code></pre> <p>This function returns the primary monitor. This is usually the monitor where elements like the task bar or global menu bar are located.</p>  returns  <p><code>\\GLFWmonitor</code> The primary monitor, or <code>NULL</code> if no monitors were found or if an <code>error</code> occurred.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetPrimaryMonitor.html"},{"title":"glfwGetTime","text":"<p>Returns the GLFW time.</p> <pre><code>function glfwGetTime() : float\n</code></pre> <p>This function returns the current GLFW time, in seconds. Unless the time has been set using <code>glfwSetTime</code> it measures time elapsed since GLFW was initialized.</p> <p>This function and <code>glfwSetTime</code> are helper functions on top of @ref glfwGetTimerFrequency and <code>glfwGetTimerValue</code>.</p> <p>The resolution of the timer is system dependent, but is usually on the order of a few micro- or nanoseconds. It uses the highest-resolution monotonic time source on each supported platform.</p>  returns  <p><code>float</code> The current time, in seconds, or zero if an <code>error</code> occurred.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetTime.html"},{"title":"glfwGetVersion","text":"<p>Retrieves the version of the GLFW library.</p> <pre><code>function glfwGetVersion(int &amp;$major, int &amp;$minor, int &amp;$rev) : void\n</code></pre> <p>This function retrieves the major, minor and revision numbers of the GLFW library. It is intended for when you are using GLFW as a shared library and want to ensure that you are using the minimum required version.</p> <p>Any or all of the version arguments may be <code>NULL</code>.</p>  arguments  <ol> <li><code>int</code> <code>$major</code> Where to store the major version number, or <code>NULL</code>.</li> <li><code>int</code> <code>$minor</code> Where to store the minor version number, or <code>NULL</code>.</li> <li><code>int</code> <code>$rev</code> Where to store the revision number, or <code>NULL</code>.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetVersion.html"},{"title":"glfwGetVersionString","text":"<p>Returns a string describing the compile-time configuration.</p> <pre><code>function glfwGetVersionString() : string\n</code></pre> <p>This function returns the compile-time generated <code>version string</code> of the GLFW library binary. It describes the version, platform, compiler and any platform-specific compile-time options. It should not be confused with the OpenGL or OpenGL ES version string, queried with <code>glGetString</code>.</p> <p>Do not use the version string to parse the GLFW library version. The <code>glfwGetVersion</code> function provides the version of the running library binary in numerical format.</p>  returns  <p><code>string</code> The ASCII encoded GLFW version string.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetVersionString.html"},{"title":"glfwGetVideoMode","text":"<p>Returns the current mode of the specified monitor.</p> <pre><code>function glfwGetVideoMode(\\GLFWmonitor $monitor) : \\GLFWvidmode\n</code></pre> <p>This function returns the current video mode of the specified monitor. If you have created a full screen window for that monitor, the return value will depend on whether that window is iconified.</p>  arguments  <ol> <li><code>\\GLFWmonitor</code> <code>$monitor</code> The monitor to query.</li> </ol>  returns  <p><code>\\GLFWvidmode</code> The current mode of the monitor, or <code>NULL</code> if an <code>error</code> occurred.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetVideoMode.html"},{"title":"glfwGetVideoModes","text":"<p>Returns the available video modes for the specified monitor.</p> <pre><code>function glfwGetVideoModes(\\GLFWmonitor $monitor) : \\GLFWvidmode\n</code></pre> <p>This function returns an array of all video modes supported by the specified monitor. The returned array is sorted in ascending order, first by color bit depth (the sum of all channel depths), then by resolution area (the product of width and height), then resolution width and finally by refresh rate.</p>  arguments  <ol> <li><code>\\GLFWmonitor</code> <code>$monitor</code> The monitor to query.</li> </ol>  returns  <p><code>\\GLFWvidmode</code> An array of video modes, or <code>NULL</code> if an <code>error</code> occurred.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetVideoModes.html"},{"title":"glfwGetWindowAttrib","text":"<p>Returns an attribute of the specified window.</p> <pre><code>function glfwGetWindowAttrib(\\GLFWwindow $window, int $attrib) : int\n</code></pre> <p>This function returns the value of an attribute of the specified window or its OpenGL or OpenGL ES context.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window to query.</li> <li><code>int</code> <code>$attrib</code> The <code>window attribute</code> whose value to return.</li> </ol>  returns  <p><code>int</code> The value of the attribute, or zero if an <code>error</code> occurred.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetWindowAttrib.html"},{"title":"glfwGetWindowContentScale","text":"<p>Retrieves the content scale for the specified window.</p> <pre><code>function glfwGetWindowContentScale(\\GLFWwindow $window, float &amp;$xscale, float &amp;$yscale) : void\n</code></pre> <p>This function retrieves the content scale for the specified window. The content scale is the ratio between the current DPI and the platform's default DPI. This is especially important for text and any UI elements. If the pixel dimensions of your UI scaled by this look appropriate on your machine then it should appear at a reasonable size on other machines regardless of their DPI and scaling settings. This relies on the system DPI and scaling settings being somewhat correct.</p> <p>On systems where each monitors can have its own content scale, the window content scale will depend on which monitor the system considers the window to be on.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window to query.</li> <li><code>float</code> <code>$xscale</code> Where to store the x-axis content scale, or <code>NULL</code>.</li> <li><code>float</code> <code>$yscale</code> Where to store the y-axis content scale, or <code>NULL</code>.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetWindowContentScale.html"},{"title":"glfwGetWindowFrameSize","text":"<p>Retrieves the size of the frame of the window.</p> <pre><code>function glfwGetWindowFrameSize(\\GLFWwindow $window, int &amp;$left, int &amp;$top, int &amp;$right, int &amp;$bottom) : void\n</code></pre> <p>This function retrieves the size, in screen coordinates, of each edge of the frame of the specified window. This size includes the title bar, if the window has one. The size of the frame may vary depending on the <code>window-related hints</code> used to create it.</p> <p>Because this function retrieves the size of each window frame edge and not the offset along a particular coordinate axis, the retrieved values will always be zero or positive.</p> <p>Any or all of the size arguments may be <code>NULL</code>. If an error occurs, all non-<code>NULL</code> size arguments will be set to zero.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose frame size to query.</li> <li><code>int</code> <code>$left</code> Where to store the size, in screen coordinates, of the left edge of the window frame, or <code>NULL</code>.</li> <li><code>int</code> <code>$top</code> Where to store the size, in screen coordinates, of the top edge of the window frame, or <code>NULL</code>.</li> <li><code>int</code> <code>$right</code> Where to store the size, in screen coordinates, of the right edge of the window frame, or <code>NULL</code>.</li> <li><code>int</code> <code>$bottom</code> Where to store the size, in screen coordinates, of the bottom edge of the window frame, or <code>NULL</code>.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetWindowFrameSize.html"},{"title":"glfwGetWindowMonitor","text":"<p>Returns the monitor that the window uses for full screen mode.</p> <pre><code>function glfwGetWindowMonitor(\\GLFWwindow $window) : \\GLFWmonitor\n</code></pre> <p>This function returns the handle of the monitor that the specified window is in full screen on.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window to query.</li> </ol>  returns  <p><code>\\GLFWmonitor</code> The monitor, or <code>NULL</code> if the window is in windowed mode or an <code>error</code> occurred.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetWindowMonitor.html"},{"title":"glfwGetWindowOpacity","text":"<p>Returns the opacity of the whole window.</p> <pre><code>function glfwGetWindowOpacity(\\GLFWwindow $window) : float\n</code></pre> <p>This function returns the opacity of the window, including any decorations.</p> <p>The opacity (or alpha) value is a positive finite number between zero and one, where zero is fully transparent and one is fully opaque. If the system does not support whole window transparency, this function always returns one.</p> <p>The initial opacity value for newly created windows is one.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window to query.</li> </ol>  returns  <p><code>float</code> The opacity value of the specified window.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetWindowOpacity.html"},{"title":"glfwGetWindowPos","text":"<p>Retrieves the position of the content area of the specified window.</p> <pre><code>function glfwGetWindowPos(\\GLFWwindow $window, int &amp;$xpos, int &amp;$ypos) : void\n</code></pre> <p>This function retrieves the position, in screen coordinates, of the upper-left corner of the content area of the specified window.</p> <p>Any or all of the position arguments may be <code>NULL</code>. If an error occurs, all non-<code>NULL</code> position arguments will be set to zero.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window to query.</li> <li><code>int</code> <code>$xpos</code> Where to store the x-coordinate of the upper-left corner of the content area, or <code>NULL</code>.</li> <li><code>int</code> <code>$ypos</code> Where to store the y-coordinate of the upper-left corner of the content area, or <code>NULL</code>.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetWindowPos.html"},{"title":"glfwGetWindowSize","text":"<p>Retrieves the size of the content area of the specified window.</p> <pre><code>function glfwGetWindowSize(\\GLFWwindow $window, int &amp;$width, int &amp;$height) : void\n</code></pre> <p>This function retrieves the size, in screen coordinates, of the content area of the specified window. If you wish to retrieve the size of the framebuffer of the window in pixels, see <code>glfwGetFramebufferSize</code>.</p> <p>Any or all of the size arguments may be <code>NULL</code>. If an error occurs, all non-<code>NULL</code> size arguments will be set to zero.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose size to retrieve.</li> <li><code>int</code> <code>$width</code> Where to store the width, in screen coordinates, of the content area, or <code>NULL</code>.</li> <li><code>int</code> <code>$height</code> Where to store the height, in screen coordinates, of the content area, or <code>NULL</code>.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwGetWindowSize.html"},{"title":"glfwHideWindow","text":"<p>Hides the specified window.</p> <pre><code>function glfwHideWindow(\\GLFWwindow $window) : void\n</code></pre> <p>This function hides the specified window if it was previously visible. If the window is already hidden or is in full screen mode, this function does nothing.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window to hide.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwHideWindow.html"},{"title":"glfwIconifyWindow","text":"<p>Iconifies the specified window.</p> <pre><code>function glfwIconifyWindow(\\GLFWwindow $window) : void\n</code></pre> <p>This function iconifies (minimizes) the specified window if it was previously restored. If the window is already iconified, this function does nothing.</p> <p>If the specified window is a full screen window, GLFW restores the original video mode of the monitor. The window's desired video mode is set again when the window is restored.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window to iconify.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwIconifyWindow.html"},{"title":"glfwInit","text":"<p>Initializes the GLFW library.</p> <pre><code>function glfwInit() : int\n</code></pre> <p>This function initializes the GLFW library. Before most GLFW functions can be used, GLFW must be initialized, and before an application terminates GLFW should be terminated in order to free any resources allocated during or after initialization.</p> <p>If this function fails, it calls <code>glfwTerminate</code> before returning. If it succeeds, you should call <code>glfwTerminate</code> before the application exits.</p> <p>Additional calls to this function after successful initialization but before termination will return <code>GLFW_TRUE</code> immediately.</p>  returns  <p><code>int</code> <code>GLFW_TRUE</code> if successful, or <code>GLFW_FALSE</code> if an <code>error</code> occurred.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwInit.html"},{"title":"glfwInitHint","text":"<p>Sets the specified init hint to the desired value.</p> <pre><code>function glfwInitHint(int $hint, int $value) : void\n</code></pre> <p>This function sets hints for the next initialization of GLFW.</p> <p>The values you set hints to are never reset by GLFW, but they only take effect during initialization. Once GLFW has been initialized, any values you set will be ignored until the library is terminated and initialized again.</p> <p>Some hints are platform specific. These may be set on any platform but they will only affect their specific platform. Other platforms will ignore them. Setting these hints requires no platform specific headers or functions.</p>  arguments  <ol> <li><code>int</code> <code>$hint</code> The <code>init hint</code> to set.</li> <li><code>int</code> <code>$value</code> The new value of the init hint.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwInitHint.html"},{"title":"glfwJoystickIsGamepad","text":"<p>Returns whether the specified joystick has a gamepad mapping.</p> <pre><code>function glfwJoystickIsGamepad(int $jid) : int\n</code></pre> <p>This function returns whether the specified joystick is both present and has a gamepad mapping.</p> <p>If the specified joystick is present but does not have a gamepad mapping this function will return <code>GLFW_FALSE</code> but will not generate an error. Call <code>glfwJoystickPresent</code> to check if a joystick is present regardless of whether it has a mapping.</p>  arguments  <ol> <li><code>int</code> <code>$jid</code> The <code>joystick</code> to query.</li> </ol>  returns  <p><code>int</code> <code>GLFW_TRUE</code> if a joystick is both present and has a gamepad mapping, or <code>GLFW_FALSE</code> otherwise.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwJoystickIsGamepad.html"},{"title":"glfwJoystickPresent","text":"<p>Returns whether the specified joystick is present.</p> <pre><code>function glfwJoystickPresent(int $jid) : int\n</code></pre> <p>This function returns whether the specified joystick is present.</p> <p>There is no need to call this function before other functions that accept a joystick ID, as they all check for presence before performing any other work.</p>  arguments  <ol> <li><code>int</code> <code>$jid</code> The <code>joystick</code> to query.</li> </ol>  returns  <p><code>int</code> <code>GLFW_TRUE</code> if the joystick is present, or <code>GLFW_FALSE</code> otherwise.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwJoystickPresent.html"},{"title":"glfwMakeContextCurrent","text":"<p>Makes the context of the specified window current for the calling thread.</p> <pre><code>function glfwMakeContextCurrent(\\GLFWwindow $window) : void\n</code></pre> <p>This function makes the OpenGL or OpenGL ES context of the specified window current on the calling thread. A context must only be made current on a single thread at a time and each thread can have only a single current context at a time.</p> <p>When moving a context between threads, you must make it non-current on the old thread before making it current on the new one.</p> <p>By default, making a context non-current implicitly forces a pipeline flush. On machines that support <code>GL_KHR_context_flush_control</code>, you can control whether a context performs this flush by setting the <code>GLFW_CONTEXT_RELEASE_BEHAVIOR</code> hint.</p> <p>The specified window must have an OpenGL or OpenGL ES context. Specifying a window without a context will generate a <code>GLFW_NO_WINDOW_CONTEXT</code> error.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose context to make current, or <code>NULL</code> to detach the current context.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwMakeContextCurrent.html"},{"title":"glfwMaximizeWindow","text":"<p>Maximizes the specified window.</p> <pre><code>function glfwMaximizeWindow(\\GLFWwindow $window) : void\n</code></pre> <p>This function maximizes the specified window if it was previously not maximized. If the window is already maximized, this function does nothing.</p> <p>If the specified window is a full screen window, this function does nothing.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window to maximize.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwMaximizeWindow.html"},{"title":"glfwPollEvents","text":"<p>Processes all pending events.</p> <pre><code>function glfwPollEvents() : void\n</code></pre> <p>This function processes only those events that are already in the event queue and then returns immediately. Processing events will cause the window and input callbacks associated with those events to be called.</p> <p>On some platforms, a window move, resize or menu operation will cause event processing to block. This is due to how event processing is designed on those platforms. You can use the <code>window refresh callback</code> to redraw the contents of your window when necessary during such operations.</p> <p>Do not assume that callbacks you set will only be called in response to event processing functions like this one. While it is necessary to poll for events, window systems that require GLFW to register callbacks of its own can pass events to GLFW in response to many window system function calls. GLFW will pass those events on to the application callbacks before returning.</p> <p>Event processing is not required for joystick input to work.</p>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwPollEvents.html"},{"title":"glfwPostEmptyEvent","text":"<p>Posts an empty event to the event queue.</p> <pre><code>function glfwPostEmptyEvent() : void\n</code></pre> <p>This function posts an empty event from the current thread to the event queue, causing <code>glfwWaitEvents</code> or <code>glfwWaitEventsTimeout</code> to return.</p>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwPostEmptyEvent.html"},{"title":"glfwRawMouseMotionSupported","text":"<p>Returns whether raw mouse motion is supported.</p> <pre><code>function glfwRawMouseMotionSupported() : int\n</code></pre> <p>This function returns whether raw mouse motion is supported on the current system. This status does not change after GLFW has been initialized so you only need to check this once. If you attempt to enable raw motion on a system that does not support it, <code>GLFW_PLATFORM_ERROR</code> will be emitted.</p> <p>Raw mouse motion is closer to the actual motion of the mouse across a surface. It is not affected by the scaling and acceleration applied to the motion of the desktop cursor. That processing is suitable for a cursor while raw motion is better for controlling for example a 3D camera. Because of this, raw mouse motion is only provided when the cursor is disabled.</p>  returns  <p><code>int</code> <code>GLFW_TRUE</code> if raw mouse motion is supported on the current machine, or <code>GLFW_FALSE</code> otherwise.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwRawMouseMotionSupported.html"},{"title":"glfwRequestWindowAttention","text":"<p>Requests user attention to the specified window.</p> <pre><code>function glfwRequestWindowAttention(\\GLFWwindow $window) : void\n</code></pre> <p>This function requests user attention to the specified window. On platforms where this is not supported, attention is requested to the application as a whole.</p> <p>Once the user has given attention, usually by focusing the window or application, the system will end the request automatically.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window to request attention to.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwRequestWindowAttention.html"},{"title":"glfwRestoreWindow","text":"<p>Restores the specified window.</p> <pre><code>function glfwRestoreWindow(\\GLFWwindow $window) : void\n</code></pre> <p>This function restores the specified window if it was previously iconified (minimized) or maximized. If the window is already restored, this function does nothing.</p> <p>If the specified window is an iconified full screen window, its desired video mode is set again for its monitor when the window is restored.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window to restore.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwRestoreWindow.html"},{"title":"glfwSetCharCallback","text":"<p>This function sets the character callback of the specified window, which is called when a Unicode character is input.</p> <pre><code>function glfwSetCharCallback(\\GLFWwindow $window, callable $callback) : void\n</code></pre> <p>Example: <pre><code>glfwSetCharCallback($window, function($codepoint) {\n    echo \"Character: \" . mb_chr($codepoint) . PHP_EOL;\n});\n</code></pre></p> <p>The character callback is intended for Unicode text input. As it deals with characters, it is keyboard layout dependent, whereas the key callback is not. Characters do not map 1:1 to physical keys, as a key may produce zero, one or more characters. If you want to know whether a specific physical key was pressed or released, see the key callback instead.</p> <p>The character callback behaves as system text input normally does and will not be called if modifier keys are held down that would prevent normal text input on that platform, for example a Super (Command) key on macOS or Alt key on Windows.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose callback to set.</li> <li><code>callable</code> <code>$callback</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetCharCallback.html"},{"title":"glfwSetCharModsCallback","text":"<p>This function sets the character with modifiers callback of the specified window, which is called when a Unicode character is input regardless of what modifier keys are used.</p> <pre><code>function glfwSetCharModsCallback(\\GLFWwindow $window, callable $callback) : void\n</code></pre> <p>The character with modifiers callback is intended for implementing custom Unicode character input. For regular Unicode text input, see the character callback.</p> <p>Example: <pre><code>glfwSetCharModsCallback($window, function($codepoint, $mods) {\n    echo \"Character: \" . mb_chr($codepoint) . ' with mods: ' . $mods .\nPHP_EOL;\n});\n</code></pre></p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose callback to set.</li> <li><code>callable</code> <code>$callback</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetCharModsCallback.html"},{"title":"glfwSetClipboardString","text":"<p>Sets the clipboard to the specified string.</p> <pre><code>function glfwSetClipboardString(\\GLFWwindow $window, string $string) : void\n</code></pre> <p>This function sets the system clipboard to the specified, UTF-8 encoded string.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> Deprecated. Any valid window or <code>NULL</code>.</li> <li><code>string</code> <code>$string</code> A UTF-8 encoded string.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetClipboardString.html"},{"title":"glfwSetCursor","text":"<p>Sets the cursor for the window.</p> <pre><code>function glfwSetCursor(\\GLFWwindow $window, \\GLFWcursor $cursor) : void\n</code></pre> <p>This function sets the cursor image to be used when the cursor is over the content area of the specified window. The set cursor will only be visible when the <code>cursor mode</code> of the window is <code>GLFW_CURSOR_NORMAL</code>.</p> <p>On some platforms, the set cursor may not be visible unless the window also has input focus.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window to set the cursor for.</li> <li><code>\\GLFWcursor</code> <code>$cursor</code> The cursor to set, or <code>NULL</code> to switch back to the default arrow cursor.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetCursor.html"},{"title":"glfwSetCursorEnterCallback","text":"<p>This function sets the cursor boundary crossing callback of the specified window, which is called when the cursor enters or leaves the client area of the window.</p> <pre><code>function glfwSetCursorEnterCallback(\\GLFWwindow $window, callable $callback) : void\n</code></pre> <p>Example: <pre><code>glfwSetCursorEnterCallback($window, function($entered) {\n    if ($entered) {\n        echo \"Cursor entered window\" . PHP_EOL;\n    } else {\n        echo \"Cursor left window\" . PHP_EOL;\n    }\n});\n</code></pre></p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose callback to set.</li> <li><code>callable</code> <code>$callback</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetCursorEnterCallback.html"},{"title":"glfwSetCursorPos","text":"<p>Sets the position of the cursor, relative to the content area of the window.</p> <pre><code>function glfwSetCursorPos(\\GLFWwindow $window, float $xpos, float $ypos) : void\n</code></pre> <p>This function sets the position, in screen coordinates, of the cursor relative to the upper-left corner of the content area of the specified window. The window must have input focus. If the window does not have input focus when this function is called, it fails silently.</p> <p>Do not use this function to implement things like camera controls. GLFW already provides the <code>GLFW_CURSOR_DISABLED</code> cursor mode that hides the cursor, transparently re-centers it and provides unconstrained cursor motion. See <code>glfwSetInputMode</code> for more information.</p> <p>If the cursor mode is <code>GLFW_CURSOR_DISABLED</code> then the cursor position is unconstrained and limited only by the minimum and maximum values of a <code>double</code>.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The desired window.</li> <li><code>float</code> <code>$xpos</code> The desired x-coordinate, relative to the left edge of the content area.</li> <li><code>float</code> <code>$ypos</code> The desired y-coordinate, relative to the top edge of the content area.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetCursorPos.html"},{"title":"glfwSetCursorPosCallback","text":"<p>This function sets the cursor position callback of the specified window, which is called when the cursor is moved.</p> <pre><code>function glfwSetCursorPosCallback(\\GLFWwindow $window, callable $callback) : void\n</code></pre> <p>The callback is provided with the position, in screen coordinates, relative to the upper-left corner of the client area of the window.</p> <p>Example: <pre><code>glfwSetCursorPosCallback($window, function($xpos, $ypos) {\n    echo \"Cursor position: \" . $xpos . \", \" . $ypos . PHP_EOL;\n});\n</code></pre></p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose callback to set.</li> <li><code>callable</code> <code>$callback</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetCursorPosCallback.html"},{"title":"glfwSetDropCallback","text":"<p>This function sets the file drop callback of the specified window, which is called when one or more dragged files are dropped on the window.</p> <pre><code>function glfwSetDropCallback(\\GLFWwindow $window, callable $callback) : void\n</code></pre> <p>Example: <pre><code>glfwSetDropCallback($window, function($paths) {\n    echo \"Dropped files:\" . PHP_EOL;\n    foreach ($paths as $path) {\n        echo \"  \" . $path . PHP_EOL;\n    }\n});\n</code></pre></p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose callback to set.</li> <li><code>callable</code> <code>$callback</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetDropCallback.html"},{"title":"glfwSetFramebufferSizeCallback","text":"<p>This function sets the framebuffer resize callback of the specified window, which is called when the framebuffer of the specified window is resized.</p> <pre><code>function glfwSetFramebufferSizeCallback(\\GLFWwindow $window, callable $callback) : void\n</code></pre> <p>This callback is provided for convenience.  The equivalent functionality can be achieved by registering a window size callback and querying the framebuffer size within that callback.</p> <p>Example: <pre><code>glfwSetFramebufferSizeCallback($window, function($width, $height) {\n    echo \"Framebuffer size changed to: \" . $width . \"x\" . $height . PHP_EOL;\n});\n</code></pre></p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose callback to set.</li> <li><code>callable</code> <code>$callback</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetFramebufferSizeCallback.html"},{"title":"glfwSetGamma","text":"<p>Generates a gamma ramp and sets it for the specified monitor.</p> <pre><code>function glfwSetGamma(\\GLFWmonitor $monitor, float $gamma) : void\n</code></pre> <p>This function generates an appropriately sized gamma ramp from the specified exponent and then calls <code>glfwSetGammaRamp</code> with it. The value must be a finite number greater than zero.</p> <p>The software controlled gamma ramp is applied in addition to the hardware gamma correction, which today is usually an approximation of sRGB gamma. This means that setting a perfectly linear ramp, or gamma 1.0, will produce the default (usually sRGB-like) behavior.</p> <p>For gamma correct rendering with OpenGL or OpenGL ES, see the @ref GLFW_SRGB_CAPABLE hint.</p>  arguments  <ol> <li><code>\\GLFWmonitor</code> <code>$monitor</code> The monitor whose gamma ramp to set.</li> <li><code>float</code> <code>$gamma</code> The desired exponent.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetGamma.html"},{"title":"glfwSetInputMode","text":"<p>Sets an input option for the specified window.</p> <pre><code>function glfwSetInputMode(\\GLFWwindow $window, int $mode, int $value) : void\n</code></pre> <p>This function sets an input mode option for the specified window. The mode must be one of <code>GLFW_CURSOR</code>, <code>GLFW_STICKY_KEYS</code>, <code>GLFW_STICKY_MOUSE_BUTTONS</code>, <code>GLFW_LOCK_KEY_MODS</code> or <code>GLFW_RAW_MOUSE_MOTION</code>.</p> <p>If the mode is <code>GLFW_CURSOR</code>, the value must be one of the following cursor modes: - <code>GLFW_CURSOR_NORMAL</code> makes the cursor visible and behaving normally. - <code>GLFW_CURSOR_HIDDEN</code> makes the cursor invisible when it is over the  content area of the window but does not restrict the cursor from leaving. - <code>GLFW_CURSOR_DISABLED</code> hides and grabs the cursor, providing virtual  and unlimited cursor movement. This is useful for implementing for  example 3D camera controls.</p> <p>If the mode is <code>GLFW_STICKY_KEYS</code>, the value must be either <code>GLFW_TRUE</code> to enable sticky keys, or <code>GLFW_FALSE</code> to disable it. If sticky keys are enabled, a key press will ensure that <code>glfwGetKey</code> returns <code>GLFW_PRESS</code> the next time it is called even if the key had been released before the call. This is useful when you are only interested in whether keys have been pressed but not when or in which order.</p> <p>If the mode is <code>GLFW_STICKY_MOUSE_BUTTONS</code>, the value must be either <code>GLFW_TRUE</code> to enable sticky mouse buttons, or <code>GLFW_FALSE</code> to disable it. If sticky mouse buttons are enabled, a mouse button press will ensure that <code>glfwGetMouseButton</code> returns <code>GLFW_PRESS</code> the next time it is called even if the mouse button had been released before the call. This is useful when you are only interested in whether mouse buttons have been pressed but not when or in which order.</p> <p>If the mode is <code>GLFW_LOCK_KEY_MODS</code>, the value must be either <code>GLFW_TRUE</code> to enable lock key modifier bits, or <code>GLFW_FALSE</code> to disable them. If enabled, callbacks that receive modifier bits will also have the @ref GLFW_MOD_CAPS_LOCK bit set when the event was generated with Caps Lock on, and the <code>GLFW_MOD_NUM_LOCK</code> bit when Num Lock was on.</p> <p>If the mode is <code>GLFW_RAW_MOUSE_MOTION</code>, the value must be either <code>GLFW_TRUE</code> to enable raw (unscaled and unaccelerated) mouse motion when the cursor is disabled, or <code>GLFW_FALSE</code> to disable it. If raw motion is not supported, attempting to set this will emit <code>GLFW_PLATFORM_ERROR</code>. Call @ref glfwRawMouseMotionSupported to check for support.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose input mode to set.</li> <li><code>int</code> <code>$mode</code> One of <code>GLFW_CURSOR</code>, <code>GLFW_STICKY_KEYS</code>, <code>GLFW_STICKY_MOUSE_BUTTONS</code>, <code>GLFW_LOCK_KEY_MODS</code> or <code>GLFW_RAW_MOUSE_MOTION</code>.</li> <li><code>int</code> <code>$value</code> The new value of the specified input mode.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetInputMode.html"},{"title":"glfwSetKeyCallback","text":"<p>This function sets the key callback of the specified window, which is called when a key is pressed, repeated or released.</p> <pre><code>function glfwSetKeyCallback(\\GLFWwindow $window, callable $callback) : void\n</code></pre> <p>Example: <pre><code>glfwSetKeyCallback($window, function($key, $scancode, $action, $mods)\nuse($window) {\n    if ($key == GLFW_KEY_ESCAPE &amp;&amp; $action == GLFW_PRESS) {\n        glfwSetWindowShouldClose($window, GL_TRUE);\n    }\n});\n</code></pre></p> <p>The key functions deal with physical keys, with layout independent key tokens named after their values in the standard US keyboard layout. If you want to input text, use the character callback instead.</p> <p>When a window loses input focus, it will generate synthetic key release events for all pressed keys. You can tell these events from user-generated events by the fact that the synthetic ones are generated after the focus loss event has been processed, i.e. after the window focus callback has been called.</p> <p>The scancode of a key is specific to that platform or sometimes even to that machine. Scancodes are intended to allow users to bind keys that don't have a GLFW key token. Such keys have key set to GLFW_KEY_UNKNOWN, their state is not saved and so it cannot be queried with glfwGetKey.</p> <p>Sometimes GLFW needs to generate synthetic key events, in which case the scancode may be zero.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose callback to set.</li> <li><code>callable</code> <code>$callback</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetKeyCallback.html"},{"title":"glfwSetMouseButtonCallback","text":"<p>This function sets the mouse button callback of the specified window, which is called when a mouse button is pressed or released.</p> <pre><code>function glfwSetMouseButtonCallback(\\GLFWwindow $window, callable $callback) : void\n</code></pre> <p>Example: <pre><code>glfwSetMouseButtonCallback($window, function($button, $action, $mods) {\n    if ($button == GLFW_MOUSE_BUTTON_LEFT &amp;&amp; $action == GLFW_PRESS) {\n        echo \"Left mouse button pressed\" . PHP_EOL;\n    }\n});\n</code></pre></p> <p>When a window loses input focus, it will generate synthetic mouse button release events for all pressed mouse buttons. You can tell these events from user-generated events by the fact that the synthetic ones are generated after the focus loss event has been processed, i.e. after the window focus callback has been called.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose callback to set.</li> <li><code>callable</code> <code>$callback</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetMouseButtonCallback.html"},{"title":"glfwSetScrollCallback","text":"<p>This function sets the scroll callback of the specified window, which is called when a scrolling device is used, such as a mouse wheel or scrolling area of a touchpad.</p> <pre><code>function glfwSetScrollCallback(\\GLFWwindow $window, callable $callback) : void\n</code></pre> <p>Example: <pre><code>glfwSetScrollCallback($window, function($xoffset, $yoffset) {\n    echo \"Scroll offset: \" . $xoffset . \", \" . $yoffset . PHP_EOL;\n});\n</code></pre></p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose callback to set.</li> <li><code>callable</code> <code>$callback</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetScrollCallback.html"},{"title":"glfwSetTime","text":"<p>Sets the GLFW time.</p> <pre><code>function glfwSetTime(float $time) : void\n</code></pre> <p>This function sets the current GLFW time, in seconds. The value must be a positive finite number less than or equal to 18446744073.0, which is approximately 584.5 years.</p> <p>This function and <code>glfwGetTime</code> are helper functions on top of @ref glfwGetTimerFrequency and <code>glfwGetTimerValue</code>.</p>  arguments  <ol> <li><code>float</code> <code>$time</code> The new value, in seconds.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetTime.html"},{"title":"glfwSetWindowAspectRatio","text":"<p>Sets the aspect ratio of the specified window.</p> <pre><code>function glfwSetWindowAspectRatio(\\GLFWwindow $window, int $numer, int $denom) : void\n</code></pre> <p>This function sets the required aspect ratio of the content area of the specified window. If the window is full screen, the aspect ratio only takes effect once it is made windowed. If the window is not resizable, this function does nothing.</p> <p>The aspect ratio is specified as a numerator and a denominator and both values must be greater than zero. For example, the common 16:9 aspect ratio is specified as 16 and 9, respectively.</p> <p>If the numerator and denominator is set to <code>GLFW_DONT_CARE</code> then the aspect ratio limit is disabled.</p> <p>The aspect ratio is applied immediately to a windowed mode window and may cause it to be resized.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window to set limits for.</li> <li><code>int</code> <code>$numer</code> The numerator of the desired aspect ratio, or <code>GLFW_DONT_CARE</code>.</li> <li><code>int</code> <code>$denom</code> The denominator of the desired aspect ratio, or <code>GLFW_DONT_CARE</code>.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetWindowAspectRatio.html"},{"title":"glfwSetWindowAttrib","text":"<p>Sets an attribute of the specified window.</p> <pre><code>function glfwSetWindowAttrib(\\GLFWwindow $window, int $attrib, int $value) : void\n</code></pre> <p>This function sets the value of an attribute of the specified window.</p> <p>The supported attributes are <code>GLFW_DECORATED</code>, <code>GLFW_RESIZABLE</code>, <code>GLFW_FLOATING</code>, <code>GLFW_AUTO_ICONIFY</code> and <code>GLFW_FOCUS_ON_SHOW</code>.</p> <p>Some of these attributes are ignored for full screen windows. The new value will take effect if the window is later made windowed.</p> <p>Some of these attributes are ignored for windowed mode windows. The new value will take effect if the window is later made full screen.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window to set the attribute for.</li> <li><code>int</code> <code>$attrib</code> A supported window attribute.</li> <li><code>int</code> <code>$value</code> <code>GLFW_TRUE</code> or <code>GLFW_FALSE</code>.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetWindowAttrib.html"},{"title":"glfwSetWindowCloseCallback","text":"<p>This function sets the close callback of the specified window, which is called when the user attempts to close the window, for example by clicking the close widget in the title bar.</p> <pre><code>function glfwSetWindowCloseCallback(\\GLFWwindow $window, callable $callback) : void\n</code></pre> <p>The close flag is set before this callback is called, but you can modify it at any time with glfwSetWindowShouldClose.</p> <p>The close callback is not triggered by glfwDestroyWindow.</p> <p>Example: <pre><code>glfwSetWindowCloseCallback($window, function() {\n    echo \"Window close requested\" . PHP_EOL;\n});\n</code></pre></p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose callback to set.</li> <li><code>callable</code> <code>$callback</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetWindowCloseCallback.html"},{"title":"glfwSetWindowContentScaleCallback","text":"<p>This function sets the window content scale callback of the specified window, which is called when the content scale of the specified window changes.</p> <pre><code>function glfwSetWindowContentScaleCallback(\\GLFWwindow $window, callable $callback) : void\n</code></pre> <p>This callback is provided for convenience.  The equivalent functionality can be achieved by registering a window size callback and querying the content scale within that callback.</p> <p>Example: <pre><code>glfwSetWindowContentScaleCallback($window, function($xscale, $yscale) {\n    echo \"Window content scale changed to: \" . $xscale . \"x\" . $yscale .\nPHP_EOL;\n});\n</code></pre></p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose callback to set.</li> <li><code>callable</code> <code>$callback</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetWindowContentScaleCallback.html"},{"title":"glfwSetWindowFocusCallback","text":"<p>This function sets the focus callback of the specified window, which is called when the window gains or loses input focus.</p> <pre><code>function glfwSetWindowFocusCallback(\\GLFWwindow $window, callable $callback) : void\n</code></pre> <p>After the focus callback is called for a window that lost input focus, synthetic key and mouse button release events will be generated for all such that had been pressed.  For more information, see glfwSetKeyCallback and glfwSetMouseButtonCallback.</p> <p>Example: <pre><code>glfwSetWindowFocusCallback($window, function($focused) {\n    echo \"Window focus changed to: \" . $focused . PHP_EOL;\n});\n</code></pre></p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose callback to set.</li> <li><code>callable</code> <code>$callback</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetWindowFocusCallback.html"},{"title":"glfwSetWindowIconifyCallback","text":"<p>This function sets the iconification callback of the specified window, which is called when the window is iconified or restored.</p> <pre><code>function glfwSetWindowIconifyCallback(\\GLFWwindow $window, callable $callback) : void\n</code></pre> <p>Example: <pre><code>glfwSetWindowIconifyCallback($window, function($iconified) {\n    echo \"Window iconified changed to: \" . $iconified . PHP_EOL;\n});\n</code></pre></p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose callback to set.</li> <li><code>callable</code> <code>$callback</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetWindowIconifyCallback.html"},{"title":"glfwSetWindowMaximizeCallback","text":"<p>This function sets the maximize callback of the specified window, which is called when the window is maximized or restored.</p> <pre><code>function glfwSetWindowMaximizeCallback(\\GLFWwindow $window, callable $callback) : void\n</code></pre> <p>Example: <pre><code>glfwSetWindowMaximizeCallback($window, function($maximized) {\n    echo \"Window maximized changed to: \" . $maximized . PHP_EOL;\n});\n</code></pre></p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose callback to set.</li> <li><code>callable</code> <code>$callback</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetWindowMaximizeCallback.html"},{"title":"glfwSetWindowMonitor","text":"<p>Sets the mode, monitor, video mode and placement of a window.</p> <pre><code>function glfwSetWindowMonitor(\\GLFWwindow $window, ?\\GLFWmonitor $monitor, int $xpos, int $ypos, int $width, int $height, int $refreshRate) : void\n</code></pre> <p>This function sets the monitor that the window uses for full screen mode or, if the monitor is <code>NULL</code>, makes it windowed mode.</p> <p>When setting a monitor, this function updates the width, height and refresh rate of the desired video mode and switches to the video mode closest to it. The window position is ignored when setting a monitor.</p> <p>When the monitor is <code>NULL</code>, the position, width and height are used to place the window content area. The refresh rate is ignored when no monitor is specified.</p> <p>If you only wish to update the resolution of a full screen window or the size of a windowed mode window, see <code>glfwSetWindowSize</code>.</p> <p>When a window transitions from full screen to windowed mode, this function restores any previous window settings such as whether it is decorated, floating, resizable, has size or aspect ratio limits, etc.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose monitor, size or video mode to set.</li> <li><code>?\\GLFWmonitor</code> <code>$monitor</code> The desired monitor, or <code>NULL</code> to set windowed mode.</li> <li><code>int</code> <code>$xpos</code> The desired x-coordinate of the upper-left corner of the content area.</li> <li><code>int</code> <code>$ypos</code> The desired y-coordinate of the upper-left corner of the content area.</li> <li><code>int</code> <code>$width</code> The desired with, in screen coordinates, of the content area or video mode.</li> <li><code>int</code> <code>$height</code> The desired height, in screen coordinates, of the content area or video mode.</li> <li><code>int</code> <code>$refreshRate</code> The desired refresh rate, in Hz, of the video mode, or <code>GLFW_DONT_CARE</code>.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetWindowMonitor.html"},{"title":"glfwSetWindowOpacity","text":"<p>Sets the opacity of the whole window.</p> <pre><code>function glfwSetWindowOpacity(\\GLFWwindow $window, float $opacity) : void\n</code></pre> <p>This function sets the opacity of the window, including any decorations.</p> <p>The opacity (or alpha) value is a positive finite number between zero and one, where zero is fully transparent and one is fully opaque.</p> <p>The initial opacity value for newly created windows is one.</p> <p>A window created with framebuffer transparency may not use whole window transparency. The results of doing this are undefined.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window to set the opacity for.</li> <li><code>float</code> <code>$opacity</code> The desired opacity of the specified window.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetWindowOpacity.html"},{"title":"glfwSetWindowPos","text":"<p>Sets the position of the content area of the specified window.</p> <pre><code>function glfwSetWindowPos(\\GLFWwindow $window, int $xpos, int $ypos) : void\n</code></pre> <p>This function sets the position, in screen coordinates, of the upper-left corner of the content area of the specified windowed mode window. If the window is a full screen window, this function does nothing.</p> <p>Do not use this function to move an already visible window unless you have very good reasons for doing so, as it will confuse and annoy the user.</p> <p>The window manager may put limits on what positions are allowed. GLFW cannot and should not override these limits.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window to query.</li> <li><code>int</code> <code>$xpos</code> The x-coordinate of the upper-left corner of the content area.</li> <li><code>int</code> <code>$ypos</code> The y-coordinate of the upper-left corner of the content area.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetWindowPos.html"},{"title":"glfwSetWindowPosCallback","text":"<p>This function sets the position callback of the specified window, which is called when the window is moved.</p> <pre><code>function glfwSetWindowPosCallback(\\GLFWwindow $window, callable $callback) : void\n</code></pre> <p>The callback is provided with the screen position of the upper-left corner of the client area of the window.</p> <p>Example: <pre><code>glfwSetWindowPosCallback($window, function($x, $y) {\n    echo \"Window moved to: \" . $x . \", \" . $y . PHP_EOL;\n});\n</code></pre></p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose callback to set.</li> <li><code>callable</code> <code>$callback</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetWindowPosCallback.html"},{"title":"glfwSetWindowRefreshCallback","text":"<p>This function sets the refresh callback of the specified window, which is called when the client area of the window needs to be redrawn, for example if the window has been exposed after having been covered by another window.</p> <pre><code>function glfwSetWindowRefreshCallback(\\GLFWwindow $window, callable $callback) : void\n</code></pre> <p>On compositing window systems such as Aero, Compiz, Aqua or Wayland, where the window contents are saved off-screen, this callback may be called only very infrequently or never at all.</p> <p>Example: <pre><code>glfwSetWindowRefreshCallback($window, function() {\n    echo \"Window needs to be redrawn\" . PHP_EOL;\n});\n</code></pre></p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose callback to set.</li> <li><code>callable</code> <code>$callback</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetWindowRefreshCallback.html"},{"title":"glfwSetWindowShouldClose","text":"<p>Sets the close flag of the specified window.</p> <pre><code>function glfwSetWindowShouldClose(\\GLFWwindow $window, int $value) : void\n</code></pre> <p>This function sets the value of the close flag of the specified window. This can be used to override the user's attempt to close the window, or to signal that it should be closed.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose flag to change.</li> <li><code>int</code> <code>$value</code> The new value.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetWindowShouldClose.html"},{"title":"glfwSetWindowSize","text":"<p>Sets the size of the content area of the specified window.</p> <pre><code>function glfwSetWindowSize(\\GLFWwindow $window, int $width, int $height) : void\n</code></pre> <p>This function sets the size, in screen coordinates, of the content area of the specified window.</p> <p>For full screen windows, this function updates the resolution of its desired video mode and switches to the video mode closest to it, without affecting the window's context. As the context is unaffected, the bit depths of the framebuffer remain unchanged.</p> <p>If you wish to update the refresh rate of the desired video mode in addition to its resolution, see <code>glfwSetWindowMonitor</code>.</p> <p>The window manager may put limits on what sizes are allowed. GLFW cannot and should not override these limits.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window to resize.</li> <li><code>int</code> <code>$width</code> The desired width, in screen coordinates, of the window content area.</li> <li><code>int</code> <code>$height</code> The desired height, in screen coordinates, of the window content area.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetWindowSize.html"},{"title":"glfwSetWindowSizeCallback","text":"<p>This function sets the size callback of the specified window, which is called when the window is resized.</p> <pre><code>function glfwSetWindowSizeCallback(\\GLFWwindow $window, callable $callback) : void\n</code></pre> <p>The callback is provided with the size, in screen coordinates, of the client area of the window.</p> <p>Example: <pre><code>glfwSetWindowSizeCallback($window, function($width, $height) {\n    echo \"Window resized to: \" . $width . \"x\" . $height . PHP_EOL;\n});\n</code></pre></p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose callback to set.</li> <li><code>callable</code> <code>$callback</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetWindowSizeCallback.html"},{"title":"glfwSetWindowSizeLimits","text":"<p>Sets the size limits of the specified window.</p> <pre><code>function glfwSetWindowSizeLimits(\\GLFWwindow $window, int $minwidth, int $minheight, int $maxwidth, int $maxheight) : void\n</code></pre> <p>This function sets the size limits of the content area of the specified window. If the window is full screen, the size limits only take effect once it is made windowed. If the window is not resizable, this function does nothing.</p> <p>The size limits are applied immediately to a windowed mode window and may cause it to be resized.</p> <p>The maximum dimensions must be greater than or equal to the minimum dimensions and all must be greater than or equal to zero.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window to set limits for.</li> <li><code>int</code> <code>$minwidth</code> The minimum width, in screen coordinates, of the content area, or <code>GLFW_DONT_CARE</code>.</li> <li><code>int</code> <code>$minheight</code> The minimum height, in screen coordinates, of the content area, or <code>GLFW_DONT_CARE</code>.</li> <li><code>int</code> <code>$maxwidth</code> The maximum width, in screen coordinates, of the content area, or <code>GLFW_DONT_CARE</code>.</li> <li><code>int</code> <code>$maxheight</code> The maximum height, in screen coordinates, of the content area, or <code>GLFW_DONT_CARE</code>.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetWindowSizeLimits.html"},{"title":"glfwSetWindowTitle","text":"<p>Sets the title of the specified window.</p> <pre><code>function glfwSetWindowTitle(\\GLFWwindow $window, string $title) : void\n</code></pre> <p>This function sets the window title, encoded as UTF-8, of the specified window.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose title to change.</li> <li><code>string</code> <code>$title</code> The UTF-8 encoded window title.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSetWindowTitle.html"},{"title":"glfwShowWindow","text":"<p>Makes the specified window visible.</p> <pre><code>function glfwShowWindow(\\GLFWwindow $window) : void\n</code></pre> <p>This function makes the specified window visible if it was previously hidden. If the window is already visible or is in full screen mode, this function does nothing.</p> <p>By default, windowed mode windows are focused when shown Set the <code>GLFW_FOCUS_ON_SHOW</code> window hint to change this behavior for all newly created windows, or change the behavior for an existing window with <code>glfwSetWindowAttrib</code>.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window to make visible.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwShowWindow.html"},{"title":"glfwSwapBuffers","text":"<p>Swaps the front and back buffers of the specified window.</p> <pre><code>function glfwSwapBuffers(\\GLFWwindow $window) : void\n</code></pre> <p>This function swaps the front and back buffers of the specified window when rendering with OpenGL or OpenGL ES. If the swap interval is greater than zero, the GPU driver waits the specified number of screen updates before swapping the buffers.</p> <p>The specified window must have an OpenGL or OpenGL ES context. Specifying a window without a context will generate a <code>GLFW_NO_WINDOW_CONTEXT</code> error.</p> <p>This function does not apply to Vulkan. If you are rendering with Vulkan, see <code>vkQueuePresentKHR</code> instead.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window whose buffers to swap.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSwapBuffers.html"},{"title":"glfwSwapInterval","text":"<p>Sets the swap interval for the current context.</p> <pre><code>function glfwSwapInterval(int $interval) : void\n</code></pre> <p>This function sets the swap interval for the current OpenGL or OpenGL ES context, i.e. the number of screen updates to wait from the time @ref glfwSwapBuffers was called before swapping the buffers and returning. This is sometimes called vertical synchronization, vertical retrace synchronization or just vsync.</p> <p>A context that supports either of the <code>WGL_EXT_swap_control_tear</code> and <code>GLX_EXT_swap_control_tear</code> extensions also accepts negative swap intervals, which allows the driver to swap immediately even if a frame arrives a little bit late. You can check for these extensions with @ref glfwExtensionSupported.</p> <p>A context must be current on the calling thread. Calling this function without a current context will cause a <code>GLFW_NO_CURRENT_CONTEXT</code> error.</p> <p>This function does not apply to Vulkan. If you are rendering with Vulkan, see the present mode of your swapchain instead.</p>  arguments  <ol> <li><code>int</code> <code>$interval</code> The minimum number of screen updates to wait for until the buffers are swapped by <code>glfwSwapBuffers</code>.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwSwapInterval.html"},{"title":"glfwTerminate","text":"<p>Terminates the GLFW library.</p> <pre><code>function glfwTerminate() : void\n</code></pre> <p>This function destroys all remaining windows and cursors, restores any modified gamma ramps and frees any other allocated resources. Once this function is called, you must again call <code>glfwInit</code> successfully before you will be able to use most GLFW functions.</p> <p>If GLFW has been successfully initialized, this function should be called before the application exits. If initialization fails, there is no need to call this function, as it is called by <code>glfwInit</code> before it returns failure.</p> <p>This function has no effect if GLFW is not initialized.</p>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwTerminate.html"},{"title":"glfwUpdateGamepadMappings","text":"<p>Adds the specified SDL_GameControllerDB gamepad mappings.</p> <pre><code>function glfwUpdateGamepadMappings(string $string) : int\n</code></pre> <p>This function parses the specified ASCII encoded string and updates the internal list with any gamepad mappings it finds. This string may contain either a single gamepad mapping or many mappings separated by newlines. The parser supports the full format of the <code>gamecontrollerdb.txt</code> source file including empty lines and comments.</p> <p>See <code>gamepad_mapping</code> for a description of the format.</p> <p>If there is already a gamepad mapping for a given GUID in the internal list, it will be replaced by the one passed to this function. If the library is terminated and re-initialized the internal list will revert to the built-in default.</p>  arguments  <ol> <li><code>string</code> <code>$string</code> The string containing the gamepad mappings.</li> </ol>  returns  <p><code>int</code> <code>GLFW_TRUE</code> if successful, or <code>GLFW_FALSE</code> if an <code>error</code> occurred.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwUpdateGamepadMappings.html"},{"title":"glfwVulkanSupported","text":"<p>Returns whether the Vulkan loader and an ICD have been found.</p> <pre><code>function glfwVulkanSupported() : int\n</code></pre> <p>This function returns whether the Vulkan loader and any minimally functional ICD have been found.</p> <p>The availability of a Vulkan loader and even an ICD does not by itself guarantee that surface creation or even instance creation is possible. Call @ref glfwGetRequiredInstanceExtensions to check whether the extensions necessary for Vulkan surface creation are available and <code>glfwGetPhysicalDevicePresentationSupport</code> to check whether a queue family of a physical device supports image presentation.</p>  returns  <p><code>int</code> <code>GLFW_TRUE</code> if Vulkan is minimally available, or <code>GLFW_FALSE</code> otherwise.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwVulkanSupported.html"},{"title":"glfwWaitEvents","text":"<p>Waits until events are queued and processes them.</p> <pre><code>function glfwWaitEvents() : void\n</code></pre> <p>This function puts the calling thread to sleep until at least one event is available in the event queue. Once one or more events are available, it behaves exactly like <code>glfwPollEvents</code>, i.e. the events in the queue are processed and the function then returns immediately. Processing events will cause the window and input callbacks associated with those events to be called.</p> <p>Since not all events are associated with callbacks, this function may return without a callback having been called even if you are monitoring all callbacks.</p> <p>On some platforms, a window move, resize or menu operation will cause event processing to block. This is due to how event processing is designed on those platforms. You can use the <code>window refresh callback</code> to redraw the contents of your window when necessary during such operations.</p> <p>Do not assume that callbacks you set will only be called in response to event processing functions like this one. While it is necessary to poll for events, window systems that require GLFW to register callbacks of its own can pass events to GLFW in response to many window system function calls. GLFW will pass those events on to the application callbacks before returning.</p> <p>Event processing is not required for joystick input to work.</p>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwWaitEvents.html"},{"title":"glfwWaitEventsTimeout","text":"<p>Waits with timeout until events are queued and processes them.</p> <pre><code>function glfwWaitEventsTimeout(float $timeout) : void\n</code></pre> <p>This function puts the calling thread to sleep until at least one event is available in the event queue, or until the specified timeout is reached. If one or more events are available, it behaves exactly like @ref glfwPollEvents, i.e. the events in the queue are processed and the function then returns immediately. Processing events will cause the window and input callbacks associated with those events to be called.</p> <p>The timeout value must be a positive finite number.</p> <p>Since not all events are associated with callbacks, this function may return without a callback having been called even if you are monitoring all callbacks.</p> <p>On some platforms, a window move, resize or menu operation will cause event processing to block. This is due to how event processing is designed on those platforms. You can use the <code>window refresh callback</code> to redraw the contents of your window when necessary during such operations.</p> <p>Do not assume that callbacks you set will only be called in response to event processing functions like this one. While it is necessary to poll for events, window systems that require GLFW to register callbacks of its own can pass events to GLFW in response to many window system function calls. GLFW will pass those events on to the application callbacks before returning.</p> <p>Event processing is not required for joystick input to work.</p>  arguments  <ol> <li><code>float</code> <code>$timeout</code> The maximum amount of time, in seconds, to wait.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwWaitEventsTimeout.html"},{"title":"glfwWindowHint","text":"<p>Sets the specified window hint to the desired value.</p> <pre><code>function glfwWindowHint(int $hint, int $value) : void\n</code></pre> <p>This function sets hints for the next call to <code>glfwCreateWindow</code>. The hints, once set, retain their values until changed by a call to this function or <code>glfwDefaultWindowHints</code>, or until the library is terminated.</p> <p>Only integer value hints can be set with this function. String value hints are set with <code>glfwWindowHintString</code>.</p> <p>This function does not check whether the specified hint values are valid. If you set hints to invalid values this will instead be reported by the next call to <code>glfwCreateWindow</code>.</p> <p>Some hints are platform specific. These may be set on any platform but they will only affect their specific platform. Other platforms will ignore them. Setting these hints requires no platform specific headers or functions.</p>  arguments  <ol> <li><code>int</code> <code>$hint</code> The <code>window hint</code> to set.</li> <li><code>int</code> <code>$value</code> The new value of the window hint.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwWindowHint.html"},{"title":"glfwWindowHintString","text":"<p>Sets the specified window hint to the desired value.</p> <pre><code>function glfwWindowHintString(int $hint, string $value) : void\n</code></pre> <p>This function sets hints for the next call to <code>glfwCreateWindow</code>. The hints, once set, retain their values until changed by a call to this function or <code>glfwDefaultWindowHints</code>, or until the library is terminated.</p> <p>Only string type hints can be set with this function. Integer value hints are set with <code>glfwWindowHint</code>.</p> <p>This function does not check whether the specified hint values are valid. If you set hints to invalid values this will instead be reported by the next call to <code>glfwCreateWindow</code>.</p> <p>Some hints are platform specific. These may be set on any platform but they will only affect their specific platform. Other platforms will ignore them. Setting these hints requires no platform specific headers or functions.</p>  arguments  <ol> <li><code>int</code> <code>$hint</code> The <code>window hint</code> to set.</li> <li><code>string</code> <code>$value</code> The new value of the window hint.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwWindowHintString.html"},{"title":"glfwWindowShouldClose","text":"<p>Checks the close flag of the specified window.</p> <pre><code>function glfwWindowShouldClose(\\GLFWwindow $window) : int\n</code></pre> <p>This function returns the value of the close flag of the specified window.</p>  arguments  <ol> <li><code>\\GLFWwindow</code> <code>$window</code> The window to query.</li> </ol>  returns  <p><code>int</code> The value of the close flag.</p>     <p>Copyright</p> <p>This documentation page is prased from the <code>glfw3.h</code> header file, and only modified to fit  the PHP-GFLW extension bindings. The original documentation copyright is as follows:</p> <pre><code>Copyright (c) 2002-2006 Marcus Geelnard\nCopyright (c) 2006-2019 Camilla L\u00f6wy\nhttps://www.glfw.org/license\n</code></pre>","location":"API/GLFW/glfwWindowShouldClose.html"},{"title":"ObjFileParser","text":"<p>The Obj File Parser is a simple parser for the Wavefront .obj file format that ships with PHP-GLFW. Loading some sort of geometry is essential for any 3D OpenGL application. This PHP OpenGL extension comes with a simple parser based on the fast_obj library written in C. The parser is able to load large .obj files in a matter of seconds. I also added some additional features to the parser, like the generation of tangents and bitangents for normal mapping.</p> <pre><code>namespace GL\\Geometry\n{\n    class ObjFileParser {}\n}\n</code></pre>","location":"API/Geometry/ObjFileParser.html"},{"title":"Usage","text":"","location":"API/Geometry/ObjFileParser.html#usage"},{"title":"Loading a .obj file","text":"<pre><code>use GL\\Geometry\\ObjFileParser;\n\n$model = new \\GL\\Geometry\\ObjFileParser('path/to/your/3dmodel.obj');\n</code></pre>","location":"API/Geometry/ObjFileParser.html#loading-a-obj-file"},{"title":"Extracting all vertices","text":"<p>If you don't care about materials and just want to extract all vertices from the .obj file, you can using the <code>getVertices</code> method.</p> <pre><code>$vertices = $model-&gt;getVertices('p');\n</code></pre> <p>Noticed the <code>p</code> argument? This is the vertex attribute you want to extract.  In this example we only want to extract the position data, which is what <code>p</code> stands for.</p> <p>Check out the getVertices method for more information about the available vertex attributes.</p> <p><code>$vertices</code> is now a FloatBuffer object that contains the positions of all vertices in the .obj file.</p> <pre><code>var_dump($vertices); // [\n    1.0, 2.0, 3.0, // vertex 1\n    4.0, 5.0, 6.0, // vertex 2\n    7.0, 8.0, 9.0, // vertex 3\n    // ...\n// ]\n</code></pre>","location":"API/Geometry/ObjFileParser.html#extracting-all-vertices"},{"title":"Extracting meshes","text":"<p>If your model is made up of multiple materials and you want to extract the vertices for each material, you can use the <code>getMeshes</code> method. This method is going to be slower than the <code>getVertices</code> method, because it has to group the vertices by material. But it's still pretty fast, and for sure faster then if you would implement the grouping in PHP.</p> <p>One main difference between the <code>getVertices</code> and <code>getMeshes</code> method is that the <code>getMeshes</code> method returns an array of Mesh objects.</p> <pre><code>// extract `pnc` [position, normal, texture coords]\n$meshes = $model-&gt;getMeshes('pnc');\n\nforeach ($meshes as $mesh) {\n    // do something with the mesh\n}\n</code></pre>  <p>Example</p> <p>A simple example to extract the diffuse color of a typical low poly model would be can be seen here</p>","location":"API/Geometry/ObjFileParser.html#extracting-meshes"},{"title":"Extracting part of a model","text":"<p>Many of the methods in this class allow you to pass a Group argument.  This allows you to extract only a part of the model.</p> <p>The available groups can be accessed over the <code>$model-&gt;groups</code> property and <code>$model-&gt;objects</code> property.</p> <pre><code>$model = new \\GL\\Geometry\\ObjFileParser('car.obj');\n$objects = $model-&gt;objects;\n\n$frontWheelGroup = array_filter($objects, function($group) {\n    return $group-&gt;name === 'wheel_front_left';\n});\n\n$vertices = $model-&gt;getVertices('p', $frontWheelGroup);\n</code></pre>","location":"API/Geometry/ObjFileParser.html#extracting-part-of-a-model"},{"title":"Properties","text":"<p>The ObjFileParser has a few public properties:</p>","location":"API/Geometry/ObjFileParser.html#properties"},{"title":"$materials","text":"<p>An array of material objects is parsed from the file.</p> <pre><code>/*\n * @var array&lt;\\GL\\Geometry\\ObjFileParser\\Material&gt;\n */\npublic readonly array $materials;\n</code></pre>","location":"API/Geometry/ObjFileParser.html#materials"},{"title":"$groups","text":"<p>An array of groups parsed from the file. (marked as \"g\")</p> <pre><code>/*\n * @var array&lt;\\GL\\Geometry\\ObjFileParser\\Group&gt;\n */\npublic readonly array $groups;\n</code></pre>","location":"API/Geometry/ObjFileParser.html#groups"},{"title":"$objects","text":"<p>An array of objects parsed from the file. (marked as \"o\")</p> <pre><code>/*\n * @var array&lt;\\GL\\Geometry\\ObjFileParser\\Group&gt;\n */\npublic readonly array $objects;\n</code></pre>  <p>What is the difference between groups and objects?</p> <p>One explanation I found said: Groups are used to group faces together. Objects are used to group groups together.  This is a bit confusing, but it is the way the .obj file format works.</p> <p>Now I could not confirm this as it seems that every 3D exporter does kinda what he wants with .obj files, so check your  .obj file and the settings of your 3D editor. </p>","location":"API/Geometry/ObjFileParser.html#objects"},{"title":"Methods","text":"","location":"API/Geometry/ObjFileParser.html#methods"},{"title":"<code>__construct</code>","text":"<p>Parses on <code>.obj</code> (Wavefront object) file and makes the parsed data available.</p> <pre><code>function __construct(string $file)\n</code></pre> <p>IMPORTANT: This obj. file parser does ONLY support triangulated meshes!</p>  arguments  <ol> <li><code>string</code> <code>$file</code> The path to the obj file to parse.</li> </ol>","location":"API/Geometry/ObjFileParser.html#__construct"},{"title":"<code>getVertices</code>","text":"<p>Returns a FloatBuffer object containing the requested vertex data for the given group.</p> <pre><code>function getVertices(string $layout, ?\\GL\\Geometry\\ObjFileParser\\Group $group = null) : \\GL\\Buffer\\FloatBuffer\n</code></pre> <p>If no group is given the entire object is returned.</p> <p>The layout of the buffer is specifed as a string, where each character represents a vertex attribute. The following characters are supported:</p> <ul> <li><code>p</code> - position</li> <li><code>n</code> - normal</li> <li><code>N</code> - generated normal (estimated for each face)</li> <li><code>c</code> - texture coordinate</li> <li><code>t</code> - tangent (estimated for each face)</li> <li><code>b</code> - bitangent (estimated for each face)</li> </ul> <p>You can use combine those characters to specify the layout of the buffer.</p> <p>Example: Layout: <code>pnc</code> Will generate the following buffer layout: <pre><code>[position.x, position.y, position.z, normal.x, normal.y, normal.z, textureCoordinate.x, textureCoordinate.y, ...]\n</code></pre></p>  arguments  <ol> <li><code>string</code> <code>$layout</code> The layout of the buffer.</li> <li><code>\\GL\\Geometry\\ObjFileParser\\Group|null</code> <code>$group</code> The group to get the vertex data for.</li> </ol>  returns  <p><code>\\GL\\Math\\FloatBuffer</code> The generated vertex data buffer</p>","location":"API/Geometry/ObjFileParser.html#getvertices"},{"title":"<code>getIndexedVertices</code>","text":"<p>Almost the same as getVertices but returns an Mesh object instead.</p> <pre><code>function getIndexedVertices(string $layout, ?\\GL\\Geometry\\ObjFileParser\\Group $group = null) : \\GL\\Geometry\\ObjFileParser\\Mesh\n</code></pre> <p>The mesh object is a wrapper around the vertex data buffer and the index buffer.</p> <p>Please see the <code>getVertices</code> docs for more information about the layout string.</p>  <p>Note</p> <p>Even you your object file is already indexed, this method will reindex the data. This is required to generate the normals and tangents. As a result this method is a lot slower than getVertices.</p>   arguments  <ol> <li><code>string</code> <code>$layout</code> The layout of the buffer.</li> <li><code>\\GL\\Geometry\\ObjFileParser\\Group|null</code> <code>$group</code> The group to get the vertex data for.</li> </ol>  returns  <p><code>\\GL\\Geometry\\Mesh</code> The generated mesh object</p>","location":"API/Geometry/ObjFileParser.html#getindexedvertices"},{"title":"<code>getMeshes</code>","text":"<p>Returns an array of Mesh objects grouped by material.</p> <pre><code>function getMeshes(string $layout, ?\\GL\\Geometry\\ObjFileParser\\Group $group = null) : array\n</code></pre> <p>In many situations your object / model is split into multiple submeshes, each with its own material. with every material there are usally different material properties associated. This usally requires a uniform to be updated, a different shader to be used or a different texture to be bound. This is where <code>getMeshes</code> comes in handy. It will return an array of Mesh objects, each with its own material.</p> <p>Please see the <code>getVertices</code> docs for more information about the layout string.</p>  arguments  <ol> <li><code>string</code> <code>$layout</code> The layout of the buffer.</li> <li><code>\\GL\\Geometry\\ObjFileParser\\Group|null</code> <code>$group</code> The group to get the vertex data for.</li> </ol>  returns  <p><code>\\GL\\Geometry\\ObjFileParser\\Mesh[]</code> </p>","location":"API/Geometry/ObjFileParser.html#getmeshes"},{"title":"ObjFileParser / Group","text":"<p>The Obj File Parser's Group class does not bring any new functionality to the table. It's just a container for index offsets that make up a group  in an obj file.</p> <pre><code>namespace GL\\Geometry\\ObjFileParser\n{\n    class Group {}\n}\n</code></pre>","location":"API/Geometry/ObjFileParserGroup.html"},{"title":"Properties","text":"","location":"API/Geometry/ObjFileParserGroup.html#properties"},{"title":"$name","text":"<p>The name of the group or object</p> <pre><code>/*\n * @var string|null\n */\npublic readonly ?string $name;\n</code></pre>","location":"API/Geometry/ObjFileParserGroup.html#name"},{"title":"$faceCount","text":"<p>The number of faces in the group</p> <pre><code>/*\n * @var int\n */\npublic readonly int $faceCount;\n</code></pre>","location":"API/Geometry/ObjFileParserGroup.html#facecount"},{"title":"$faceOffset","text":"<p>The offset of the first face in the resource object</p> <pre><code>/*\n * @var int\n */\npublic readonly int $faceOffset;\n</code></pre>","location":"API/Geometry/ObjFileParserGroup.html#faceoffset"},{"title":"$indexOffset","text":"<p>The offset of the first index in the resource object</p> <pre><code>/*\n * @var int\n */\npublic readonly int $indexOffset;\n</code></pre>","location":"API/Geometry/ObjFileParserGroup.html#indexoffset"},{"title":"ObjFileParser / Material","text":"<p>The Obj File Parser's Material class does not bring any new functionality to the table. It's just a container for the material properties that can be defined in an obj file.</p> <pre><code>namespace GL\\Geometry\\ObjFileParser\n{\n    class Material {}\n}\n</code></pre>","location":"API/Geometry/ObjFileParserMaterial.html"},{"title":"Properties","text":"","location":"API/Geometry/ObjFileParserMaterial.html#properties"},{"title":"$name","text":"<p>The name of the material. (marked as \"newmtl\")  This is the same name you use in a 3D modelling software like Blender or 3DS Max to reference the material.</p> <pre><code>/*\n * @var string\n */\npublic readonly string $name;\n</code></pre>","location":"API/Geometry/ObjFileParserMaterial.html#name"},{"title":"$ambient","text":"<p>The ambient color of the material. (marked as \"Ka\") This usally controls the color of the object in the shadow or when a light is not directly hitting the object.</p> <pre><code>/*\n * @var \\GL\\Math\\Vec3\n */\npublic readonly Vec3 $ambient;\n</code></pre>","location":"API/Geometry/ObjFileParserMaterial.html#ambient"},{"title":"$diffuse","text":"<p>The diffuse color of the material. (marked as \"Kd\") This usally controls the color of the object when a light is directly hitting the object. This property is often also used for albedo or base color.</p> <pre><code>/*\n * @var \\GL\\Math\\Vec3\n */\npublic readonly Vec3 $diffuse;\n</code></pre>","location":"API/Geometry/ObjFileParserMaterial.html#diffuse"},{"title":"$specular","text":"<p>The specular color of the material. (marked as \"Ks\") This property is often also used for reflection color, shininess or highlights color.</p> <pre><code>/*\n * @var \\GL\\Math\\Vec3\n */\npublic readonly Vec3 $specular;\n</code></pre>","location":"API/Geometry/ObjFileParserMaterial.html#specular"},{"title":"$emmisive","text":"<p>The emmisive color of the material. (marked as \"Ke\") This property is often also used for illumination, self glow or light emission.</p> <pre><code>/*\n * @var \\GL\\Math\\Vec3\n */\npublic readonly Vec3 $emmisive;\n</code></pre>","location":"API/Geometry/ObjFileParserMaterial.html#emmisive"},{"title":"$transmittance","text":"<p>The transmittance of the material. (marked as \"Tf\") This property is often also used for transparency or refraction color.</p> <pre><code>/*\n * @var \\GL\\Math\\Vec3\n */\npublic readonly Vec3 $transmittance;\n</code></pre>","location":"API/Geometry/ObjFileParserMaterial.html#transmittance"},{"title":"$transmissionFilter","text":"<p>The transmission filter color property of the Material. (marked as \"Tf\") This property is often also used for transparency or refraction color.</p> <pre><code>/*\n * @var \\GL\\Math\\Vec3\n */\npublic readonly Vec3 $transmissionFilter;\n</code></pre>","location":"API/Geometry/ObjFileParserMaterial.html#transmissionfilter"},{"title":"$shininess","text":"<p>The shininess of the material. (marked as \"Ns\") This property is often also used for glossiness or specular power.</p> <pre><code>/*\n * @var float\n */\npublic readonly float $shininess;\n</code></pre>","location":"API/Geometry/ObjFileParserMaterial.html#shininess"},{"title":"$indexOfRefraction","text":"<p>The index of refraction of the materials. (marked as \"Ni\")</p> <pre><code>/*\n * @var float\n */\npublic readonly float $indexOfRefraction;\n</code></pre>","location":"API/Geometry/ObjFileParserMaterial.html#indexofrefraction"},{"title":"$dissolve","text":"<p>The dissolve of the material. (marked as \"d\") This property is often also used for opacity or transparency.</p> <pre><code>/*\n * @var float\n */\npublic readonly float $dissolve;\n</code></pre>","location":"API/Geometry/ObjFileParserMaterial.html#dissolve"},{"title":"$illuminationModel","text":"<p>The illumination model of the material. (marked as \"illum\")</p> <p>from the obj file specification:</p> <ol> <li>Color on and Ambient off</li> <li>Color on and Ambient on</li> <li>Highlight on</li> <li>Reflection on and Ray trace on</li> <li>Transparency: Glass on, Reflection: Ray trace on</li> <li>Reflection: Fresnel on and Ray trace on</li> <li>Transparency: Refraction on, Reflection: Fresnel off and Ray trace on</li> <li>Transparency: Refraction on, Reflection: Fresnel on and Ray trace on</li> <li>Reflection on and Ray trace off</li> <li>Transparency: Glass on, Reflection: Ray trace off</li> <li>Casts shadows onto invisible surfaces</li> </ol> <pre><code>/*\n * @var int\n */\npublic readonly int $illuminationModel;\n</code></pre>","location":"API/Geometry/ObjFileParserMaterial.html#illuminationmodel"},{"title":"$ambientTexture","text":"<p>The ambient texture of the material. (marked as \"map_Ka\")</p> <pre><code>/*\n * @var \\GL\\Geometry\\ObjFileParser\\Texture\n */\npublic readonly Texture $ambientTexture;\n</code></pre>","location":"API/Geometry/ObjFileParserMaterial.html#ambienttexture"},{"title":"$diffuseTexture","text":"<p>The diffuse texture of the material. (marked as \"map_Kd\")</p> <pre><code>/*\n * @var \\GL\\Geometry\\ObjFileParser\\Texture\n */\npublic readonly Texture $diffuseTexture;\n</code></pre>","location":"API/Geometry/ObjFileParserMaterial.html#diffusetexture"},{"title":"$specularTexture","text":"<p>The specular texture of the material. (marked as \"map_Ks\")</p> <pre><code>/*\n * @var \\GL\\Geometry\\ObjFileParser\\Texture\n */\npublic readonly Texture $specularTexture;\n</code></pre>","location":"API/Geometry/ObjFileParserMaterial.html#speculartexture"},{"title":"$emissiveTexture","text":"<p>The emissive texture of the material. (marked as \"map_Ke\")</p> <pre><code>/*\n * @var \\GL\\Geometry\\ObjFileParser\\Texture\n */\npublic readonly Texture $emissiveTexture;\n</code></pre>","location":"API/Geometry/ObjFileParserMaterial.html#emissivetexture"},{"title":"$transmittanceTexture","text":"<p>The transmittance texture of the material. (marked as \"map_Tf\")</p> <pre><code>/*\n * @var \\GL\\Geometry\\ObjFileParser\\Texture\n */\npublic readonly Texture $transmittanceTexture;\n</code></pre>","location":"API/Geometry/ObjFileParserMaterial.html#transmittancetexture"},{"title":"$shininessTexture","text":"<p>The shininess texture of the material. (marked as \"map_Ns\")</p> <pre><code>/*\n * @var \\GL\\Geometry\\ObjFileParser\\Texture\n */\npublic readonly Texture $shininessTexture;\n</code></pre>","location":"API/Geometry/ObjFileParserMaterial.html#shininesstexture"},{"title":"$indexOfRefractionTexture","text":"<p>The index of refraction texture of the material. (marked as \"map_Ni\")</p> <pre><code>/*\n * @var \\GL\\Geometry\\ObjFileParser\\Texture\n */\npublic readonly Texture $indexOfRefractionTexture;\n</code></pre>","location":"API/Geometry/ObjFileParserMaterial.html#indexofrefractiontexture"},{"title":"$dissolveTexture","text":"<p>The dissolve texture of the material. (marked as \"map_d\")</p> <pre><code>/*\n * @var \\GL\\Geometry\\ObjFileParser\\Texture\n */\npublic readonly Texture $dissolveTexture;\n</code></pre>","location":"API/Geometry/ObjFileParserMaterial.html#dissolvetexture"},{"title":"$bumpTexture","text":"<p>The bump texture of the material. (marked as \"map_bump\")</p> <pre><code>/*\n * @var \\GL\\Geometry\\ObjFileParser\\Texture\n */\npublic readonly Texture $bumpTexture;\n</code></pre>","location":"API/Geometry/ObjFileParserMaterial.html#bumptexture"},{"title":"ObjFileParser / Mesh","text":"<p>The Obj File Parser's Mesh class does not bring any new functionality to the table. It's just a container for the three objects that can make up a mesh by PHP OpenGLs definition. </p> <ul> <li>Vertices (FloatBuffer) storing the vertex data, like position, normal, texture coordinates, etc.</li> <li>indices (UIntBuffer) storing the indices of the vertices that make up the triangles. optional</li> <li>Material the material of the mesh. optional</li> </ul> <pre><code>namespace GL\\Geometry\\ObjFileParser\n{\n    class Mesh {}\n}\n</code></pre>","location":"API/Geometry/ObjFileParserMesh.html"},{"title":"Properties","text":"","location":"API/Geometry/ObjFileParserMesh.html#properties"},{"title":"$material","text":"<p>The material of the mesh (can be null)</p> <pre><code>/*\n * @var \\GL\\Geometry\\ObjFileParser\\Material|null\n */\npublic readonly ?Material $material;\n</code></pre>","location":"API/Geometry/ObjFileParserMesh.html#material"},{"title":"$vertices","text":"<p>A float buffer containing vertex data of the mesh. The layout of the data is not fixed but rather requested by the user. Read more about the layout here.</p> <pre><code>/*\n * @var \\GL\\Buffer\\FloatBuffer\n */\npublic readonly FloatBuffer $vertices;\n</code></pre>","location":"API/Geometry/ObjFileParserMesh.html#vertices"},{"title":"$indices","text":"<p>A unsigned int buffer containing indices of the mesh. (optional)</p> <pre><code>/*\n * @var \\GL\\Buffer\\UIntBuffer|null\n */\npublic readonly ?UIntBuffer $indices;\n</code></pre>","location":"API/Geometry/ObjFileParserMesh.html#indices"},{"title":"Mat4 - GL Math","text":"<p>PHP-GLFW comes with a built-in math library this is a quick reference for the <code>Mat4</code> class. The <code>Mat4</code> represents a matrix 4x4 Matrix with 16 values.</p> <p>The values hold by the Mat4 object are stored internally as real float values, and can be accessed in an array like fashion:</p> <pre><code>$mat = new Mat4();\n$mat[0] = 42.0;\n$mat[15] = 42.0;\n\necho $mat[0];\necho $mat[15];\n</code></pre>","location":"API/Math/Mat4.html"},{"title":"Methods","text":"","location":"API/Math/Mat4.html#methods"},{"title":"<code>__construct</code>","text":"<p>Constructucts a new Mat4 matrix Does not take any arguments and always returns an identity matrix.</p> <pre><code>function __construct()\n</code></pre> <p>aka: <pre><code>1 0 0 0\n0 1 0 0\n0 0 1 0\n0 0 0 1\n</code></pre></p>","location":"API/Math/Mat4.html#__construct"},{"title":"<code>fromArray</code>","text":"<p>Constructs and returns a new matrix based on the given array of values</p> <pre><code>static function fromArray(array $values) : \\GL\\Math\\Mat4\n</code></pre> <pre><code>$matrix = Mat4::fromArray([\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1\n]);\n</code></pre>  arguments  <ol> <li><code>array</code> <code>$values</code> The values to use for the matrix. (flat)</li> </ol>  returns  <p><code>\\Mat4</code> The new matrix.</p>","location":"API/Math/Mat4.html#fromarray"},{"title":"<code>inverted</code>","text":"<p>Constructs and returns an inverse of the given matrix</p> <pre><code>static function inverted(\\GL\\Math\\Mat4 $matrix) : \\GL\\Math\\Mat4\n</code></pre> <pre><code>$inverse = Mat4::inverse($matrix);\n</code></pre>  arguments  <ol> <li><code>\\Mat4</code> <code>$matrix</code> The matrix to invert.</li> </ol>  returns  <p><code>\\Mat4</code> The inverted matrix.</p>","location":"API/Math/Mat4.html#inverted"},{"title":"<code>multiplyQuat</code>","text":"<p>Mat4 * Quat</p> <pre><code>static function multiplyQuat(\\GL\\Math\\Mat4 $left, \\GL\\Math\\Quat $right) : \\GL\\Math\\Mat4\n</code></pre> <p>Multiplies the left matrix by the right quaternion</p> <p>Note: This method only exists because there is a bug with the order of operation in PHP.</p>","location":"API/Math/Mat4.html#multiplyquat"},{"title":"<code>copy</code>","text":"<p>Copys the current matrix</p> <pre><code>function copy() : \\GL\\Math\\Mat4\n</code></pre> <p>Returns a new instance of the current matrix with the same values. This means that any modifications made to the returned matrix will not affect the current matrix.</p> <pre><code>$copy = $matrix-&gt;copy();\n</code></pre>  returns  <p><code>\\Mat4</code> The copy of the current matrix.</p>","location":"API/Math/Mat4.html#copy"},{"title":"<code>row</code>","text":"<p>Returns the row at the given index.</p> <pre><code>function row(int $index) : \\GL\\Math\\Vec4\n</code></pre> <p>Example usage:</p> <pre><code>$matrix = Mat4::fromArray([\n    [1.0, 2.0, 3.0, 4.0],\n    [5.0, 6.0, 7.0, 8.0],\n    [9.0, 10.0, 11.0, 12.0],\n    [13.0, 14.0, 15.0, 16.0]\n]);\n\n// Get the first row\n$row = $matrix-&gt;row(0);\n// Expected result: Vec4(1.0, 2.0, 3.0, 4.0)\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> The index of the row to return.</li> </ol>  returns  <p><code>\\Vec4</code> The row at the given index.</p>","location":"API/Math/Mat4.html#row"},{"title":"<code>setRow</code>","text":"<p>Sets the row at the given index to the given row</p> <pre><code>function setRow(int $index, \\GL\\Math\\Vec4 $row) : void\n</code></pre> <p>Example usage: <pre><code>$matrix = new Mat4();\n$row = new Vec4(1, 2, 3, 4);\n$matrix-&gt;setRow(0, $row);\n</code></pre></p>  arguments  <ol> <li><code>int</code> <code>$index</code> The index of the row to set.</li> <li><code>\\Vec4</code> <code>$row</code> The row to set.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Math/Mat4.html#setrow"},{"title":"<code>col</code>","text":"<p>Returns the column at the given index.</p> <pre><code>function col(int $index) : \\GL\\Math\\Vec4\n</code></pre> <p>This method retrieves a column from the matrix at the specified index and returns it as a Vec4 object.</p> <p>Example: <pre><code>$matrix = Mat4::fromArray([\n    [1.0, 2.0, 3.0, 4.0],\n    [5.0, 6.0, 7.0, 8.0],\n    [9.0, 10.0, 11.0, 12.0],\n    [13.0, 14.0, 15.0, 16.0]\n]);\n\n$col = $matrix-&gt;col(0);\n\n// Returns Vec4(1.0, 5.0, 9.0, 13.0)\n</code></pre></p>  arguments  <ol> <li><code>int</code> <code>$index</code> The index of the column to return.</li> </ol>  returns  <p><code>\\Vec4</code> The column at the given index.</p>","location":"API/Math/Mat4.html#col"},{"title":"<code>setCol</code>","text":"<p>Sets the column at the given index to the given column</p> <pre><code>function setCol(int $index, \\GL\\Math\\Vec4 $col) : void\n</code></pre> <pre><code>// Create a new matrix and set the second column\n$matrix = new Mat4();\n$col = new Vec4(1, 2, 3, 4);\n$matrix-&gt;setCol(1, $col);\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> The index of the column to set.</li> <li><code>\\Vec4</code> <code>$col</code> The column to set.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Math/Mat4.html#setcol"},{"title":"<code>lookAt</code>","text":"<p>Sets the matrix to a lookAt matrix</p> <pre><code>function lookAt(\\GL\\Math\\Vec3 $eye, \\GL\\Math\\Vec3 $center, \\GL\\Math\\Vec3 $up) : void\n</code></pre> <p>The <code>lookAt()</code> method sets the matrix to a lookAt matrix based on the camera's position and orientation. It takes three parameters: <code>$eye</code>, <code>$center</code>, and <code>$up</code>, which are all instances of the <code>Vec3</code> class.</p> <p>The <code>$eye</code> parameter indicates the position of the camera, while <code>$center</code> indicates the point in space to look at. The <code>$up</code> parameter specifies the up vector, which determines the orientation of the camera.</p> <p>Example usage:</p> <pre><code>// Create a new matrix\n$matrix = new Mat4();\n\n// Set the matrix to a lookAt matrix\n$matrix-&gt;lookAt(\n   new Vec3(0, 0, 5), // eye\n   new Vec3(0, 0, 0), // center\n   new Vec3(0, 1, 0)  // up\n);\n</code></pre> <p>This will create a new matrix and set it to a lookAt matrix with the camera positioned at <code>(0, 0, 5)</code>, looking at the origin <code>(0, 0, 0)</code>, with the up vector pointing in the positive y direction.</p>  arguments  <ol> <li><code>\\Vec3</code> <code>$eye</code> The position of the camera.</li> <li><code>\\Vec3</code> <code>$center</code> The position to look at.</li> <li><code>\\Vec3</code> <code>$up</code> The up vector.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Math/Mat4.html#lookat"},{"title":"<code>perspective</code>","text":"<p>Sets the matrix to a perspective matrix</p> <pre><code>function perspective(float $fov, float $aspect, float $near, float $far) : void\n</code></pre> <pre><code>$matrix-&gt;perspective($fov, $aspect, $near, $far);\n</code></pre>  arguments  <ol> <li><code>float</code> <code>$fov</code> The field of view.</li> <li><code>float</code> <code>$aspect</code> The aspect ratio.</li> <li><code>float</code> <code>$near</code> The near plane.</li> <li><code>float</code> <code>$far</code> The far plane.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Math/Mat4.html#perspective"},{"title":"<code>ortho</code>","text":"<p>Sets the matrix to an orthographic matrix</p> <pre><code>function ortho(float $left, float $right, float $bottom, float $top, float $near, float $far) : void\n</code></pre> <pre><code>$matrix-&gt;ortho($left, $right, $bottom, $top, $near, $far);\n</code></pre>  arguments  <ol> <li><code>float</code> <code>$left</code> The left plane.</li> <li><code>float</code> <code>$right</code> The right plane.</li> <li><code>float</code> <code>$bottom</code> The bottom plane.</li> <li><code>float</code> <code>$top</code> The top plane.</li> <li><code>float</code> <code>$near</code> The near plane.</li> <li><code>float</code> <code>$far</code> The far plane.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Math/Mat4.html#ortho"},{"title":"<code>transpose</code>","text":"<p>Tranposes the matrix</p> <pre><code>function transpose() : void\n</code></pre> <pre><code>$matrix-&gt;transpose();\n</code></pre>  returns  <p><code>void</code> </p>","location":"API/Math/Mat4.html#transpose"},{"title":"<code>inverse</code>","text":"<p>Inverts the current matrix</p> <pre><code>function inverse() : void\n</code></pre> <pre><code>$matrix-&gt;inverse();\n</code></pre>  returns  <p><code>void</code> </p>","location":"API/Math/Mat4.html#inverse"},{"title":"<code>scale</code>","text":"<p>Scale the matrix by the given vector</p> <pre><code>function scale(\\GL\\Math\\Vec3 $scale) : void\n</code></pre> <pre><code>$matrix-&gt;scale(new Vec3(2, 2, 2));\n</code></pre>","location":"API/Math/Mat4.html#scale"},{"title":"<code>translate</code>","text":"<p>Translates the matrix by the given vector</p> <pre><code>function translate(\\GL\\Math\\Vec3 $vector) : void\n</code></pre> <pre><code>$matrix-&gt;translate(new Vec3(1, 1, 1));\n</code></pre>  arguments  <ol> <li><code>\\Vec3</code> <code>$vector</code> The vector to translate by.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Math/Mat4.html#translate"},{"title":"<code>rotate</code>","text":"<p>Rotates the matrix by the given angle around the given axis</p> <pre><code>function rotate(float $angle, \\GL\\Math\\Vec3 $axis) : void\n</code></pre> <pre><code>$matrix-&gt;rotate(GLM::radians(90), new Vec3(0, 1, 0));\n</code></pre>  arguments  <ol> <li><code>float</code> <code>$angle</code> The angle to rotate by.</li> <li><code>\\Vec3</code> <code>$axis</code> The axis to rotate around.</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Math/Mat4.html#rotate"},{"title":"<code>determinant</code>","text":"<p>Retruns the determinant of the matrix</p> <pre><code>function determinant() : float\n</code></pre> <pre><code>$det = $matrix-&gt;determinant();\n</code></pre>  returns  <p><code>float</code> The determinant of the matrix.</p>","location":"API/Math/Mat4.html#determinant"},{"title":"Quat - GL Math","text":"<p>PHP-GLFW comes with a built-in math library this is a quick reference for the <code>Quat</code> class. The <code>Quat</code> represents a vector with 4 components (<code>w</code>, <code>x</code>, <code>y</code>, <code>z</code>, ), which can be and is generally used to represent rotations.</p> <pre><code>namespace GL\\Math\n{\n    class Quat {\n        public float $w;\n        public float $x;\n        public float $y;\n        public float $z;\n    }\n}\n</code></pre> <p>The properties of this class are virtual, meaning in this case they are not real PHP properties. But rather values stored internally that  can be accessed like a property. The same values can be read and written using different names:</p> <pre><code>$quat = new Quat;\n$quat-&gt;w = 42.0;\n$quat-&gt;x = 42.0;\n$quat-&gt;y = 42.0;\n$quat-&gt;z = 42.0;\n</code></pre> <p>Is exactly the same as:</p> <pre><code>$quat = new Quat;\n$quat[0] = 42.0;\n$quat[1] = 42.0;\n$quat[2] = 42.0;\n$quat[3] = 42.0;\n</code></pre>","location":"API/Math/Quat.html"},{"title":"Methods","text":"","location":"API/Math/Quat.html#methods"},{"title":"<code>__construct</code>","text":"<p>Constructor</p> <pre><code>function __construct(?float $w = null, ?float $x = null, ?float $y = null, ?float $z = null)\n</code></pre>","location":"API/Math/Quat.html#__construct"},{"title":"<code>fromVec4</code>","text":"<p>Constructs and returns a new quaternion based on the given Vec4 vector.</p> <pre><code>static function fromVec4(\\GL\\Math\\Vec4 $vec) : \\GL\\Math\\Quat\n</code></pre> <p>The quaternion is arragned as (w, x, y, z), while the vector is arranged as (x, y, z, w). This method will swap the x and w components.</p> <pre><code>$quat = Quat::fromVec4($vector);\n</code></pre>  arguments  <ol> <li><code>\\Vec4</code> <code>$vector</code> The vector to construct the quaternion from.</li> </ol>  returns  <p><code>\\Quat</code> The constructed quaternion.</p>","location":"API/Math/Quat.html#fromvec4"},{"title":"<code>fromMat4</code>","text":"<p>Constructs and returns a new quaternion based on the given Mat4 matrix</p> <pre><code>static function fromMat4(\\GL\\Math\\Mat4 $matrix) : \\GL\\Math\\Quat\n</code></pre> <pre><code>$quat = Quat::fromMat4($matrix);\n</code></pre>  arguments  <ol> <li><code>\\Mat4</code> <code>$matrix</code> The matrix to construct the quaternion from.</li> </ol>  returns  <p><code>\\Quat</code> The constructed quaternion.</p>","location":"API/Math/Quat.html#frommat4"},{"title":"<code>inverted</code>","text":"<p>Constructs and return a inverted quaternion based on the given one</p> <pre><code>static function inverted(\\GL\\Math\\Quat $quat) : \\GL\\Math\\Quat\n</code></pre> <pre><code>$inverted = Quat::inverted($quat);\n</code></pre>  arguments  <ol> <li><code>\\Quat</code> <code>$quat</code> The quaternion to invert.</li> </ol>  returns  <p><code>\\Quat</code> The inverted quaternion.</p>","location":"API/Math/Quat.html#inverted"},{"title":"<code>normalized</code>","text":"<p>Constructs and returns a normalized quaternion based on the given one</p> <pre><code>static function normalized(\\GL\\Math\\Quat $quat) : \\GL\\Math\\Quat\n</code></pre> <pre><code>$normalized = Quat::normalized($quat);\n</code></pre>  arguments  <ol> <li><code>\\Quat</code> <code>$quat</code> The quaternion to normalize.</li> </ol>  returns  <p><code>\\Quat</code> The normalized quaternion.</p>","location":"API/Math/Quat.html#normalized"},{"title":"<code>mix</code>","text":"<p>Performs a linear interpolation between two quaternions and returns the resulting quaternion.</p> <pre><code>static function mix(\\GL\\Math\\Quat $left, \\GL\\Math\\Quat $right, float $t) : \\GL\\Math\\Quat\n</code></pre> <pre><code>$result = Quat::mix($left, $right, $t);\n</code></pre>  arguments  <ol> <li><code>\\Quat</code> <code>$left</code> The left quaternion.</li> <li><code>\\Quat</code> <code>$right</code> The right quaternion.</li> <li><code>float</code> <code>$t</code> The interpolation factor.</li> </ol>  returns  <p><code>\\Quat</code> The interpolated quaternion.</p>","location":"API/Math/Quat.html#mix"},{"title":"<code>slerp</code>","text":"<p>Performs a spherical linear interpolation between two quaternions and returns the resulting quaternion.</p> <pre><code>static function slerp(\\GL\\Math\\Quat $left, \\GL\\Math\\Quat $right, float $t) : \\GL\\Math\\Quat\n</code></pre> <pre><code>$result = Quat::slerp($left, $right, $t);\n</code></pre>  arguments  <ol> <li><code>\\Quat</code> <code>$left</code> The left quaternion.</li> <li><code>\\Quat</code> <code>$right</code> The right quaternion.</li> <li><code>float</code> <code>$t</code> The interpolation factor.</li> </ol>  returns  <p><code>\\Quat</code> The interpolated quaternion.</p>","location":"API/Math/Quat.html#slerp"},{"title":"<code>dot</code>","text":"<p>Returns the dot product of two quaternions.</p> <pre><code>static function dot(\\GL\\Math\\Quat $left, \\GL\\Math\\Quat $right) : float\n</code></pre> <pre><code>$dot = Quat::dot($left, $right);\n</code></pre>  arguments  <ol> <li><code>\\Quat</code> <code>$left</code> The left quaternion.</li> <li><code>\\Quat</code> <code>$right</code> The right quaternion.</li> </ol>  returns  <p><code>float</code> The dot product.</p>","location":"API/Math/Quat.html#dot"},{"title":"<code>normalize</code>","text":"<p>The same as <code>normalized()</code>, but modifies the current quaternion instead of creating a new one.</p> <pre><code>function normalize() : void\n</code></pre> <pre><code>$quat-&gt;normalize();\n</code></pre>","location":"API/Math/Quat.html#normalize"},{"title":"<code>length</code>","text":"<p>Returns the length of the quaternion</p> <pre><code>function length() : float\n</code></pre> <pre><code>$length = $quat-&gt;length();\n</code></pre>","location":"API/Math/Quat.html#length"},{"title":"<code>eulerAngles</code>","text":"<p>Returns the quaternion represented as euler angles (in radians)</p> <pre><code>function eulerAngles() : \\GL\\Math\\Vec3\n</code></pre> <pre><code>$euler = $quat-&gt;eulerAngles();\n</code></pre>  returns  <p><code>\\Vec3</code> The euler angles.</p>","location":"API/Math/Quat.html#eulerangles"},{"title":"<code>rotate</code>","text":"<p>Rotates the quaternion by the given angle (in radians) around the given axis</p> <pre><code>function rotate(float $angle, \\GL\\Math\\Vec3 $axis) : void\n</code></pre> <pre><code>$quat-&gt;rotate(GLM::radians(45.0), new Vec3(0, 1, 0));\n</code></pre>  arguments  <ol> <li><code>float</code> <code>$angle</code> The angle to rotate by (in radians)</li> <li><code>\\Vec3</code> <code>$axis</code> The axis to rotate around</li> </ol>","location":"API/Math/Quat.html#rotate"},{"title":"<code>inverse</code>","text":"<p>Invseres the current quaternion, this is basically the same as <code>inverted()</code> but modifies the current quaternion instead of creating a new one.</p> <pre><code>function inverse() : void\n</code></pre> <pre><code>$quat-&gt;inverse();\n</code></pre>","location":"API/Math/Quat.html#inverse"},{"title":"<code>mat4</code>","text":"<p>Constructs a Mat4 matrix based on the current quaternion</p> <pre><code>function mat4() : \\GL\\Math\\Mat4\n</code></pre> <pre><code>$matrix = $quat-&gt;mat4();\n</code></pre>  returns  <p><code>\\Mat4</code> The matrix representation of the quaternion.</p>","location":"API/Math/Quat.html#mat4"},{"title":"Vec2 - GL Math","text":"<p>PHP-GLFW comes with built in fixed size vector classes. <code>Vec2</code> represents a vector with 2 components ( <code>x</code>, <code>y</code>, ).</p> <pre><code>namespace GL\\Math\n{\n    class Vec2 {\n        public float $x;\n        public float $y;\n    }\n}\n</code></pre> <p>The properties of this class are virtual, meaning in this case they are not real PHP properties. But rather values stored internally that  can be accessed like a property. The same values can be read and written using different names for convience:</p> <pre><code>$vec = new Vec2;\n$vec-&gt;x = 42.0;\n$vec-&gt;y = 42.0;\n</code></pre> <p>Is exactly the same as:</p> <pre><code>$vec = new Vec2;\n$vec-&gt;r = 42.0;\n$vec-&gt;g = 42.0;\n</code></pre>","location":"API/Math/Vec2.html"},{"title":"Methods","text":"","location":"API/Math/Vec2.html#methods"},{"title":"<code>__construct</code>","text":"<p>Constructor</p> <pre><code>function __construct(?float $x = null, ?float $y = null)\n</code></pre>","location":"API/Math/Vec2.html#__construct"},{"title":"<code>normalized</code>","text":"<p>Retruns a normalized version of the given Vec2         * <pre><code>$normalized = Vec2::normalize(new Vec2($x, $y, $z));\n</code></pre></p> <pre><code>static function normalized(\\GL\\Math\\Vec2 $vec) : \\GL\\Math\\Vec2\n</code></pre>  arguments  <ol> <li><code>\\Vec2</code> <code>$vec</code> The vector to normalize.</li> </ol>  returns  <p><code>\\Vec2</code> The normalized vector.</p>","location":"API/Math/Vec2.html#normalized"},{"title":"<code>distance</code>","text":"<p>Returns the distance between the left and right vectors</p> <pre><code>static function distance(\\GL\\Math\\Vec2 $left, \\GL\\Math\\Vec2 $right) : float\n</code></pre> <pre><code>$distance = Vec2::distance($left, $right);\n</code></pre>  arguments  <ol> <li><code>\\Vec2</code> <code>$left</code> The left vector.</li> <li><code>\\Vec2</code> <code>$right</code> The right vector.</li> </ol>  returns  <p><code>float</code> The distance between the left and right vectors.</p>","location":"API/Math/Vec2.html#distance"},{"title":"<code>distance2</code>","text":"<p>Returns the squared distance between the left and right vectors</p> <pre><code>static function distance2(\\GL\\Math\\Vec2 $left, \\GL\\Math\\Vec2 $right) : float\n</code></pre> <pre><code>$distance = Vec2::distance2($left, $right);\n</code></pre>  arguments  <ol> <li><code>\\Vec2</code> <code>$left</code> The left vector.</li> <li><code>\\Vec2</code> <code>$right</code> The right vector.</li> </ol>  returns  <p><code>float</code> The squared distance between the left and right vectors.</p>","location":"API/Math/Vec2.html#distance2"},{"title":"<code>dot</code>","text":"<p>Returns the dot product of the left and right vectors</p> <pre><code>static function dot(\\GL\\Math\\Vec2 $left, \\GL\\Math\\Vec2 $right) : float\n</code></pre> <pre><code>$dot = Vec2::dot($left, $right);\n</code></pre>  arguments  <ol> <li><code>\\Vec2</code> <code>$left</code> The left vector.</li> <li><code>\\Vec2</code> <code>$right</code> The right vector.</li> </ol>  returns  <p><code>float</code> The dot product of the left and right vectors.</p>","location":"API/Math/Vec2.html#dot"},{"title":"<code>mix</code>","text":"<p>Linearly interpolates between the left and right vectors by the given t value.</p> <pre><code>static function mix(\\GL\\Math\\Vec2 $left, \\GL\\Math\\Vec2 $right, float $t) : \\GL\\Math\\Vec2\n</code></pre> <pre><code>$mixed = Vec2::mix($left, $right, $t);\n</code></pre>  arguments  <ol> <li><code>\\Vec2</code> <code>$left</code> The left vector.</li> <li><code>\\Vec2</code> <code>$right</code> The right vector.</li> <li><code>float</code> <code>$t</code> The t value (progress / state) 0.0 == left, 1.0 == right.</li> </ol>  returns  <p><code>\\Vec2</code> The mixed vector.</p>","location":"API/Math/Vec2.html#mix"},{"title":"<code>lerp</code>","text":"<p>Linearly interpolates between the left and right vectors by the given t value.</p> <pre><code>static function lerp(\\GL\\Math\\Vec2 $left, \\GL\\Math\\Vec2 $right, float $t) : \\GL\\Math\\Vec2\n</code></pre> <p>This does exactly the same as mix..</p> <pre><code>$lerped = Vec2::lerp($left, $right, $t);\n</code></pre>  arguments  <ol> <li><code>\\Vec2</code> <code>$left</code> The left vector.</li> <li><code>\\Vec2</code> <code>$right</code> The right vector.</li> <li><code>float</code> <code>$t</code> The t value (progress / state) 0.0 == left, 1.0 == right.</li> </ol>  returns  <p><code>\\Vec2</code> The lerped vector.</p>","location":"API/Math/Vec2.html#lerp"},{"title":"<code>slerp</code>","text":"<p>Spherically interpolates between the left and right vectors by the given t value.</p> <pre><code>static function slerp(\\GL\\Math\\Vec2 $left, \\GL\\Math\\Vec2 $right, float $t) : \\GL\\Math\\Vec2\n</code></pre> <pre><code>$slerped = Vec2::slerp($left, $right, $t);\n</code></pre>  arguments  <ol> <li><code>\\Vec2</code> <code>$left</code> The left vector.</li> <li><code>\\Vec2</code> <code>$right</code> The right vector.</li> <li><code>float</code> <code>$t</code> The t value (progress / state) 0.0 == left, 1.0 == right.</li> </ol>  returns  <p><code>\\Vec2</code> The slerped vector.</p>","location":"API/Math/Vec2.html#slerp"},{"title":"<code>length</code>","text":"<p>Returns the length of the vector</p> <pre><code>function length() : float\n</code></pre>  returns  <p><code>float</code> </p>","location":"API/Math/Vec2.html#length"},{"title":"<code>distanceTo</code>","text":"<p>Returns the distance between this vector and another</p> <pre><code>function distanceTo(\\GL\\Math\\Vec2 $right) : float\n</code></pre>  returns  <p><code>float</code> </p>","location":"API/Math/Vec2.html#distanceto"},{"title":"<code>distance2To</code>","text":"<p>Returns squared distance between this vector and another</p> <pre><code>function distance2To(\\GL\\Math\\Vec2 $right) : float\n</code></pre>  returns  <p><code>float</code> </p>","location":"API/Math/Vec2.html#distance2to"},{"title":"<code>normalize</code>","text":"<p>normalizes the current vector</p> <pre><code>function normalize() : void\n</code></pre>  returns  <p><code>void</code> </p>","location":"API/Math/Vec2.html#normalize"},{"title":"<code>abs</code>","text":"<p>Makes each component x if x &gt;= 0; otherwise, -x</p> <pre><code>function abs() : void\n</code></pre>  returns  <p><code>void</code> </p>","location":"API/Math/Vec2.html#abs"},{"title":"Vec3 - GL Math","text":"<p>PHP-GLFW comes with built in fixed size vector classes. <code>Vec3</code> represents a vector with 3 components ( <code>x</code>, <code>y</code>, <code>z</code>, ).</p> <pre><code>namespace GL\\Math\n{\n    class Vec3 {\n        public float $x;\n        public float $y;\n        public float $z;\n    }\n}\n</code></pre> <p>The properties of this class are virtual, meaning in this case they are not real PHP properties. But rather values stored internally that  can be accessed like a property. The same values can be read and written using different names for convience:</p> <pre><code>$vec = new Vec3;\n$vec-&gt;x = 42.0;\n$vec-&gt;y = 42.0;\n$vec-&gt;z = 42.0;\n</code></pre> <p>Is exactly the same as:</p> <pre><code>$vec = new Vec3;\n$vec-&gt;r = 42.0;\n$vec-&gt;g = 42.0;\n$vec-&gt;b = 42.0;\n</code></pre>","location":"API/Math/Vec3.html"},{"title":"Methods","text":"","location":"API/Math/Vec3.html#methods"},{"title":"<code>__construct</code>","text":"<p>Constructor</p> <pre><code>function __construct(?float $x = null, ?float $y = null, ?float $z = null)\n</code></pre>","location":"API/Math/Vec3.html#__construct"},{"title":"<code>normalized</code>","text":"<p>Retruns a normalized version of the given Vec3         * <pre><code>$normalized = Vec3::normalize(new Vec3($x, $y, $z));\n</code></pre></p> <pre><code>static function normalized(\\GL\\Math\\Vec3 $vec) : \\GL\\Math\\Vec3\n</code></pre>  arguments  <ol> <li><code>\\Vec3</code> <code>$vec</code> The vector to normalize.</li> </ol>  returns  <p><code>\\Vec3</code> The normalized vector.</p>","location":"API/Math/Vec3.html#normalized"},{"title":"<code>distance</code>","text":"<p>Returns the distance between the left and right vectors</p> <pre><code>static function distance(\\GL\\Math\\Vec3 $left, \\GL\\Math\\Vec3 $right) : float\n</code></pre> <pre><code>$distance = Vec3::distance($left, $right);\n</code></pre>  arguments  <ol> <li><code>\\Vec3</code> <code>$left</code> The left vector.</li> <li><code>\\Vec3</code> <code>$right</code> The right vector.</li> </ol>  returns  <p><code>float</code> The distance between the left and right vectors.</p>","location":"API/Math/Vec3.html#distance"},{"title":"<code>distance2</code>","text":"<p>Returns the squared distance between the left and right vectors</p> <pre><code>static function distance2(\\GL\\Math\\Vec3 $left, \\GL\\Math\\Vec3 $right) : float\n</code></pre> <pre><code>$distance = Vec3::distance2($left, $right);\n</code></pre>  arguments  <ol> <li><code>\\Vec3</code> <code>$left</code> The left vector.</li> <li><code>\\Vec3</code> <code>$right</code> The right vector.</li> </ol>  returns  <p><code>float</code> The squared distance between the left and right vectors.</p>","location":"API/Math/Vec3.html#distance2"},{"title":"<code>dot</code>","text":"<p>Returns the dot product of the left and right vectors</p> <pre><code>static function dot(\\GL\\Math\\Vec3 $left, \\GL\\Math\\Vec3 $right) : float\n</code></pre> <pre><code>$dot = Vec3::dot($left, $right);\n</code></pre>  arguments  <ol> <li><code>\\Vec3</code> <code>$left</code> The left vector.</li> <li><code>\\Vec3</code> <code>$right</code> The right vector.</li> </ol>  returns  <p><code>float</code> The dot product of the left and right vectors.</p>","location":"API/Math/Vec3.html#dot"},{"title":"<code>mix</code>","text":"<p>Linearly interpolates between the left and right vectors by the given t value.</p> <pre><code>static function mix(\\GL\\Math\\Vec3 $left, \\GL\\Math\\Vec3 $right, float $t) : \\GL\\Math\\Vec3\n</code></pre> <pre><code>$mixed = Vec3::mix($left, $right, $t);\n</code></pre>  arguments  <ol> <li><code>\\Vec3</code> <code>$left</code> The left vector.</li> <li><code>\\Vec3</code> <code>$right</code> The right vector.</li> <li><code>float</code> <code>$t</code> The t value (progress / state) 0.0 == left, 1.0 == right.</li> </ol>  returns  <p><code>\\Vec3</code> The mixed vector.</p>","location":"API/Math/Vec3.html#mix"},{"title":"<code>lerp</code>","text":"<p>Linearly interpolates between the left and right vectors by the given t value.</p> <pre><code>static function lerp(\\GL\\Math\\Vec3 $left, \\GL\\Math\\Vec3 $right, float $t) : \\GL\\Math\\Vec3\n</code></pre> <p>This does exactly the same as mix..</p> <pre><code>$lerped = Vec3::lerp($left, $right, $t);\n</code></pre>  arguments  <ol> <li><code>\\Vec3</code> <code>$left</code> The left vector.</li> <li><code>\\Vec3</code> <code>$right</code> The right vector.</li> <li><code>float</code> <code>$t</code> The t value (progress / state) 0.0 == left, 1.0 == right.</li> </ol>  returns  <p><code>\\Vec3</code> The lerped vector.</p>","location":"API/Math/Vec3.html#lerp"},{"title":"<code>slerp</code>","text":"<p>Spherically interpolates between the left and right vectors by the given t value.</p> <pre><code>static function slerp(\\GL\\Math\\Vec3 $left, \\GL\\Math\\Vec3 $right, float $t) : \\GL\\Math\\Vec3\n</code></pre> <pre><code>$slerped = Vec3::slerp($left, $right, $t);\n</code></pre>  arguments  <ol> <li><code>\\Vec3</code> <code>$left</code> The left vector.</li> <li><code>\\Vec3</code> <code>$right</code> The right vector.</li> <li><code>float</code> <code>$t</code> The t value (progress / state) 0.0 == left, 1.0 == right.</li> </ol>  returns  <p><code>\\Vec3</code> The slerped vector.</p>","location":"API/Math/Vec3.html#slerp"},{"title":"<code>length</code>","text":"<p>Returns the length of the vector</p> <pre><code>function length() : float\n</code></pre>  returns  <p><code>float</code> </p>","location":"API/Math/Vec3.html#length"},{"title":"<code>distanceTo</code>","text":"<p>Returns the distance between this vector and another</p> <pre><code>function distanceTo(\\GL\\Math\\Vec3 $right) : float\n</code></pre>  returns  <p><code>float</code> </p>","location":"API/Math/Vec3.html#distanceto"},{"title":"<code>distance2To</code>","text":"<p>Returns squared distance between this vector and another</p> <pre><code>function distance2To(\\GL\\Math\\Vec3 $right) : float\n</code></pre>  returns  <p><code>float</code> </p>","location":"API/Math/Vec3.html#distance2to"},{"title":"<code>normalize</code>","text":"<p>normalizes the current vector</p> <pre><code>function normalize() : void\n</code></pre>  returns  <p><code>void</code> </p>","location":"API/Math/Vec3.html#normalize"},{"title":"<code>abs</code>","text":"<p>Makes each component x if x &gt;= 0; otherwise, -x</p> <pre><code>function abs() : void\n</code></pre>  returns  <p><code>void</code> </p>","location":"API/Math/Vec3.html#abs"},{"title":"Vec4 - GL Math","text":"<p>PHP-GLFW comes with built in fixed size vector classes. <code>Vec4</code> represents a vector with 4 components ( <code>x</code>, <code>y</code>, <code>z</code>, <code>w</code>, ).</p> <pre><code>namespace GL\\Math\n{\n    class Vec4 {\n        public float $x;\n        public float $y;\n        public float $z;\n        public float $w;\n    }\n}\n</code></pre> <p>The properties of this class are virtual, meaning in this case they are not real PHP properties. But rather values stored internally that  can be accessed like a property. The same values can be read and written using different names for convience:</p> <pre><code>$vec = new Vec4;\n$vec-&gt;x = 42.0;\n$vec-&gt;y = 42.0;\n$vec-&gt;z = 42.0;\n$vec-&gt;w = 42.0;\n</code></pre> <p>Is exactly the same as:</p> <pre><code>$vec = new Vec4;\n$vec-&gt;r = 42.0;\n$vec-&gt;g = 42.0;\n$vec-&gt;b = 42.0;\n$vec-&gt;a = 42.0;\n</code></pre>","location":"API/Math/Vec4.html"},{"title":"Methods","text":"","location":"API/Math/Vec4.html#methods"},{"title":"<code>__construct</code>","text":"<p>Constructor</p> <pre><code>function __construct(?float $x = null, ?float $y = null, ?float $z = null, ?float $w = null)\n</code></pre>","location":"API/Math/Vec4.html#__construct"},{"title":"<code>normalized</code>","text":"<p>Retruns a normalized version of the given Vec4         * <pre><code>$normalized = Vec4::normalize(new Vec4($x, $y, $z));\n</code></pre></p> <pre><code>static function normalized(\\GL\\Math\\Vec4 $vec) : \\GL\\Math\\Vec4\n</code></pre>  arguments  <ol> <li><code>\\Vec4</code> <code>$vec</code> The vector to normalize.</li> </ol>  returns  <p><code>\\Vec4</code> The normalized vector.</p>","location":"API/Math/Vec4.html#normalized"},{"title":"<code>distance</code>","text":"<p>Returns the distance between the left and right vectors</p> <pre><code>static function distance(\\GL\\Math\\Vec4 $left, \\GL\\Math\\Vec4 $right) : float\n</code></pre> <pre><code>$distance = Vec4::distance($left, $right);\n</code></pre>  arguments  <ol> <li><code>\\Vec4</code> <code>$left</code> The left vector.</li> <li><code>\\Vec4</code> <code>$right</code> The right vector.</li> </ol>  returns  <p><code>float</code> The distance between the left and right vectors.</p>","location":"API/Math/Vec4.html#distance"},{"title":"<code>distance2</code>","text":"<p>Returns the squared distance between the left and right vectors</p> <pre><code>static function distance2(\\GL\\Math\\Vec4 $left, \\GL\\Math\\Vec4 $right) : float\n</code></pre> <pre><code>$distance = Vec4::distance2($left, $right);\n</code></pre>  arguments  <ol> <li><code>\\Vec4</code> <code>$left</code> The left vector.</li> <li><code>\\Vec4</code> <code>$right</code> The right vector.</li> </ol>  returns  <p><code>float</code> The squared distance between the left and right vectors.</p>","location":"API/Math/Vec4.html#distance2"},{"title":"<code>dot</code>","text":"<p>Returns the dot product of the left and right vectors</p> <pre><code>static function dot(\\GL\\Math\\Vec4 $left, \\GL\\Math\\Vec4 $right) : float\n</code></pre> <pre><code>$dot = Vec4::dot($left, $right);\n</code></pre>  arguments  <ol> <li><code>\\Vec4</code> <code>$left</code> The left vector.</li> <li><code>\\Vec4</code> <code>$right</code> The right vector.</li> </ol>  returns  <p><code>float</code> The dot product of the left and right vectors.</p>","location":"API/Math/Vec4.html#dot"},{"title":"<code>mix</code>","text":"<p>Linearly interpolates between the left and right vectors by the given t value.</p> <pre><code>static function mix(\\GL\\Math\\Vec4 $left, \\GL\\Math\\Vec4 $right, float $t) : \\GL\\Math\\Vec4\n</code></pre> <pre><code>$mixed = Vec4::mix($left, $right, $t);\n</code></pre>  arguments  <ol> <li><code>\\Vec4</code> <code>$left</code> The left vector.</li> <li><code>\\Vec4</code> <code>$right</code> The right vector.</li> <li><code>float</code> <code>$t</code> The t value (progress / state) 0.0 == left, 1.0 == right.</li> </ol>  returns  <p><code>\\Vec4</code> The mixed vector.</p>","location":"API/Math/Vec4.html#mix"},{"title":"<code>lerp</code>","text":"<p>Linearly interpolates between the left and right vectors by the given t value.</p> <pre><code>static function lerp(\\GL\\Math\\Vec4 $left, \\GL\\Math\\Vec4 $right, float $t) : \\GL\\Math\\Vec4\n</code></pre> <p>This does exactly the same as mix..</p> <pre><code>$lerped = Vec4::lerp($left, $right, $t);\n</code></pre>  arguments  <ol> <li><code>\\Vec4</code> <code>$left</code> The left vector.</li> <li><code>\\Vec4</code> <code>$right</code> The right vector.</li> <li><code>float</code> <code>$t</code> The t value (progress / state) 0.0 == left, 1.0 == right.</li> </ol>  returns  <p><code>\\Vec4</code> The lerped vector.</p>","location":"API/Math/Vec4.html#lerp"},{"title":"<code>slerp</code>","text":"<p>Spherically interpolates between the left and right vectors by the given t value.</p> <pre><code>static function slerp(\\GL\\Math\\Vec4 $left, \\GL\\Math\\Vec4 $right, float $t) : \\GL\\Math\\Vec4\n</code></pre> <pre><code>$slerped = Vec4::slerp($left, $right, $t);\n</code></pre>  arguments  <ol> <li><code>\\Vec4</code> <code>$left</code> The left vector.</li> <li><code>\\Vec4</code> <code>$right</code> The right vector.</li> <li><code>float</code> <code>$t</code> The t value (progress / state) 0.0 == left, 1.0 == right.</li> </ol>  returns  <p><code>\\Vec4</code> The slerped vector.</p>","location":"API/Math/Vec4.html#slerp"},{"title":"<code>length</code>","text":"<p>Returns the length of the vector</p> <pre><code>function length() : float\n</code></pre>  returns  <p><code>float</code> </p>","location":"API/Math/Vec4.html#length"},{"title":"<code>distanceTo</code>","text":"<p>Returns the distance between this vector and another</p> <pre><code>function distanceTo(\\GL\\Math\\Vec4 $right) : float\n</code></pre>  returns  <p><code>float</code> </p>","location":"API/Math/Vec4.html#distanceto"},{"title":"<code>distance2To</code>","text":"<p>Returns squared distance between this vector and another</p> <pre><code>function distance2To(\\GL\\Math\\Vec4 $right) : float\n</code></pre>  returns  <p><code>float</code> </p>","location":"API/Math/Vec4.html#distance2to"},{"title":"<code>normalize</code>","text":"<p>normalizes the current vector</p> <pre><code>function normalize() : void\n</code></pre>  returns  <p><code>void</code> </p>","location":"API/Math/Vec4.html#normalize"},{"title":"<code>abs</code>","text":"<p>Makes each component x if x &gt;= 0; otherwise, -x</p> <pre><code>function abs() : void\n</code></pre>  returns  <p><code>void</code> </p>","location":"API/Math/Vec4.html#abs"},{"title":"glActiveShaderProgram","text":"<p>The <code>glActiveShaderProgram</code> function is used to set the active program object for a program pipeline object. This function takes two integer arguments <code>$pipeline</code> and <code>$program</code>. The pipeline parameter specifies the program pipeline object, and the program parameter specifies the linked program to be the active program.</p> <pre><code>function glActiveShaderProgram(int $pipeline, int $program) : void\n</code></pre> <p>Here is an example usage of <code>glActiveShaderProgram</code>:</p> <pre><code>$program = glCreateProgram();\nglAttachShader($program, $vertexShader);\nglAttachShader($program, $fragmentShader);\nglLinkProgram($program);\n\n$pipeline = glGenProgramPipelines();\nglUseProgramStages($pipeline, GL_VERTEX_SHADER_BIT, $program);\nglActiveShaderProgram($pipeline, $program);\n</code></pre> <p>Note that before calling <code>glActiveShaderProgram</code>, you should first create a program object, attach shaders to it, link the program, and then create a program pipeline object with <code>glGenProgramPipelines</code>. Also, make sure that the program object referred to by <code>$program</code> has been successfully linked. If not, <code>GL_INVALID_OPERATION</code> will be generated.</p>  arguments  <ol> <li><code>int</code> <code>$pipeline</code> Specifies the program pipeline object to set the active program object for.</li> <li><code>int</code> <code>$program</code> Specifies the program object to set as the active program pipeline object pipeline.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glActiveShaderProgram.html"},{"title":"glActiveTexture","text":"<p>The <code>glActiveTexture</code> function is used in OpenGL to select an active texture unit. This function takes an integer argument <code>$texture</code>, which specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least 80. The parameter <code>$texture</code> must be one of <code>GL_TEXTUREi</code>, where <code>i</code> ranges from zero to the value of <code>GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</code> minus one. The initial value is <code>GL_TEXTURE0</code>.</p> <pre><code>function glActiveTexture(int $texture) : void\n</code></pre> <p>Here is an example usage of <code>glActiveTexture</code>:</p> <pre><code>glActiveTexture(GL_TEXTURE0); // Make texture unit 0 active\nglActiveTexture(GL_TEXTURE1); // Make texture unit 1 active\n</code></pre> <p>Note that you should always check the value of <code>GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</code> to ensure that your program is compatible with the current OpenGL implementation.</p>  arguments  <ol> <li><code>int</code> <code>$texture</code> Specifies which texture unit to make active. The number of texture units is implementation dependent, but must be at least 80. texture must be one of GL_TEXTUREi, where i ranges from zero to the value of GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS minus one. The initial value is GL_TEXTURE0.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glActiveTexture.html"},{"title":"glAttachShader","text":"<p>Attaches a shader object to a program object</p> <pre><code>function glAttachShader(int $program, int $shader) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> Specifies the program object to which a shader object will be attached.</li> <li><code>int</code> <code>$shader</code> Specifies the shader object that is to be attached.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glAttachShader.html"},{"title":"glBeginConditionalRender","text":"<p>start conditional rendering</p> <pre><code>function glBeginConditionalRender(int $id, int $mode) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$id</code> Specifies the name of an occlusion query object whose results are used to determine if the rendering commands are discarded.</li> <li><code>int</code> <code>$mode</code> Specifies how glBeginConditionalRender interprets the results of the occlusion query.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBeginConditionalRender.html"},{"title":"glBeginQuery","text":"<p>delimit the boundaries of a query object</p> <pre><code>function glBeginQuery(int $target, int $id) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies the target type of query object established between glBeginQuery and the subsequent  glEndQuery. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED.</li> <li><code>int</code> <code>$id</code> Specifies the name of a query object.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBeginQuery.html"},{"title":"glBeginQueryIndexed","text":"<p>glBeginQueryIndexed</p> <pre><code>function glBeginQueryIndexed(int $target, int $index, int $id) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$id</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBeginQueryIndexed.html"},{"title":"glBeginTransformFeedback","text":"<p>start transform feedback operation</p> <pre><code>function glBeginTransformFeedback(int $primitiveMode) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$primitiveMode</code> Specify the output type of the primitives that will be recorded into the buffer objects that are bound for transform feedback.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBeginTransformFeedback.html"},{"title":"glBindAttribLocation","text":"<p>Associates a generic vertex attribute index with a named attribute variable</p> <pre><code>function glBindAttribLocation(int $program, int $index, string $name) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> Specifies the handle of the program object in which the association is to be made.</li> <li><code>int</code> <code>$index</code> Specifies the index of the generic vertex attribute to be bound.</li> <li><code>string</code> <code>$name</code> Specifies a null terminated string containing the name of the vertex shader attribute variable to which index is to be bound.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBindAttribLocation.html"},{"title":"glBindBuffer","text":"<p>bind a named buffer object</p> <pre><code>function glBindBuffer(int $target, int $buffer) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies the target to which the buffer object is bound, which must be one of the buffer binding targets in the following table:</li> <li><code>int</code> <code>$buffer</code> Specifies the name of a buffer object.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBindBuffer.html"},{"title":"glBindBufferBase","text":"<p>bind a buffer object to an indexed buffer target</p> <pre><code>function glBindBufferBase(int $target, int $index, int $buffer) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER.</li> <li><code>int</code> <code>$index</code> Specify the index of the binding point within the array specified by target.</li> <li><code>int</code> <code>$buffer</code> The name of a buffer object to bind to the specified binding point.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBindBufferBase.html"},{"title":"glBindBufferRange","text":"<p>bind a range within a buffer object to an indexed buffer target</p> <pre><code>function glBindBufferRange(int $target, int $index, int $buffer, int $offset, int $size) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER, or GL_SHADER_STORAGE_BUFFER.</li> <li><code>int</code> <code>$index</code> Specify the index of the binding point within the array specified by target.</li> <li><code>int</code> <code>$buffer</code> The name of a buffer object to bind to the specified binding point.</li> <li><code>int</code> <code>$offset</code> The starting offset in basic machine units into the buffer object buffer.</li> <li><code>int</code> <code>$size</code> The amount of data in machine units that can be read from the buffer object while used as an indexed target.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBindBufferRange.html"},{"title":"glBindFragDataLocation","text":"<p>bind a user-defined varying out variable to a fragment shader color number</p> <pre><code>function glBindFragDataLocation(int $program, int $color, string $name) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> The name of the program containing varying out variable whose binding to modify</li> <li><code>int</code> <code>$color</code> </li> <li><code>string</code> <code>$name</code> The name of the user-defined varying out variable whose binding to modify</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBindFragDataLocation.html"},{"title":"glBindFragDataLocationIndexed","text":"<p>bind a user-defined varying out variable to a fragment shader color number and index</p> <pre><code>function glBindFragDataLocationIndexed(int $program, int $colorNumber, int $index, string $name) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> The name of the program containing varying out variable whose binding to modify</li> <li><code>int</code> <code>$colorNumber</code> The color number to bind the user-defined varying out variable to</li> <li><code>int</code> <code>$index</code> The index of the color input to bind the user-defined varying out variable to</li> <li><code>string</code> <code>$name</code> The name of the user-defined varying out variable whose binding to modify</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBindFragDataLocationIndexed.html"},{"title":"glBindFramebuffer","text":"<p>bind a framebuffer to a framebuffer target</p> <pre><code>function glBindFramebuffer(int $target, int $framebuffer) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies the framebuffer target of the binding operation.</li> <li><code>int</code> <code>$framebuffer</code> Specifies the name of the framebuffer object to bind.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBindFramebuffer.html"},{"title":"glBindProgramPipeline","text":"<p>bind a program pipeline to the current context</p> <pre><code>function glBindProgramPipeline(int $pipeline) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$pipeline</code> Specifies the name of the pipeline object to bind to the context.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBindProgramPipeline.html"},{"title":"glBindRenderbuffer","text":"<p>bind a renderbuffer to a renderbuffer target</p> <pre><code>function glBindRenderbuffer(int $target, int $renderbuffer) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies the renderbuffer target of the binding operation. target must be GL_RENDERBUFFER.</li> <li><code>int</code> <code>$renderbuffer</code> Specifies the name of the renderbuffer object to bind.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBindRenderbuffer.html"},{"title":"glBindSampler","text":"<p>bind a named sampler to a texturing target</p> <pre><code>function glBindSampler(int $unit, int $sampler) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$unit</code> Specifies the index of the texture unit to which the sampler is bound.</li> <li><code>int</code> <code>$sampler</code> Specifies the name of a sampler.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBindSampler.html"},{"title":"glBindTexture","text":"<p>bind a named texture to a texturing target</p> <pre><code>function glBindTexture(int $target, int $texture) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies the target to which the texture is bound. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY.</li> <li><code>int</code> <code>$texture</code> Specifies the name of a texture.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBindTexture.html"},{"title":"glBindTransformFeedback","text":"<p>bind a transform feedback object</p> <pre><code>function glBindTransformFeedback(int $target, int $id) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies the target to which to bind the transform feedback object id. target must be GL_TRANSFORM_FEEDBACK.</li> <li><code>int</code> <code>$id</code> Specifies the name of a transform feedback object reserved by glGenTransformFeedbacks.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBindTransformFeedback.html"},{"title":"glBindVertexArray","text":"<p>bind a vertex array object</p> <pre><code>function glBindVertexArray(int $array) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$array</code> Specifies the name of the vertex array to bind.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBindVertexArray.html"},{"title":"glBlendColor","text":"<p>set the blend color</p> <pre><code>function glBlendColor(float $red, float $green, float $blue, float $alpha) : void\n</code></pre>  arguments  <ol> <li><code>float</code> <code>$red</code> specify the components of GL_BLEND_COLOR</li> <li><code>float</code> <code>$green</code> </li> <li><code>float</code> <code>$blue</code> </li> <li><code>float</code> <code>$alpha</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBlendColor.html"},{"title":"glBlendEquation","text":"<p>specify the equation used for both the RGB blend equation and the Alpha blend equation</p> <pre><code>function glBlendEquation(int $mode) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$mode</code> specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBlendEquation.html"},{"title":"glBlendEquationSeparate","text":"<p>set the RGB blend equation and the alpha blend equation separately</p> <pre><code>function glBlendEquationSeparate(int $modeRGB, int $modeAlpha) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$modeRGB</code> specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.</li> <li><code>int</code> <code>$modeAlpha</code> specifies the alpha blend equation, how the alpha component of the source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBlendEquationSeparate.html"},{"title":"glBlendEquationSeparatei","text":"<p>glBlendEquationSeparatei</p> <pre><code>function glBlendEquationSeparatei(int $buf, int $modeRGB, int $modeAlpha) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$buf</code> </li> <li><code>int</code> <code>$modeRGB</code> </li> <li><code>int</code> <code>$modeAlpha</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBlendEquationSeparatei.html"},{"title":"glBlendEquationi","text":"<p>glBlendEquationi</p> <pre><code>function glBlendEquationi(int $buf, int $mode) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$buf</code> </li> <li><code>int</code> <code>$mode</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBlendEquationi.html"},{"title":"glBlendFunc","text":"<p>specify pixel arithmetic</p> <pre><code>function glBlendFunc(int $sfactor, int $dfactor) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$sfactor</code> Specifies how the red, green, blue, and alpha source blending factors are computed. The initial value is GL_ONE.</li> <li><code>int</code> <code>$dfactor</code> Specifies how the red, green, blue, and alpha destination blending factors are computed. The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBlendFunc.html"},{"title":"glBlendFuncSeparate","text":"<p>specify pixel arithmetic for RGB and alpha components separately</p> <pre><code>function glBlendFuncSeparate(int $sfactorRGB, int $dfactorRGB, int $sfactorAlpha, int $dfactorAlpha) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$sfactorRGB</code> </li> <li><code>int</code> <code>$dfactorRGB</code> </li> <li><code>int</code> <code>$sfactorAlpha</code> </li> <li><code>int</code> <code>$dfactorAlpha</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBlendFuncSeparate.html"},{"title":"glBlendFuncSeparatei","text":"<p>glBlendFuncSeparatei</p> <pre><code>function glBlendFuncSeparatei(int $buf, int $srcRGB, int $dstRGB, int $srcAlpha, int $dstAlpha) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$buf</code> </li> <li><code>int</code> <code>$srcRGB</code> </li> <li><code>int</code> <code>$dstRGB</code> </li> <li><code>int</code> <code>$srcAlpha</code> </li> <li><code>int</code> <code>$dstAlpha</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBlendFuncSeparatei.html"},{"title":"glBlendFunci","text":"<p>glBlendFunci</p> <pre><code>function glBlendFunci(int $buf, int $src, int $dst) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$buf</code> </li> <li><code>int</code> <code>$src</code> </li> <li><code>int</code> <code>$dst</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBlendFunci.html"},{"title":"glBlitFramebuffer","text":"<p>copy a block of pixels from one framebuffer object to another</p> <pre><code>function glBlitFramebuffer(int $srcX0, int $srcY0, int $srcX1, int $srcY1, int $dstX0, int $dstY0, int $dstX1, int $dstY1, int $mask, int $filter) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$srcX0</code> Specify the bounds of the source rectangle within the read buffer of the read framebuffer.</li> <li><code>int</code> <code>$srcY0</code> </li> <li><code>int</code> <code>$srcX1</code> </li> <li><code>int</code> <code>$srcY1</code> </li> <li><code>int</code> <code>$dstX0</code> Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.</li> <li><code>int</code> <code>$dstY0</code> </li> <li><code>int</code> <code>$dstX1</code> </li> <li><code>int</code> <code>$dstY1</code> </li> <li><code>int</code> <code>$mask</code> The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT.</li> <li><code>int</code> <code>$filter</code> Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or GL_LINEAR.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBlitFramebuffer.html"},{"title":"glBufferData","text":"<p>creates and initializes a buffer object's data store</p> <pre><code>function glBufferData(int $target, \\GL\\Buffer\\BufferInterface $buffer, int $usage) : void\n</code></pre>  <p>PHP-GLFW Note</p> <p>In the PHP extension this method has different signiture compared to the original. Instead of passing byte size and a pointer to the function, in PHP you pass a <code>GL\\Buffer\\BufferInterface</code> instance.</p>  <p>Example: <pre><code>$buffer = new GL\\Buffer\\FloatBuffer([\n    // positions     // colors\n    0.5, -0.5, 0.0,  1.0, 0.0, 0.0,  // bottom right\n   -0.5, -0.5, 0.0,  0.0, 1.0, 0.0,  // bottom let\n    0.0,  0.5, 0.0,  0.0, 0.0, 1.0   // top\n]);\n\nglGenVertexArrays(1, $VAO);\nglGenBuffers(1, $VBO);\nglBindVertexArray($VAO);\nglBindBuffer(GL_ARRAY_BUFFER, $VBO);\nglBufferData(GL_ARRAY_BUFFER, $buffer, GL_STATIC_DRAW);\n</code></pre></p>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies the target to which the buffer object is bound for glBufferData.</li> <li><code>\\GL\\Buffer\\BufferInterface</code> <code>$buffer</code> Specifies a buffer object containing the to be uploaded data.</li> <li><code>int</code> <code>$usage</code> Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glBufferData.html"},{"title":"glCheckFramebufferStatus","text":"<p>check the completeness status of a framebuffer</p> <pre><code>function glCheckFramebufferStatus(int $target) : int\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus.</li> </ol>  returns  <p><code>int</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glCheckFramebufferStatus.html"},{"title":"glClampColor","text":"<p>specify whether data read via glReadPixels should be clamped</p> <pre><code>function glClampColor(int $target, int $clamp) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Target for color clamping. target must be GL_CLAMP_READ_COLOR.</li> <li><code>int</code> <code>$clamp</code> Specifies whether to apply color clamping. clamp must be GL_TRUE or GL_FALSE.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glClampColor.html"},{"title":"glClear","text":"<p>clear buffers to preset values</p> <pre><code>function glClear(int $mask) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$mask</code> Bitwise OR of masks that indicate the buffers to be cleared. The three masks are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glClear.html"},{"title":"glClearBufferfi","text":"<p>glClearBufferfi</p> <pre><code>function glClearBufferfi(int $buffer, int $drawbuffer, float $depth, int $stencil) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$buffer</code> </li> <li><code>int</code> <code>$drawbuffer</code> </li> <li><code>float</code> <code>$depth</code> </li> <li><code>int</code> <code>$stencil</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glClearBufferfi.html"},{"title":"glClearBufferfv","text":"<p>glClearBufferfv</p> <pre><code>function glClearBufferfv(int $buffer, int $drawbuffer, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$buffer</code> </li> <li><code>int</code> <code>$drawbuffer</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glClearBufferfv.html"},{"title":"glClearBufferiv","text":"<p>glClearBufferiv</p> <pre><code>function glClearBufferiv(int $buffer, int $drawbuffer, \\GL\\Buffer\\IntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$buffer</code> </li> <li><code>int</code> <code>$drawbuffer</code> </li> <li><code>\\GL\\Buffer\\IntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glClearBufferiv.html"},{"title":"glClearBufferuiv","text":"<p>glClearBufferuiv</p> <pre><code>function glClearBufferuiv(int $buffer, int $drawbuffer, \\GL\\Buffer\\UIntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$buffer</code> </li> <li><code>int</code> <code>$drawbuffer</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glClearBufferuiv.html"},{"title":"glClearColor","text":"<p>specify clear values for the color buffers</p> <pre><code>function glClearColor(float $red, float $green, float $blue, float $alpha) : void\n</code></pre>  arguments  <ol> <li><code>float</code> <code>$red</code> Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial values are all 0.</li> <li><code>float</code> <code>$green</code> </li> <li><code>float</code> <code>$blue</code> </li> <li><code>float</code> <code>$alpha</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glClearColor.html"},{"title":"glClearDepth","text":"<p>specify the clear value for the depth buffer</p> <pre><code>function glClearDepth(float $depth) : void\n</code></pre>  arguments  <ol> <li><code>float</code> <code>$depth</code> Specifies the depth value used when the depth buffer is cleared. The initial value is 1.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glClearDepth.html"},{"title":"glClearDepthf","text":"<p>glClearDepthf</p> <pre><code>function glClearDepthf(float $d) : void\n</code></pre>  arguments  <ol> <li><code>float</code> <code>$d</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glClearDepthf.html"},{"title":"glClearStencil","text":"<p>specify the clear value for the stencil buffer</p> <pre><code>function glClearStencil(int $s) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$s</code> Specifies the index used when the stencil buffer is cleared. The initial value is 0.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glClearStencil.html"},{"title":"glClientWaitSync","text":"<p>block and wait for a sync object to become signaled</p> <pre><code>function glClientWaitSync(int $sync, int $flags, int $timeout) : int\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$sync</code> The sync object whose status to wait on.</li> <li><code>int</code> <code>$flags</code> A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT.</li> <li><code>int</code> <code>$timeout</code> The timeout, specified in nanoseconds, for which the implementation should wait for sync to become signaled.</li> </ol>  returns  <p><code>int</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glClientWaitSync.html"},{"title":"glColorMask","text":"<p>enable and disable writing of frame buffer color components</p> <pre><code>function glColorMask(bool $red, bool $green, bool $blue, bool $alpha) : void\n</code></pre>  arguments  <ol> <li><code>bool</code> <code>$red</code> Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial values are all GL_TRUE, indicating that the color components are written.</li> <li><code>bool</code> <code>$green</code> </li> <li><code>bool</code> <code>$blue</code> </li> <li><code>bool</code> <code>$alpha</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glColorMask.html"},{"title":"glColorMaski","text":"<p>glColorMaski</p> <pre><code>function glColorMaski(int $index, bool $r, bool $g, bool $b, bool $a) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>bool</code> <code>$r</code> </li> <li><code>bool</code> <code>$g</code> </li> <li><code>bool</code> <code>$b</code> </li> <li><code>bool</code> <code>$a</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glColorMaski.html"},{"title":"glColorP3ui","text":"<p>glColorP3ui</p> <pre><code>function glColorP3ui(int $type, int $color) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$type</code> </li> <li><code>int</code> <code>$color</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glColorP3ui.html"},{"title":"glColorP3uiv","text":"<p>glColorP3uiv</p> <pre><code>function glColorP3uiv(int $type, \\GL\\Buffer\\UIntBuffer|array $color) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$type</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$color</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glColorP3uiv.html"},{"title":"glColorP4ui","text":"<p>glColorP4ui</p> <pre><code>function glColorP4ui(int $type, int $color) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$type</code> </li> <li><code>int</code> <code>$color</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glColorP4ui.html"},{"title":"glColorP4uiv","text":"<p>glColorP4uiv</p> <pre><code>function glColorP4uiv(int $type, \\GL\\Buffer\\UIntBuffer|array $color) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$type</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$color</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glColorP4uiv.html"},{"title":"glCompileShader","text":"<p>Compiles a shader object</p> <pre><code>function glCompileShader(int $shader) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$shader</code> Specifies the shader object to be compiled.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glCompileShader.html"},{"title":"glCopyBufferSubData","text":"<p>copy all or part of the data store of a buffer object to the data store of another buffer object</p> <pre><code>function glCopyBufferSubData(int $readTarget, int $writeTarget, int $readOffset, int $writeOffset, int $size) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$readTarget</code> Specifies the target to which the source buffer object is bound for glCopyBufferSubData</li> <li><code>int</code> <code>$writeTarget</code> Specifies the target to which the destination buffer object is bound for glCopyBufferSubData.</li> <li><code>int</code> <code>$readOffset</code> Specifies the offset, in basic machine units, within the data store of the source buffer object at which data will be read.</li> <li><code>int</code> <code>$writeOffset</code> Specifies the offset, in basic machine units, within the data store of the destination buffer object at which data will be written.</li> <li><code>int</code> <code>$size</code> Specifies the size, in basic machine units, of the data to be copied from the source buffer object to the destination buffer object.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glCopyBufferSubData.html"},{"title":"glCopyTexImage1D","text":"<p>copy pixels into a 1D texture image</p> <pre><code>function glCopyTexImage1D(int $target, int $level, int $internalformat, int $x, int $y, int $width, int $border) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies the target texture. Must be GL_TEXTURE_1D.</li> <li><code>int</code> <code>$level</code> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</li> <li><code>int</code> <code>$internalformat</code> Specifies the internal format of the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA. GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_STENCIL_INDEX8, GL_RED, GL_RG, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.</li> <li><code>int</code> <code>$x</code> Specify the window coordinates of the left corner of the row of pixels to be copied.</li> <li><code>int</code> <code>$y</code> </li> <li><code>int</code> <code>$width</code> Specifies the width of the texture image. The height of the texture image is 1.</li> <li><code>int</code> <code>$border</code> Must be 0.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glCopyTexImage1D.html"},{"title":"glCopyTexImage2D","text":"<p>copy pixels into a 2D texture image</p> <pre><code>function glCopyTexImage2D(int $target, int $level, int $internalformat, int $x, int $y, int $width, int $height, int $border) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.</li> <li><code>int</code> <code>$level</code> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</li> <li><code>int</code> <code>$internalformat</code> Specifies the internal format of the texture. Must be one of the following symbolic constants: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, GL_COMPRESSED_SRGB_ALPHA. GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT32, GL_STENCIL_INDEX8, GL_RED, GL_RG, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.</li> <li><code>int</code> <code>$x</code> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</li> <li><code>int</code> <code>$y</code> </li> <li><code>int</code> <code>$width</code> Specifies the width of the texture image.</li> <li><code>int</code> <code>$height</code> Specifies the height of the texture image.</li> <li><code>int</code> <code>$border</code> Must be 0.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glCopyTexImage2D.html"},{"title":"glCopyTexSubImage1D","text":"<p>copy a one-dimensional texture subimage</p> <pre><code>function glCopyTexSubImage1D(int $target, int $level, int $xoffset, int $x, int $y, int $width) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies the target to which the texture object is bound for glCopyTexSubImage1D function. Must be GL_TEXTURE_1D.</li> <li><code>int</code> <code>$level</code> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</li> <li><code>int</code> <code>$xoffset</code> Specifies the texel offset within the texture array.</li> <li><code>int</code> <code>$x</code> Specify the window coordinates of the left corner of the row of pixels to be copied.</li> <li><code>int</code> <code>$y</code> </li> <li><code>int</code> <code>$width</code> Specifies the width of the texture subimage.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glCopyTexSubImage1D.html"},{"title":"glCopyTexSubImage2D","text":"<p>copy a two-dimensional texture subimage</p> <pre><code>function glCopyTexSubImage2D(int $target, int $level, int $xoffset, int $yoffset, int $x, int $y, int $width, int $height) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies the target to which the texture object is bound for glCopyTexSubImage2D function. Must be GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_RECTANGLE.</li> <li><code>int</code> <code>$level</code> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</li> <li><code>int</code> <code>$xoffset</code> Specifies a texel offset in the x direction within the texture array.</li> <li><code>int</code> <code>$yoffset</code> Specifies a texel offset in the y direction within the texture array.</li> <li><code>int</code> <code>$x</code> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</li> <li><code>int</code> <code>$y</code> </li> <li><code>int</code> <code>$width</code> Specifies the width of the texture subimage.</li> <li><code>int</code> <code>$height</code> Specifies the height of the texture subimage.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glCopyTexSubImage2D.html"},{"title":"glCopyTexSubImage3D","text":"<p>copy a three-dimensional texture subimage</p> <pre><code>function glCopyTexSubImage3D(int $target, int $level, int $xoffset, int $yoffset, int $zoffset, int $x, int $y, int $width, int $height) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies the target to which the texture object is bound for glCopyTexSubImage3D function. Must be GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or GL_TEXTURE_CUBE_MAP_ARRAY.</li> <li><code>int</code> <code>$level</code> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.</li> <li><code>int</code> <code>$xoffset</code> Specifies a texel offset in the x direction within the texture array.</li> <li><code>int</code> <code>$yoffset</code> Specifies a texel offset in the y direction within the texture array.</li> <li><code>int</code> <code>$zoffset</code> Specifies a texel offset in the z direction within the texture array.</li> <li><code>int</code> <code>$x</code> Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.</li> <li><code>int</code> <code>$y</code> </li> <li><code>int</code> <code>$width</code> Specifies the width of the texture subimage.</li> <li><code>int</code> <code>$height</code> Specifies the height of the texture subimage.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glCopyTexSubImage3D.html"},{"title":"glCreateProgram","text":"<p>Creates a program object</p> <pre><code>function glCreateProgram() : int\n</code></pre>  returns  <p><code>int</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glCreateProgram.html"},{"title":"glCreateShader","text":"<p>Creates a shader object</p> <pre><code>function glCreateShader(int $type) : int\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$type</code> </li> </ol>  returns  <p><code>int</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glCreateShader.html"},{"title":"glCullFace","text":"","location":"API/OpenGL/glCullFace.html"},{"title":"Functions","text":"<pre><code>function glCullFace(int $mode) : void\n</code></pre>   <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glCullFace.html#functions"},{"title":"glDeleteBuffers","text":"<p>delete named buffer objects</p> <pre><code>function glDeleteBuffers(int $n, ?int ...$buffers) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$n</code> Specifies the number of buffer objects to be deleted.</li> <li><code>?int</code> <code>$buffers</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDeleteBuffers.html"},{"title":"glDeleteFramebuffers","text":"<p>delete framebuffer objects</p> <pre><code>function glDeleteFramebuffers(int $n, ?int ...$framebuffers) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$n</code> Specifies the number of framebuffer objects to be deleted.</li> <li><code>?int</code> <code>$framebuffers</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDeleteFramebuffers.html"},{"title":"glDeleteProgram","text":"<p>Deletes a program object</p> <pre><code>function glDeleteProgram(int $program) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> Specifies the program object to be deleted.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDeleteProgram.html"},{"title":"glDeleteProgramPipelines","text":"<p>delete program pipeline objects</p> <pre><code>function glDeleteProgramPipelines(int $n, ?int ...$pipelines) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$n</code> Specifies the number of program pipeline objects to delete.</li> <li><code>?int</code> <code>$pipelines</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDeleteProgramPipelines.html"},{"title":"glDeleteQueries","text":"<p>delete named query objects</p> <pre><code>function glDeleteQueries(int $n, ?int ...$ids) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$n</code> Specifies the number of query objects to be deleted.</li> <li><code>?int</code> <code>$ids</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDeleteQueries.html"},{"title":"glDeleteRenderbuffers","text":"<p>delete renderbuffer objects</p> <pre><code>function glDeleteRenderbuffers(int $n, ?int ...$renderbuffers) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$n</code> Specifies the number of renderbuffer objects to be deleted.</li> <li><code>?int</code> <code>$renderbuffers</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDeleteRenderbuffers.html"},{"title":"glDeleteSamplers","text":"<p>delete named sampler objects</p> <pre><code>function glDeleteSamplers(int $count, ?int ...$samplers) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$count</code> </li> <li><code>?int</code> <code>$samplers</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDeleteSamplers.html"},{"title":"glDeleteShader","text":"<p>Deletes a shader object</p> <pre><code>function glDeleteShader(int $shader) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$shader</code> Specifies the shader object to be deleted.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDeleteShader.html"},{"title":"glDeleteSync","text":"<p>delete a sync object</p> <pre><code>function glDeleteSync(int $sync) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$sync</code> The sync object to be deleted.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDeleteSync.html"},{"title":"glDeleteTextures","text":"<p>delete named textures</p> <pre><code>function glDeleteTextures(int $n, ?int ...$textures) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$n</code> Specifies the number of textures to be deleted.</li> <li><code>?int</code> <code>$textures</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDeleteTextures.html"},{"title":"glDeleteTransformFeedbacks","text":"<p>delete transform feedback objects</p> <pre><code>function glDeleteTransformFeedbacks(int $n, ?int ...$ids) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$n</code> Specifies the number of transform feedback objects to delete.</li> <li><code>?int</code> <code>$ids</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDeleteTransformFeedbacks.html"},{"title":"glDeleteVertexArrays","text":"<p>delete vertex array objects</p> <pre><code>function glDeleteVertexArrays(int $n, ?int ...$arrays) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$n</code> Specifies the number of vertex array objects to be deleted.</li> <li><code>?int</code> <code>$arrays</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDeleteVertexArrays.html"},{"title":"glDepthFunc","text":"<p>specify the value used for depth buffer comparisons</p> <pre><code>function glDepthFunc(int $func) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$func</code> Specifies the depth comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted. The initial value is GL_LESS.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDepthFunc.html"},{"title":"glDepthMask","text":"<p>enable or disable writing into the depth buffer</p> <pre><code>function glDepthMask(bool $flag) : void\n</code></pre>  arguments  <ol> <li><code>bool</code> <code>$flag</code> Specifies whether the depth buffer is enabled for writing. If flag is GL_FALSE, depth buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDepthMask.html"},{"title":"glDepthRange","text":"<p>specify mapping of depth values from normalized device coordinates to window coordinates</p> <pre><code>function glDepthRange(float $n, float $f) : void\n</code></pre>  arguments  <ol> <li><code>float</code> <code>$n</code> </li> <li><code>float</code> <code>$f</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDepthRange.html"},{"title":"glDepthRangeArrayv","text":"<p>glDepthRangeArrayv</p> <pre><code>function glDepthRangeArrayv(int $first, \\GL\\Buffer\\DoubleBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$first</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDepthRangeArrayv.html"},{"title":"glDepthRangeIndexed","text":"<p>specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport</p> <pre><code>function glDepthRangeIndexed(int $index, float $n, float $f) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> Specifies the index of the viewport whose depth range to update.</li> <li><code>float</code> <code>$n</code> </li> <li><code>float</code> <code>$f</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDepthRangeIndexed.html"},{"title":"glDepthRangef","text":"<p>glDepthRangef</p> <pre><code>function glDepthRangef(float $n, float $f) : void\n</code></pre>  arguments  <ol> <li><code>float</code> <code>$n</code> </li> <li><code>float</code> <code>$f</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDepthRangef.html"},{"title":"glDetachShader","text":"<p>Detaches a shader object from a program object to which it is attached</p> <pre><code>function glDetachShader(int $program, int $shader) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> Specifies the program object from which to detach the shader object.</li> <li><code>int</code> <code>$shader</code> Specifies the shader object to be detached.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDetachShader.html"},{"title":"glDisable","text":"<p>glDisable</p> <pre><code>function glDisable(int $cap) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$cap</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDisable.html"},{"title":"glDisableVertexAttribArray","text":"<p>glDisableVertexAttribArray</p> <pre><code>function glDisableVertexAttribArray(int $index) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDisableVertexAttribArray.html"},{"title":"glDisablei","text":"<p>glDisablei</p> <pre><code>function glDisablei(int $target, int $index) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$index</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDisablei.html"},{"title":"glDrawArrays","text":"<p>render primitives from array data</p> <pre><code>function glDrawArrays(int $mode, int $first, int $count) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$mode</code> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.</li> <li><code>int</code> <code>$first</code> Specifies the starting index in the enabled arrays.</li> <li><code>int</code> <code>$count</code> Specifies the number of indices to be rendered.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDrawArrays.html"},{"title":"glDrawArraysInstanced","text":"<p>draw multiple instances of a range of elements</p> <pre><code>function glDrawArraysInstanced(int $mode, int $first, int $count, int $instancecount) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$mode</code> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY, GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are accepted.</li> <li><code>int</code> <code>$first</code> Specifies the starting index in the enabled arrays.</li> <li><code>int</code> <code>$count</code> Specifies the number of indices to be rendered.</li> <li><code>int</code> <code>$instancecount</code> Specifies the number of instances of the specified range of indices to be rendered.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDrawArraysInstanced.html"},{"title":"glDrawBuffer","text":"<p>specify which color buffers are to be drawn into</p> <pre><code>function glDrawBuffer(int $buf) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$buf</code> For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic constants GL_NONE, GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and GL_FRONT_AND_BACK are accepted. The initial value is GL_FRONT for single-buffered contexts, and GL_BACK for double-buffered contexts. For framebuffer objects, GL_COLOR_ATTACHMENT$m$ and GL_NONE enums are accepted, where $m$ is a value between 0 and GL_MAX_COLOR_ATTACHMENTS.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDrawBuffer.html"},{"title":"glDrawBuffers","text":"<p>Specifies a list of color buffers to be drawn     into</p> <pre><code>function glDrawBuffers(int $n, ?int ...$bufs) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$n</code> Specifies the number of buffers in bufs.</li> <li><code>?int</code> <code>$bufs</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDrawBuffers.html"},{"title":"glDrawElements","text":"<p>render primitives from array data using element indices</p> <pre><code>function glDrawElements(int $mode, int $count, int $type, int|\\GL\\Buffer\\UIntBuffer|\\GL\\Buffer\\UShortBuffer|\\GL\\Buffer\\UByteBuffer $indices) : void\n</code></pre>  <p>PHP-GLFW Note</p> <p>In the PHP extension this method supports both buffer objects and integer offsets. When using an Element Array Buffer (bound to GL_ELEMENT_ARRAY_BUFFER), pass an integer offset. When drawing without binding an element buffer, pass a UIntBuffer, UShortBuffer, or UByteBuffer containing the indices.</p>  <p>Example: <pre><code>// define vertices for a rectangle using two triangles\n$vertices = new GL\\Buffer\\FloatBuffer([\n    // positions     // colors\n    0.5,  0.5, 0.0,  1.0, 0.0, 0.0,  // top right\n    0.5, -0.5, 0.0,  0.0, 1.0, 0.0,  // bottom right\n   -0.5, -0.5, 0.0,  0.0, 0.0, 1.0,  // bottom left\n   -0.5,  0.5, 0.0,  1.0, 1.0, 0.0   // top left\n]);\n\n// define indices to form two triangles\n$indices = new GL\\Buffer\\UIntBuffer([\n    0, 1, 3,  // first triangle\n    1, 2, 3   // second triangle\n]);\n\nglGenVertexArrays(1, $VAO);\nglGenBuffers(1, $VBO);\nglGenBuffers(1, $EBO);\n\nglBindVertexArray($VAO);\nglBindBuffer(GL_ARRAY_BUFFER, $VBO);\nglBufferData(GL_ARRAY_BUFFER, $vertices, GL_STATIC_DRAW);\n\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, $EBO);\nglBufferData(GL_ELEMENT_ARRAY_BUFFER, $indices, GL_STATIC_DRAW);\n\n// ... set up vertex attributes ...\n\n// draw the rectangle using indices\nglDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);\n</code></pre></p>  arguments  <ol> <li><code>int</code> <code>$mode</code> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES are accepted.</li> <li><code>int</code> <code>$count</code> Specifies the number of elements to be rendered.</li> <li><code>int</code> <code>$type</code> Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or GL_UNSIGNED_INT.</li> <li><code>int|\\GL\\Buffer\\UIntBuffer|\\GL\\Buffer\\UShortBuffer|\\GL\\Buffer\\UByteBuffer</code> <code>$indices</code> Specifies a buffer object containing the indices, or an offset into the currently bound element array buffer.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDrawElements.html"},{"title":"glDrawTransformFeedback","text":"<p>render primitives using a count derived from a transform feedback object</p> <pre><code>function glDrawTransformFeedback(int $mode, int $id) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$mode</code> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted.</li> <li><code>int</code> <code>$id</code> Specifies the name of a transform feedback object from which to retrieve a primitive count.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDrawTransformFeedback.html"},{"title":"glDrawTransformFeedbackStream","text":"<p>render primitives using a count derived from a specifed stream of a transform feedback object</p> <pre><code>function glDrawTransformFeedbackStream(int $mode, int $id, int $stream) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$mode</code> Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES are accepted.</li> <li><code>int</code> <code>$id</code> Specifies the name of a transform feedback object from which to retrieve a primitive count.</li> <li><code>int</code> <code>$stream</code> Specifies the index of the transform feedback stream from which to retrieve a primitive count.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glDrawTransformFeedbackStream.html"},{"title":"glEnable","text":"<p>enable or disable server-side GL capabilities</p> <pre><code>function glEnable(int $cap) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$cap</code> Specifies a symbolic constant indicating a GL capability.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glEnable.html"},{"title":"glEnableVertexAttribArray","text":"<p>Enable or disable a generic vertex attribute     array</p> <pre><code>function glEnableVertexAttribArray(int $index) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> Specifies the index of the generic vertex attribute to be enabled or disabled.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glEnableVertexAttribArray.html"},{"title":"glEnablei","text":"<p>glEnablei</p> <pre><code>function glEnablei(int $target, int $index) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$index</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glEnablei.html"},{"title":"glEndConditionalRender","text":"<p>glEndConditionalRender</p> <pre><code>function glEndConditionalRender() : void\n</code></pre>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glEndConditionalRender.html"},{"title":"glEndQuery","text":"<p>glEndQuery</p> <pre><code>function glEndQuery(int $target) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glEndQuery.html"},{"title":"glEndQueryIndexed","text":"<p>glEndQueryIndexed</p> <pre><code>function glEndQueryIndexed(int $target, int $index) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$index</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glEndQueryIndexed.html"},{"title":"glEndTransformFeedback","text":"<p>glEndTransformFeedback</p> <pre><code>function glEndTransformFeedback() : void\n</code></pre>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glEndTransformFeedback.html"},{"title":"glFenceSync","text":"<p>create a new sync object and insert it into the GL command stream</p> <pre><code>function glFenceSync(int $condition, int $flags) : int\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$condition</code> Specifies the condition that must be met to set the sync object's state to signaled. condition must be GL_SYNC_GPU_COMMANDS_COMPLETE.</li> <li><code>int</code> <code>$flags</code> Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are presently defined for this operation and flags must be zero. flags is a placeholder for anticipated future extensions of fence sync object capabilities.</li> </ol>  returns  <p><code>int</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glFenceSync.html"},{"title":"glFinish","text":"<p>block until all GL execution is complete</p> <pre><code>function glFinish() : void\n</code></pre>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glFinish.html"},{"title":"glFlush","text":"<p>force execution of GL commands in finite time</p> <pre><code>function glFlush() : void\n</code></pre>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glFlush.html"},{"title":"glFlushMappedBufferRange","text":"<p>indicate modifications to a range of a mapped buffer</p> <pre><code>function glFlushMappedBufferRange(int $target, int $offset, int $length) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies the target to which the buffer object is bound for glFlushMappedBufferRange, which must be one of the buffer binding targets in the following table:</li> <li><code>int</code> <code>$offset</code> Specifies the start of the buffer subrange, in basic machine units.</li> <li><code>int</code> <code>$length</code> Specifies the length of the buffer subrange, in basic machine units.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glFlushMappedBufferRange.html"},{"title":"glFramebufferRenderbuffer","text":"<p>attach a renderbuffer as a logical buffer of a framebuffer object</p> <pre><code>function glFramebufferRenderbuffer(int $target, int $attachment, int $renderbuffertarget, int $renderbuffer) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies the target to which the framebuffer is bound for glFramebufferRenderbuffer.</li> <li><code>int</code> <code>$attachment</code> Specifies the attachment point of the framebuffer.</li> <li><code>int</code> <code>$renderbuffertarget</code> Specifies the renderbuffer target. Must be GL_RENDERBUFFER.</li> <li><code>int</code> <code>$renderbuffer</code> Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glFramebufferRenderbuffer.html"},{"title":"glFramebufferTexture","text":"<p>attach a level of a texture object as a logical buffer of a framebuffer object</p> <pre><code>function glFramebufferTexture(int $target, int $attachment, int $texture, int $level) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies the target to which the framebuffer is bound for all commands except glNamedFramebufferTexture.</li> <li><code>int</code> <code>$attachment</code> Specifies the attachment point of the framebuffer.</li> <li><code>int</code> <code>$texture</code> Specifies the name of an existing texture object to attach.</li> <li><code>int</code> <code>$level</code> Specifies the mipmap level of the texture object to attach.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glFramebufferTexture.html"},{"title":"glFramebufferTexture1D","text":"<p>glFramebufferTexture1D</p> <pre><code>function glFramebufferTexture1D(int $target, int $attachment, int $textarget, int $texture, int $level) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$attachment</code> </li> <li><code>int</code> <code>$textarget</code> </li> <li><code>int</code> <code>$texture</code> </li> <li><code>int</code> <code>$level</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glFramebufferTexture1D.html"},{"title":"glFramebufferTexture2D","text":"<p>glFramebufferTexture2D</p> <pre><code>function glFramebufferTexture2D(int $target, int $attachment, int $textarget, int $texture, int $level) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$attachment</code> </li> <li><code>int</code> <code>$textarget</code> </li> <li><code>int</code> <code>$texture</code> </li> <li><code>int</code> <code>$level</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glFramebufferTexture2D.html"},{"title":"glFramebufferTexture3D","text":"<p>glFramebufferTexture3D</p> <pre><code>function glFramebufferTexture3D(int $target, int $attachment, int $textarget, int $texture, int $level, int $zoffset) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$attachment</code> </li> <li><code>int</code> <code>$textarget</code> </li> <li><code>int</code> <code>$texture</code> </li> <li><code>int</code> <code>$level</code> </li> <li><code>int</code> <code>$zoffset</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glFramebufferTexture3D.html"},{"title":"glFramebufferTextureLayer","text":"<p>attach a single layer of a texture object as a logical buffer of a framebuffer object</p> <pre><code>function glFramebufferTextureLayer(int $target, int $attachment, int $texture, int $level, int $layer) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies the target to which the framebuffer is bound for glFramebufferTextureLayer.</li> <li><code>int</code> <code>$attachment</code> Specifies the attachment point of the framebuffer.</li> <li><code>int</code> <code>$texture</code> Specifies the name of an existing texture object to attach.</li> <li><code>int</code> <code>$level</code> Specifies the mipmap level of the texture object to attach.</li> <li><code>int</code> <code>$layer</code> Specifies the layer of the texture object to attach.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glFramebufferTextureLayer.html"},{"title":"glFrontFace","text":"<p>define front- and back-facing polygons</p> <pre><code>function glFrontFace(int $mode) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$mode</code> Specifies the orientation of front-facing polygons. GL_CW and GL_CCW are accepted. The initial value is GL_CCW.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glFrontFace.html"},{"title":"glGenBuffers","text":"<p>generate buffer object names</p> <pre><code>function glGenBuffers(int $n, ?int &amp;...$buffers) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$n</code> Specifies the number of buffer object names to be generated.</li> <li><code>?int</code> <code>$buffers</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGenBuffers.html"},{"title":"glGenFramebuffers","text":"<p>generate framebuffer object names</p> <pre><code>function glGenFramebuffers(int $n, ?int &amp;...$framebuffers) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$n</code> Specifies the number of framebuffer object names to generate.</li> <li><code>?int</code> <code>$framebuffers</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGenFramebuffers.html"},{"title":"glGenProgramPipelines","text":"<p>reserve program pipeline object names</p> <pre><code>function glGenProgramPipelines(int $n, ?int &amp;...$pipelines) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$n</code> Specifies the number of program pipeline object names to reserve.</li> <li><code>?int</code> <code>$pipelines</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGenProgramPipelines.html"},{"title":"glGenQueries","text":"<p>generate query object names</p> <pre><code>function glGenQueries(int $n, ?int &amp;...$ids) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$n</code> Specifies the number of query object names to be generated.</li> <li><code>?int</code> <code>$ids</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGenQueries.html"},{"title":"glGenRenderbuffers","text":"<p>generate renderbuffer object names</p> <pre><code>function glGenRenderbuffers(int $n, ?int &amp;...$renderbuffers) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$n</code> Specifies the number of renderbuffer object names to generate.</li> <li><code>?int</code> <code>$renderbuffers</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGenRenderbuffers.html"},{"title":"glGenSamplers","text":"<p>generate sampler object names</p> <pre><code>function glGenSamplers(int $count, ?int &amp;...$samplers) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$count</code> </li> <li><code>?int</code> <code>$samplers</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGenSamplers.html"},{"title":"glGenTextures","text":"<p>generate texture names</p> <pre><code>function glGenTextures(int $n, ?int &amp;...$textures) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$n</code> Specifies the number of texture names to be generated.</li> <li><code>?int</code> <code>$textures</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGenTextures.html"},{"title":"glGenTransformFeedbacks","text":"<p>reserve transform feedback object names</p> <pre><code>function glGenTransformFeedbacks(int $n, ?int &amp;...$ids) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$n</code> Specifies the number of transform feedback object names to reserve.</li> <li><code>?int</code> <code>$ids</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGenTransformFeedbacks.html"},{"title":"glGenVertexArrays","text":"<p>generate vertex array object names</p> <pre><code>function glGenVertexArrays(int $n, ?int &amp;...$arrays) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$n</code> Specifies the number of vertex array object names to generate.</li> <li><code>?int</code> <code>$arrays</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGenVertexArrays.html"},{"title":"glGenerateMipmap","text":"<p>generate mipmaps for a specified texture object</p> <pre><code>function glGenerateMipmap(int $target) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies the target to which the texture object is bound for glGenerateMipmap. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP, or GL_TEXTURE_CUBE_MAP_ARRAY.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGenerateMipmap.html"},{"title":"glGetActiveSubroutineUniformiv","text":"<p>glGetActiveSubroutineUniformiv</p> <pre><code>function glGetActiveSubroutineUniformiv(int $program, int $shadertype, int $index, int $pname, int &amp;$values) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$shadertype</code> </li> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$values</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetActiveSubroutineUniformiv.html"},{"title":"glGetActiveUniformBlockiv","text":"<p>glGetActiveUniformBlockiv</p> <pre><code>function glGetActiveUniformBlockiv(int $program, int $uniformBlockIndex, int $pname, int &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$uniformBlockIndex</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetActiveUniformBlockiv.html"},{"title":"glGetAttachedShaders","text":"<p>Returns the handles of the shader objects attached to a program object</p> <pre><code>function glGetAttachedShaders(int $program, int $maxCount, int &amp;$count, int &amp;$shaders) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> Specifies the program object to be queried.</li> <li><code>int</code> <code>$maxCount</code> Specifies the size of the array for storing the returned object names.</li> <li><code>int</code> <code>$count</code> Returns the number of names actually returned in shaders.</li> <li><code>int</code> <code>$shaders</code> Specifies an array that is used to return the names of attached shader objects.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetAttachedShaders.html"},{"title":"glGetAttribLocation","text":"<p>Returns the location of an attribute variable</p> <pre><code>function glGetAttribLocation(int $program, string $name) : int\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> Specifies the program object to be queried.</li> <li><code>string</code> <code>$name</code> Points to a null terminated string containing the name of the attribute variable whose location is to be queried.</li> </ol>  returns  <p><code>int</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetAttribLocation.html"},{"title":"glGetBooleani_v","text":"<p>glGetBooleani_v</p> <pre><code>function glGetBooleani_v(int $target, int $index, ?bool &amp;...$data) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$index</code> </li> <li><code>?bool</code> <code>$data</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetBooleani_v.html"},{"title":"glGetBooleanv","text":"<p>glGetBooleanv</p> <pre><code>function glGetBooleanv(int $pname, ?bool &amp;...$data) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$pname</code> </li> <li><code>?bool</code> <code>$data</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetBooleanv.html"},{"title":"glGetBufferParameteri64v","text":"<p>glGetBufferParameteri64v</p> <pre><code>function glGetBufferParameteri64v(int $target, int $pname, int &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetBufferParameteri64v.html"},{"title":"glGetBufferParameteriv","text":"<p>return parameters of a buffer object</p> <pre><code>function glGetBufferParameteriv(int $target, int $pname, int &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies the target to which the buffer object is bound for glGetBufferParameteriv and glGetBufferParameteri64v. Must be one of the buffer binding targets in the following table:</li> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetBufferParameteriv.html"},{"title":"glGetDoublei_v","text":"<p>glGetDoublei_v</p> <pre><code>function glGetDoublei_v(int $target, int $index, ?bool &amp;...$data) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$index</code> </li> <li><code>?bool</code> <code>$data</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetDoublei_v.html"},{"title":"glGetDoublev","text":"<p>glGetDoublev</p> <pre><code>function glGetDoublev(int $pname, ?bool &amp;...$data) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$pname</code> </li> <li><code>?bool</code> <code>$data</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetDoublev.html"},{"title":"glGetError","text":"<p>return error information</p> <pre><code>function glGetError() : int\n</code></pre>  returns  <p><code>int</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetError.html"},{"title":"glGetFloati_v","text":"<p>glGetFloati_v</p> <pre><code>function glGetFloati_v(int $target, int $index, ?bool &amp;...$data) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$index</code> </li> <li><code>?bool</code> <code>$data</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetFloati_v.html"},{"title":"glGetFloatv","text":"<p>glGetFloatv</p> <pre><code>function glGetFloatv(int $pname, ?bool &amp;...$data) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$pname</code> </li> <li><code>?bool</code> <code>$data</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetFloatv.html"},{"title":"glGetFragDataIndex","text":"<p>query the bindings of color indices to user-defined varying out variables</p> <pre><code>function glGetFragDataIndex(int $program, string $name) : int\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> The name of the program containing varying out variable whose binding to query</li> <li><code>string</code> <code>$name</code> The name of the user-defined varying out variable whose index to query</li> </ol>  returns  <p><code>int</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetFragDataIndex.html"},{"title":"glGetFragDataLocation","text":"<p>query the bindings of color numbers to user-defined varying out variables</p> <pre><code>function glGetFragDataLocation(int $program, string $name) : int\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> The name of the program containing varying out variable whose binding to query</li> <li><code>string</code> <code>$name</code> The name of the user-defined varying out variable whose binding to query</li> </ol>  returns  <p><code>int</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetFragDataLocation.html"},{"title":"glGetFramebufferAttachmentParameteriv","text":"<p>retrieve information about attachments of a framebuffer object</p> <pre><code>function glGetFramebufferAttachmentParameteriv(int $target, int $attachment, int $pname, int &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies the target to which the framebuffer object is bound for glGetFramebufferAttachmentParameteriv.</li> <li><code>int</code> <code>$attachment</code> Specifies the attachment of the framebuffer object to query.</li> <li><code>int</code> <code>$pname</code> Specifies the parameter of attachment to query.</li> <li><code>int</code> <code>$params</code> Returns the value of parameter pname for attachment.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetFramebufferAttachmentParameteriv.html"},{"title":"glGetInteger64i_v","text":"<p>glGetInteger64i_v</p> <pre><code>function glGetInteger64i_v(int $target, int $index, int &amp;$data) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$data</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetInteger64i_v.html"},{"title":"glGetInteger64v","text":"<p>glGetInteger64v</p> <pre><code>function glGetInteger64v(int $pname, int &amp;$data) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$data</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetInteger64v.html"},{"title":"glGetIntegeri_v","text":"<p>glGetIntegeri_v</p> <pre><code>function glGetIntegeri_v(int $target, int $index, ?bool &amp;...$data) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$index</code> </li> <li><code>?bool</code> <code>$data</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetIntegeri_v.html"},{"title":"glGetIntegerv","text":"<p>glGetIntegerv</p> <pre><code>function glGetIntegerv(int $pname, ?bool &amp;...$data) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$pname</code> </li> <li><code>?bool</code> <code>$data</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetIntegerv.html"},{"title":"glGetMultisamplefv","text":"<p>retrieve the location of a sample</p> <pre><code>function glGetMultisamplefv(int $pname, int $index, float &amp;$val) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$pname</code> Specifies the sample parameter name. pname must be GL_SAMPLE_POSITION.</li> <li><code>int</code> <code>$index</code> Specifies the index of the sample whose position to query.</li> <li><code>float</code> <code>$val</code> Specifies the address of an array to receive the position of the sample.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetMultisamplefv.html"},{"title":"glGetProgramInfoLog","text":"<p>Returns the information log for a program object</p> <pre><code>function glGetProgramInfoLog(int $program, int $bufSize) : string\n</code></pre>  <p>PHP-GLFW Note</p> <p>In the PHP extension this function directly returns the error string instead of being passed by reference as an argument.</p>   arguments  <ol> <li><code>int</code> <code>$program</code> Specifies the program object whose information log is to be queried.</li> <li><code>int</code> <code>$bufSize</code> Specifies the size of the character buffer for storing the returned information log.</li> </ol>  returns  <p><code>string</code> Returns the information log for the specified object.</p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetProgramInfoLog.html"},{"title":"glGetProgramPipelineiv","text":"<p>glGetProgramPipelineiv</p> <pre><code>function glGetProgramPipelineiv(int $pipeline, int $pname, int &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$pipeline</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetProgramPipelineiv.html"},{"title":"glGetProgramStageiv","text":"<p>glGetProgramStageiv</p> <pre><code>function glGetProgramStageiv(int $program, int $shadertype, int $pname, int &amp;$values) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$shadertype</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$values</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetProgramStageiv.html"},{"title":"glGetProgramiv","text":"<p>glGetProgramiv</p> <pre><code>function glGetProgramiv(int $program, int $pname, int &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetProgramiv.html"},{"title":"glGetQueryIndexediv","text":"<p>return parameters of an indexed query object target</p> <pre><code>function glGetQueryIndexediv(int $target, int $index, int $pname, int &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP.</li> <li><code>int</code> <code>$index</code> Specifies the index of the query object target.</li> <li><code>int</code> <code>$pname</code> Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS.</li> <li><code>int</code> <code>$params</code> Returns the requested data.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetQueryIndexediv.html"},{"title":"glGetQueryObjecti64v","text":"<p>glGetQueryObjecti64v</p> <pre><code>function glGetQueryObjecti64v(int $id, int $pname, int &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$id</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetQueryObjecti64v.html"},{"title":"glGetQueryObjectiv","text":"<p>glGetQueryObjectiv</p> <pre><code>function glGetQueryObjectiv(int $id, int $pname, int &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$id</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetQueryObjectiv.html"},{"title":"glGetQueryObjectui64v","text":"<p>glGetQueryObjectui64v</p> <pre><code>function glGetQueryObjectui64v(int $id, int $pname, int &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$id</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetQueryObjectui64v.html"},{"title":"glGetQueryObjectuiv","text":"<p>glGetQueryObjectuiv</p> <pre><code>function glGetQueryObjectuiv(int $id, int $pname, int &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$id</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetQueryObjectuiv.html"},{"title":"glGetQueryiv","text":"<p>return parameters of a query object target</p> <pre><code>function glGetQueryiv(int $target, int $pname, int &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP.</li> <li><code>int</code> <code>$pname</code> Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY or GL_QUERY_COUNTER_BITS.</li> <li><code>int</code> <code>$params</code> Returns the requested data.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetQueryiv.html"},{"title":"glGetRenderbufferParameteriv","text":"<p>glGetRenderbufferParameteriv</p> <pre><code>function glGetRenderbufferParameteriv(int $target, int $pname, int &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetRenderbufferParameteriv.html"},{"title":"glGetSamplerParameterIiv","text":"<p>glGetSamplerParameterIiv</p> <pre><code>function glGetSamplerParameterIiv(int $sampler, int $pname, int &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$sampler</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetSamplerParameterIiv.html"},{"title":"glGetSamplerParameterIuiv","text":"<p>glGetSamplerParameterIuiv</p> <pre><code>function glGetSamplerParameterIuiv(int $sampler, int $pname, int &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$sampler</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetSamplerParameterIuiv.html"},{"title":"glGetSamplerParameterfv","text":"<p>glGetSamplerParameterfv</p> <pre><code>function glGetSamplerParameterfv(int $sampler, int $pname, float &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$sampler</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>float</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetSamplerParameterfv.html"},{"title":"glGetSamplerParameteriv","text":"<p>glGetSamplerParameteriv</p> <pre><code>function glGetSamplerParameteriv(int $sampler, int $pname, int &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$sampler</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetSamplerParameteriv.html"},{"title":"glGetShaderInfoLog","text":"<p>Returns the information log for a shader object</p> <pre><code>function glGetShaderInfoLog(int $shader, int $bufSize) : string\n</code></pre>  <p>PHP-GLFW Note</p> <p>In the PHP extension this function directly returns the error string instead of being passed by reference as an argument.</p>   arguments  <ol> <li><code>int</code> <code>$shader</code> Specifies the shader object whose information log is to be queried.</li> <li><code>int</code> <code>$bufSize</code> Specifies the size of the character buffer for storing the returned information log.</li> </ol>  returns  <p><code>string</code> Returns the information log for the specified object.</p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetShaderInfoLog.html"},{"title":"glGetShaderPrecisionFormat","text":"<p>retrieve the range and precision for numeric formats supported by the shader compiler</p> <pre><code>function glGetShaderPrecisionFormat(int $shadertype, int $precisiontype, int &amp;$range, int &amp;$precision) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$shadertype</code> </li> <li><code>int</code> <code>$precisiontype</code> </li> <li><code>int</code> <code>$range</code> Specifies the address of array of two integers into which encodings of the implementation's numeric range are returned.</li> <li><code>int</code> <code>$precision</code> Specifies the address of an integer into which the numeric precision of the implementation is written.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetShaderPrecisionFormat.html"},{"title":"glGetShaderiv","text":"<p>glGetShaderiv</p> <pre><code>function glGetShaderiv(int $shader, int $pname, int &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$shader</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetShaderiv.html"},{"title":"glGetString","text":"<p>return a string describing the current GL connection</p> <pre><code>function glGetString(int $name) : string\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$name</code> Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi accepts the GL_EXTENSIONS token.</li> </ol>  returns  <p><code>string</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetString.html"},{"title":"glGetStringi","text":"<p>glGetStringi</p> <pre><code>function glGetStringi(int $name, int $index) : string\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$name</code> </li> <li><code>int</code> <code>$index</code> </li> </ol>  returns  <p><code>string</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetStringi.html"},{"title":"glGetSubroutineIndex","text":"<p>retrieve the index of a subroutine uniform of a given shader stage within a program</p> <pre><code>function glGetSubroutineIndex(int $program, int $shadertype, string $name) : int\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> Specifies the name of the program containing shader stage.</li> <li><code>int</code> <code>$shadertype</code> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER.</li> <li><code>string</code> <code>$name</code> Specifies the name of the subroutine uniform whose index to query.</li> </ol>  returns  <p><code>int</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetSubroutineIndex.html"},{"title":"glGetSubroutineUniformLocation","text":"<p>retrieve the location of a subroutine uniform of a given shader stage within a program</p> <pre><code>function glGetSubroutineUniformLocation(int $program, int $shadertype, string $name) : int\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> Specifies the name of the program containing shader stage.</li> <li><code>int</code> <code>$shadertype</code> Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or GL_FRAGMENT_SHADER.</li> <li><code>string</code> <code>$name</code> Specifies the name of the subroutine uniform whose index to query.</li> </ol>  returns  <p><code>int</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetSubroutineUniformLocation.html"},{"title":"glGetSynciv","text":"<p>query the properties of a sync object</p> <pre><code>function glGetSynciv(int $sync, int $pname, int $count, int &amp;$length, int &amp;$values) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$sync</code> Specifies the sync object whose properties to query.</li> <li><code>int</code> <code>$pname</code> Specifies the parameter whose value to retrieve from the sync object specified in sync.</li> <li><code>int</code> <code>$count</code> </li> <li><code>int</code> <code>$length</code> Specifies the address of an variable to receive the number of integers placed in values.</li> <li><code>int</code> <code>$values</code> Specifies the address of an array to receive the values of the queried parameter.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetSynciv.html"},{"title":"glGetTexImage","text":"<p>glGetTexImage</p> <pre><code>function glGetTexImage(int $target, int $level, int $format, int $type, \\GL\\Buffer\\BufferInterface $pixels) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$level</code> </li> <li><code>int</code> <code>$format</code> </li> <li><code>int</code> <code>$type</code> </li> <li><code>\\GL\\Buffer\\BufferInterface</code> <code>$pixels</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetTexImage.html"},{"title":"glGetTexLevelParameterfv","text":"<p>glGetTexLevelParameterfv</p> <pre><code>function glGetTexLevelParameterfv(int $target, int $level, int $pname, float &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$level</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>float</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetTexLevelParameterfv.html"},{"title":"glGetTexLevelParameteriv","text":"<p>glGetTexLevelParameteriv</p> <pre><code>function glGetTexLevelParameteriv(int $target, int $level, int $pname, int &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$level</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetTexLevelParameteriv.html"},{"title":"glGetTexParameterIiv","text":"<p>glGetTexParameterIiv</p> <pre><code>function glGetTexParameterIiv(int $target, int $pname, ?bool &amp;...$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>?bool</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetTexParameterIiv.html"},{"title":"glGetTexParameterIuiv","text":"<p>glGetTexParameterIuiv</p> <pre><code>function glGetTexParameterIuiv(int $target, int $pname, ?bool &amp;...$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>?bool</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetTexParameterIuiv.html"},{"title":"glGetTexParameterfv","text":"<p>glGetTexParameterfv</p> <pre><code>function glGetTexParameterfv(int $target, int $pname, ?bool &amp;...$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>?bool</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetTexParameterfv.html"},{"title":"glGetTexParameteriv","text":"<p>glGetTexParameteriv</p> <pre><code>function glGetTexParameteriv(int $target, int $pname, ?bool &amp;...$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>?bool</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetTexParameteriv.html"},{"title":"glGetUniformBlockIndex","text":"<p>retrieve the index of a named uniform block</p> <pre><code>function glGetUniformBlockIndex(int $program, string $uniformBlockName) : int\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> Specifies the name of a program containing the uniform block.</li> <li><code>string</code> <code>$uniformBlockName</code> Specifies the address an array of characters to containing the name of the uniform block whose index to retrieve.</li> </ol>  returns  <p><code>int</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetUniformBlockIndex.html"},{"title":"glGetUniformLocation","text":"<p>Returns the location of a uniform variable</p> <pre><code>function glGetUniformLocation(int $program, string $name) : int\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> Specifies the program object to be queried.</li> <li><code>string</code> <code>$name</code> Points to a null terminated string containing the name of the uniform variable whose location is to be queried.</li> </ol>  returns  <p><code>int</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetUniformLocation.html"},{"title":"glGetUniformSubroutineuiv","text":"<p>glGetUniformSubroutineuiv</p> <pre><code>function glGetUniformSubroutineuiv(int $shadertype, int $location, int &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$shadertype</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>int</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetUniformSubroutineuiv.html"},{"title":"glGetUniformdv","text":"<p>glGetUniformdv</p> <pre><code>function glGetUniformdv(int $program, int $location, float &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>float</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetUniformdv.html"},{"title":"glGetUniformfv","text":"<p>glGetUniformfv</p> <pre><code>function glGetUniformfv(int $program, int $location, float &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>float</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetUniformfv.html"},{"title":"glGetUniformiv","text":"<p>glGetUniformiv</p> <pre><code>function glGetUniformiv(int $program, int $location, int &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>int</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetUniformiv.html"},{"title":"glGetUniformuiv","text":"<p>glGetUniformuiv</p> <pre><code>function glGetUniformuiv(int $program, int $location, int &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>int</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetUniformuiv.html"},{"title":"glGetVertexAttribIiv","text":"<p>glGetVertexAttribIiv</p> <pre><code>function glGetVertexAttribIiv(int $index, int $pname, int &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetVertexAttribIiv.html"},{"title":"glGetVertexAttribIuiv","text":"<p>glGetVertexAttribIuiv</p> <pre><code>function glGetVertexAttribIuiv(int $index, int $pname, int &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetVertexAttribIuiv.html"},{"title":"glGetVertexAttribLdv","text":"<p>glGetVertexAttribLdv</p> <pre><code>function glGetVertexAttribLdv(int $index, int $pname, float &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>float</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetVertexAttribLdv.html"},{"title":"glGetVertexAttribdv","text":"<p>glGetVertexAttribdv</p> <pre><code>function glGetVertexAttribdv(int $index, int $pname, float &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>float</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetVertexAttribdv.html"},{"title":"glGetVertexAttribfv","text":"<p>glGetVertexAttribfv</p> <pre><code>function glGetVertexAttribfv(int $index, int $pname, float &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>float</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetVertexAttribfv.html"},{"title":"glGetVertexAttribiv","text":"<p>glGetVertexAttribiv</p> <pre><code>function glGetVertexAttribiv(int $index, int $pname, int &amp;$params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glGetVertexAttribiv.html"},{"title":"glHint","text":"<p>specify implementation-specific hints</p> <pre><code>function glHint(int $target, int $mode) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies a symbolic constant indicating the behavior to be controlled. GL_LINE_SMOOTH_HINT, GL_POLYGON_SMOOTH_HINT, GL_TEXTURE_COMPRESSION_HINT, and GL_FRAGMENT_SHADER_DERIVATIVE_HINT are accepted.</li> <li><code>int</code> <code>$mode</code> Specifies a symbolic constant indicating the desired behavior. GL_FASTEST, GL_NICEST, and GL_DONT_CARE are accepted.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glHint.html"},{"title":"glIsBuffer","text":"<p>determine if a name corresponds to a buffer object</p> <pre><code>function glIsBuffer(int $buffer) : bool\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$buffer</code> Specifies a value that may be the name of a buffer object.</li> </ol>  returns  <p><code>bool</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glIsBuffer.html"},{"title":"glIsEnabled","text":"<p>test whether a capability is enabled</p> <pre><code>function glIsEnabled(int $cap) : bool\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$cap</code> Specifies a symbolic constant indicating a GL capability.</li> </ol>  returns  <p><code>bool</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glIsEnabled.html"},{"title":"glIsEnabledi","text":"<p>glIsEnabledi</p> <pre><code>function glIsEnabledi(int $target, int $index) : bool\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$index</code> </li> </ol>  returns  <p><code>bool</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glIsEnabledi.html"},{"title":"glIsFramebuffer","text":"<p>determine if a name corresponds to a framebuffer object</p> <pre><code>function glIsFramebuffer(int $framebuffer) : bool\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$framebuffer</code> Specifies a value that may be the name of a framebuffer object.</li> </ol>  returns  <p><code>bool</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glIsFramebuffer.html"},{"title":"glIsProgram","text":"<p>Determines if a name corresponds to a program object</p> <pre><code>function glIsProgram(int $program) : bool\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> Specifies a potential program object.</li> </ol>  returns  <p><code>bool</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glIsProgram.html"},{"title":"glIsProgramPipeline","text":"<p>determine if a name corresponds to a program pipeline object</p> <pre><code>function glIsProgramPipeline(int $pipeline) : bool\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$pipeline</code> Specifies a value that may be the name of a program pipeline object.</li> </ol>  returns  <p><code>bool</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glIsProgramPipeline.html"},{"title":"glIsQuery","text":"<p>determine if a name corresponds to a query object</p> <pre><code>function glIsQuery(int $id) : bool\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$id</code> Specifies a value that may be the name of a query object.</li> </ol>  returns  <p><code>bool</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glIsQuery.html"},{"title":"glIsRenderbuffer","text":"<p>determine if a name corresponds to a renderbuffer object</p> <pre><code>function glIsRenderbuffer(int $renderbuffer) : bool\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$renderbuffer</code> Specifies a value that may be the name of a renderbuffer object.</li> </ol>  returns  <p><code>bool</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glIsRenderbuffer.html"},{"title":"glIsSampler","text":"<p>determine if a name corresponds to a sampler object</p> <pre><code>function glIsSampler(int $sampler) : bool\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$sampler</code> </li> </ol>  returns  <p><code>bool</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glIsSampler.html"},{"title":"glIsShader","text":"<p>Determines if a name corresponds to a shader object</p> <pre><code>function glIsShader(int $shader) : bool\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$shader</code> Specifies a potential shader object.</li> </ol>  returns  <p><code>bool</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glIsShader.html"},{"title":"glIsSync","text":"<p>determine if a name corresponds to a sync object</p> <pre><code>function glIsSync(int $sync) : bool\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$sync</code> Specifies a value that may be the name of a sync object.</li> </ol>  returns  <p><code>bool</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glIsSync.html"},{"title":"glIsTexture","text":"<p>determine if a name corresponds to a texture</p> <pre><code>function glIsTexture(int $texture) : bool\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$texture</code> Specifies a value that may be the name of a texture.</li> </ol>  returns  <p><code>bool</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glIsTexture.html"},{"title":"glIsTransformFeedback","text":"<p>determine if a name corresponds to a transform feedback object</p> <pre><code>function glIsTransformFeedback(int $id) : bool\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$id</code> Specifies a value that may be the name of a transform feedback object.</li> </ol>  returns  <p><code>bool</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glIsTransformFeedback.html"},{"title":"glIsVertexArray","text":"<p>determine if a name corresponds to a vertex array object</p> <pre><code>function glIsVertexArray(int $array) : bool\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$array</code> Specifies a value that may be the name of a vertex array object.</li> </ol>  returns  <p><code>bool</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glIsVertexArray.html"},{"title":"glLineWidth","text":"<p>specify the width of rasterized lines</p> <pre><code>function glLineWidth(float $width) : void\n</code></pre>  arguments  <ol> <li><code>float</code> <code>$width</code> Specifies the width of rasterized lines. The initial value is 1.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glLineWidth.html"},{"title":"glLinkProgram","text":"<p>Links a program object</p> <pre><code>function glLinkProgram(int $program) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> Specifies the handle of the program object to be linked.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glLinkProgram.html"},{"title":"glLogicOp","text":"<p>specify a logical pixel operation for rendering</p> <pre><code>function glLogicOp(int $opcode) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$opcode</code> Specifies a symbolic constant that selects a logical operation. The following symbols are accepted: GL_CLEAR, GL_SET, GL_COPY, GL_COPY_INVERTED, GL_NOOP, GL_INVERT, GL_AND, GL_NAND, GL_OR, GL_NOR, GL_XOR, GL_EQUIV, GL_AND_REVERSE, GL_AND_INVERTED, GL_OR_REVERSE, and GL_OR_INVERTED. The initial value is GL_COPY.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glLogicOp.html"},{"title":"glMinSampleShading","text":"<p>specifies minimum rate at which sample shading takes place</p> <pre><code>function glMinSampleShading(float $value) : void\n</code></pre>  arguments  <ol> <li><code>float</code> <code>$value</code> Specifies the rate at which samples are shaded within each covered pixel.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glMinSampleShading.html"},{"title":"glMultiTexCoordP1ui","text":"<p>glMultiTexCoordP1ui</p> <pre><code>function glMultiTexCoordP1ui(int $texture, int $type, int $coords) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$texture</code> </li> <li><code>int</code> <code>$type</code> </li> <li><code>int</code> <code>$coords</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glMultiTexCoordP1ui.html"},{"title":"glMultiTexCoordP1uiv","text":"<p>glMultiTexCoordP1uiv</p> <pre><code>function glMultiTexCoordP1uiv(int $texture, int $type, \\GL\\Buffer\\UIntBuffer|array $coords) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$texture</code> </li> <li><code>int</code> <code>$type</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$coords</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glMultiTexCoordP1uiv.html"},{"title":"glMultiTexCoordP2ui","text":"<p>glMultiTexCoordP2ui</p> <pre><code>function glMultiTexCoordP2ui(int $texture, int $type, int $coords) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$texture</code> </li> <li><code>int</code> <code>$type</code> </li> <li><code>int</code> <code>$coords</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glMultiTexCoordP2ui.html"},{"title":"glMultiTexCoordP2uiv","text":"<p>glMultiTexCoordP2uiv</p> <pre><code>function glMultiTexCoordP2uiv(int $texture, int $type, \\GL\\Buffer\\UIntBuffer|array $coords) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$texture</code> </li> <li><code>int</code> <code>$type</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$coords</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glMultiTexCoordP2uiv.html"},{"title":"glMultiTexCoordP3ui","text":"<p>glMultiTexCoordP3ui</p> <pre><code>function glMultiTexCoordP3ui(int $texture, int $type, int $coords) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$texture</code> </li> <li><code>int</code> <code>$type</code> </li> <li><code>int</code> <code>$coords</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glMultiTexCoordP3ui.html"},{"title":"glMultiTexCoordP3uiv","text":"<p>glMultiTexCoordP3uiv</p> <pre><code>function glMultiTexCoordP3uiv(int $texture, int $type, \\GL\\Buffer\\UIntBuffer|array $coords) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$texture</code> </li> <li><code>int</code> <code>$type</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$coords</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glMultiTexCoordP3uiv.html"},{"title":"glMultiTexCoordP4ui","text":"<p>glMultiTexCoordP4ui</p> <pre><code>function glMultiTexCoordP4ui(int $texture, int $type, int $coords) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$texture</code> </li> <li><code>int</code> <code>$type</code> </li> <li><code>int</code> <code>$coords</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glMultiTexCoordP4ui.html"},{"title":"glMultiTexCoordP4uiv","text":"<p>glMultiTexCoordP4uiv</p> <pre><code>function glMultiTexCoordP4uiv(int $texture, int $type, \\GL\\Buffer\\UIntBuffer|array $coords) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$texture</code> </li> <li><code>int</code> <code>$type</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$coords</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glMultiTexCoordP4uiv.html"},{"title":"glNormalP3ui","text":"<p>glNormalP3ui</p> <pre><code>function glNormalP3ui(int $type, int $coords) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$type</code> </li> <li><code>int</code> <code>$coords</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glNormalP3ui.html"},{"title":"glNormalP3uiv","text":"<p>glNormalP3uiv</p> <pre><code>function glNormalP3uiv(int $type, \\GL\\Buffer\\UIntBuffer|array $coords) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$type</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$coords</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glNormalP3uiv.html"},{"title":"glPatchParameterfv","text":"<p>glPatchParameterfv</p> <pre><code>function glPatchParameterfv(int $pname, \\GL\\Buffer\\FloatBuffer|array $values) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$pname</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$values</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glPatchParameterfv.html"},{"title":"glPatchParameteri","text":"<p>glPatchParameteri</p> <pre><code>function glPatchParameteri(int $pname, int $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glPatchParameteri.html"},{"title":"glPauseTransformFeedback","text":"<p>pause transform feedback operations</p> <pre><code>function glPauseTransformFeedback() : void\n</code></pre>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glPauseTransformFeedback.html"},{"title":"glPixelStoref","text":"<p>glPixelStoref</p> <pre><code>function glPixelStoref(int $pname, float $param) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$pname</code> </li> <li><code>float</code> <code>$param</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glPixelStoref.html"},{"title":"glPixelStorei","text":"<p>glPixelStorei</p> <pre><code>function glPixelStorei(int $pname, int $param) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$param</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glPixelStorei.html"},{"title":"glPointParameterf","text":"<p>glPointParameterf</p> <pre><code>function glPointParameterf(int $pname, float $param) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$pname</code> </li> <li><code>float</code> <code>$param</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glPointParameterf.html"},{"title":"glPointParameterfv","text":"<p>glPointParameterfv</p> <pre><code>function glPointParameterfv(int $pname, \\GL\\Buffer\\FloatBuffer|array $params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$pname</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glPointParameterfv.html"},{"title":"glPointParameteri","text":"<p>glPointParameteri</p> <pre><code>function glPointParameteri(int $pname, int $param) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$param</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glPointParameteri.html"},{"title":"glPointParameteriv","text":"<p>glPointParameteriv</p> <pre><code>function glPointParameteriv(int $pname, \\GL\\Buffer\\IntBuffer|array $params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$pname</code> </li> <li><code>\\GL\\Buffer\\IntBuffer|array</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glPointParameteriv.html"},{"title":"glPointSize","text":"<p>specify the diameter of rasterized points</p> <pre><code>function glPointSize(float $size) : void\n</code></pre>  arguments  <ol> <li><code>float</code> <code>$size</code> Specifies the diameter of rasterized points. The initial value is 1.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glPointSize.html"},{"title":"glPolygonMode","text":"<p>select a polygon rasterization mode</p> <pre><code>function glPolygonMode(int $face, int $mode) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$face</code> Specifies the polygons that mode applies to. Must be GL_FRONT_AND_BACK for front- and back-facing polygons.</li> <li><code>int</code> <code>$mode</code> Specifies how polygons will be rasterized. Accepted values are GL_POINT, GL_LINE, and GL_FILL. The initial value is GL_FILL for both front- and back-facing polygons.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glPolygonMode.html"},{"title":"glPolygonOffset","text":"<p>set the scale and units used to calculate depth values</p> <pre><code>function glPolygonOffset(float $factor, float $units) : void\n</code></pre>  arguments  <ol> <li><code>float</code> <code>$factor</code> Specifies a scale factor that is used to create a variable depth offset for each polygon. The initial value is 0.</li> <li><code>float</code> <code>$units</code> Is multiplied by an implementation-specific value to create a constant depth offset. The initial value is 0.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glPolygonOffset.html"},{"title":"glPrimitiveRestartIndex","text":"<p>specify the primitive restart index</p> <pre><code>function glPrimitiveRestartIndex(int $index) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> Specifies the value to be interpreted as the primitive restart index.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glPrimitiveRestartIndex.html"},{"title":"glProgramParameteri","text":"<p>glProgramParameteri</p> <pre><code>function glProgramParameteri(int $program, int $pname, int $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramParameteri.html"},{"title":"glProgramUniform1d","text":"<p>glProgramUniform1d</p> <pre><code>function glProgramUniform1d(int $program, int $location, float $v0) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>float</code> <code>$v0</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform1d.html"},{"title":"glProgramUniform1dv","text":"<p>glProgramUniform1dv</p> <pre><code>function glProgramUniform1dv(int $program, int $location, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform1dv.html"},{"title":"glProgramUniform1f","text":"<p>glProgramUniform1f</p> <pre><code>function glProgramUniform1f(int $program, int $location, float $v0) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>float</code> <code>$v0</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform1f.html"},{"title":"glProgramUniform1fv","text":"<p>glProgramUniform1fv</p> <pre><code>function glProgramUniform1fv(int $program, int $location, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform1fv.html"},{"title":"glProgramUniform1i","text":"<p>glProgramUniform1i</p> <pre><code>function glProgramUniform1i(int $program, int $location, int $v0) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>int</code> <code>$v0</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform1i.html"},{"title":"glProgramUniform1iv","text":"<p>glProgramUniform1iv</p> <pre><code>function glProgramUniform1iv(int $program, int $location, \\GL\\Buffer\\IntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\IntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform1iv.html"},{"title":"glProgramUniform1ui","text":"<p>glProgramUniform1ui</p> <pre><code>function glProgramUniform1ui(int $program, int $location, int $v0) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>int</code> <code>$v0</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform1ui.html"},{"title":"glProgramUniform1uiv","text":"<p>glProgramUniform1uiv</p> <pre><code>function glProgramUniform1uiv(int $program, int $location, \\GL\\Buffer\\UIntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform1uiv.html"},{"title":"glProgramUniform2d","text":"<p>glProgramUniform2d</p> <pre><code>function glProgramUniform2d(int $program, int $location, float $v0, float $v1) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>float</code> <code>$v0</code> </li> <li><code>float</code> <code>$v1</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform2d.html"},{"title":"glProgramUniform2dv","text":"<p>glProgramUniform2dv</p> <pre><code>function glProgramUniform2dv(int $program, int $location, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform2dv.html"},{"title":"glProgramUniform2f","text":"<p>glProgramUniform2f</p> <pre><code>function glProgramUniform2f(int $program, int $location, float $v0, float $v1) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>float</code> <code>$v0</code> </li> <li><code>float</code> <code>$v1</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform2f.html"},{"title":"glProgramUniform2fv","text":"<p>glProgramUniform2fv</p> <pre><code>function glProgramUniform2fv(int $program, int $location, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform2fv.html"},{"title":"glProgramUniform2i","text":"<p>glProgramUniform2i</p> <pre><code>function glProgramUniform2i(int $program, int $location, int $v0, int $v1) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>int</code> <code>$v0</code> </li> <li><code>int</code> <code>$v1</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform2i.html"},{"title":"glProgramUniform2iv","text":"<p>glProgramUniform2iv</p> <pre><code>function glProgramUniform2iv(int $program, int $location, \\GL\\Buffer\\IntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\IntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform2iv.html"},{"title":"glProgramUniform2ui","text":"<p>glProgramUniform2ui</p> <pre><code>function glProgramUniform2ui(int $program, int $location, int $v0, int $v1) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>int</code> <code>$v0</code> </li> <li><code>int</code> <code>$v1</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform2ui.html"},{"title":"glProgramUniform2uiv","text":"<p>glProgramUniform2uiv</p> <pre><code>function glProgramUniform2uiv(int $program, int $location, \\GL\\Buffer\\UIntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform2uiv.html"},{"title":"glProgramUniform3d","text":"<p>glProgramUniform3d</p> <pre><code>function glProgramUniform3d(int $program, int $location, float $v0, float $v1, float $v2) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>float</code> <code>$v0</code> </li> <li><code>float</code> <code>$v1</code> </li> <li><code>float</code> <code>$v2</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform3d.html"},{"title":"glProgramUniform3dv","text":"<p>glProgramUniform3dv</p> <pre><code>function glProgramUniform3dv(int $program, int $location, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform3dv.html"},{"title":"glProgramUniform3f","text":"<p>glProgramUniform3f</p> <pre><code>function glProgramUniform3f(int $program, int $location, float $v0, float $v1, float $v2) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>float</code> <code>$v0</code> </li> <li><code>float</code> <code>$v1</code> </li> <li><code>float</code> <code>$v2</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform3f.html"},{"title":"glProgramUniform3fv","text":"<p>glProgramUniform3fv</p> <pre><code>function glProgramUniform3fv(int $program, int $location, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform3fv.html"},{"title":"glProgramUniform3i","text":"<p>glProgramUniform3i</p> <pre><code>function glProgramUniform3i(int $program, int $location, int $v0, int $v1, int $v2) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>int</code> <code>$v0</code> </li> <li><code>int</code> <code>$v1</code> </li> <li><code>int</code> <code>$v2</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform3i.html"},{"title":"glProgramUniform3iv","text":"<p>glProgramUniform3iv</p> <pre><code>function glProgramUniform3iv(int $program, int $location, \\GL\\Buffer\\IntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\IntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform3iv.html"},{"title":"glProgramUniform3ui","text":"<p>glProgramUniform3ui</p> <pre><code>function glProgramUniform3ui(int $program, int $location, int $v0, int $v1, int $v2) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>int</code> <code>$v0</code> </li> <li><code>int</code> <code>$v1</code> </li> <li><code>int</code> <code>$v2</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform3ui.html"},{"title":"glProgramUniform3uiv","text":"<p>glProgramUniform3uiv</p> <pre><code>function glProgramUniform3uiv(int $program, int $location, \\GL\\Buffer\\UIntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform3uiv.html"},{"title":"glProgramUniform4d","text":"<p>glProgramUniform4d</p> <pre><code>function glProgramUniform4d(int $program, int $location, float $v0, float $v1, float $v2, float $v3) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>float</code> <code>$v0</code> </li> <li><code>float</code> <code>$v1</code> </li> <li><code>float</code> <code>$v2</code> </li> <li><code>float</code> <code>$v3</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform4d.html"},{"title":"glProgramUniform4dv","text":"<p>glProgramUniform4dv</p> <pre><code>function glProgramUniform4dv(int $program, int $location, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform4dv.html"},{"title":"glProgramUniform4f","text":"<p>glProgramUniform4f</p> <pre><code>function glProgramUniform4f(int $program, int $location, float $v0, float $v1, float $v2, float $v3) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>float</code> <code>$v0</code> </li> <li><code>float</code> <code>$v1</code> </li> <li><code>float</code> <code>$v2</code> </li> <li><code>float</code> <code>$v3</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform4f.html"},{"title":"glProgramUniform4fv","text":"<p>glProgramUniform4fv</p> <pre><code>function glProgramUniform4fv(int $program, int $location, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform4fv.html"},{"title":"glProgramUniform4i","text":"<p>glProgramUniform4i</p> <pre><code>function glProgramUniform4i(int $program, int $location, int $v0, int $v1, int $v2, int $v3) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>int</code> <code>$v0</code> </li> <li><code>int</code> <code>$v1</code> </li> <li><code>int</code> <code>$v2</code> </li> <li><code>int</code> <code>$v3</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform4i.html"},{"title":"glProgramUniform4iv","text":"<p>glProgramUniform4iv</p> <pre><code>function glProgramUniform4iv(int $program, int $location, \\GL\\Buffer\\IntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\IntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform4iv.html"},{"title":"glProgramUniform4ui","text":"<p>glProgramUniform4ui</p> <pre><code>function glProgramUniform4ui(int $program, int $location, int $v0, int $v1, int $v2, int $v3) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>int</code> <code>$v0</code> </li> <li><code>int</code> <code>$v1</code> </li> <li><code>int</code> <code>$v2</code> </li> <li><code>int</code> <code>$v3</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform4ui.html"},{"title":"glProgramUniform4uiv","text":"<p>glProgramUniform4uiv</p> <pre><code>function glProgramUniform4uiv(int $program, int $location, \\GL\\Buffer\\UIntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniform4uiv.html"},{"title":"glProgramUniformMatrix2dv","text":"<p>glProgramUniformMatrix2dv</p> <pre><code>function glProgramUniformMatrix2dv(int $program, int $location, bool $transpose, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniformMatrix2dv.html"},{"title":"glProgramUniformMatrix2fv","text":"<p>glProgramUniformMatrix2fv</p> <pre><code>function glProgramUniformMatrix2fv(int $program, int $location, bool $transpose, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniformMatrix2fv.html"},{"title":"glProgramUniformMatrix2x3dv","text":"<p>glProgramUniformMatrix2x3dv</p> <pre><code>function glProgramUniformMatrix2x3dv(int $program, int $location, bool $transpose, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniformMatrix2x3dv.html"},{"title":"glProgramUniformMatrix2x3fv","text":"<p>glProgramUniformMatrix2x3fv</p> <pre><code>function glProgramUniformMatrix2x3fv(int $program, int $location, bool $transpose, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniformMatrix2x3fv.html"},{"title":"glProgramUniformMatrix2x4dv","text":"<p>glProgramUniformMatrix2x4dv</p> <pre><code>function glProgramUniformMatrix2x4dv(int $program, int $location, bool $transpose, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniformMatrix2x4dv.html"},{"title":"glProgramUniformMatrix2x4fv","text":"<p>glProgramUniformMatrix2x4fv</p> <pre><code>function glProgramUniformMatrix2x4fv(int $program, int $location, bool $transpose, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniformMatrix2x4fv.html"},{"title":"glProgramUniformMatrix3dv","text":"<p>glProgramUniformMatrix3dv</p> <pre><code>function glProgramUniformMatrix3dv(int $program, int $location, bool $transpose, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniformMatrix3dv.html"},{"title":"glProgramUniformMatrix3fv","text":"<p>glProgramUniformMatrix3fv</p> <pre><code>function glProgramUniformMatrix3fv(int $program, int $location, bool $transpose, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniformMatrix3fv.html"},{"title":"glProgramUniformMatrix3x2dv","text":"<p>glProgramUniformMatrix3x2dv</p> <pre><code>function glProgramUniformMatrix3x2dv(int $program, int $location, bool $transpose, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniformMatrix3x2dv.html"},{"title":"glProgramUniformMatrix3x2fv","text":"<p>glProgramUniformMatrix3x2fv</p> <pre><code>function glProgramUniformMatrix3x2fv(int $program, int $location, bool $transpose, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniformMatrix3x2fv.html"},{"title":"glProgramUniformMatrix3x4dv","text":"<p>glProgramUniformMatrix3x4dv</p> <pre><code>function glProgramUniformMatrix3x4dv(int $program, int $location, bool $transpose, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniformMatrix3x4dv.html"},{"title":"glProgramUniformMatrix3x4fv","text":"<p>glProgramUniformMatrix3x4fv</p> <pre><code>function glProgramUniformMatrix3x4fv(int $program, int $location, bool $transpose, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniformMatrix3x4fv.html"},{"title":"glProgramUniformMatrix4dv","text":"<p>glProgramUniformMatrix4dv</p> <pre><code>function glProgramUniformMatrix4dv(int $program, int $location, bool $transpose, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniformMatrix4dv.html"},{"title":"glProgramUniformMatrix4fv","text":"<p>glProgramUniformMatrix4fv</p> <pre><code>function glProgramUniformMatrix4fv(int $program, int $location, bool $transpose, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniformMatrix4fv.html"},{"title":"glProgramUniformMatrix4x2dv","text":"<p>glProgramUniformMatrix4x2dv</p> <pre><code>function glProgramUniformMatrix4x2dv(int $program, int $location, bool $transpose, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniformMatrix4x2dv.html"},{"title":"glProgramUniformMatrix4x2fv","text":"<p>glProgramUniformMatrix4x2fv</p> <pre><code>function glProgramUniformMatrix4x2fv(int $program, int $location, bool $transpose, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniformMatrix4x2fv.html"},{"title":"glProgramUniformMatrix4x3dv","text":"<p>glProgramUniformMatrix4x3dv</p> <pre><code>function glProgramUniformMatrix4x3dv(int $program, int $location, bool $transpose, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniformMatrix4x3dv.html"},{"title":"glProgramUniformMatrix4x3fv","text":"<p>glProgramUniformMatrix4x3fv</p> <pre><code>function glProgramUniformMatrix4x3fv(int $program, int $location, bool $transpose, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> </li> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProgramUniformMatrix4x3fv.html"},{"title":"glProvokingVertex","text":"<p>specifiy the vertex to be used as the source of data for flat shaded varyings</p> <pre><code>function glProvokingVertex(int $mode) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$mode</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glProvokingVertex.html"},{"title":"glQueryCounter","text":"<p>record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.</p> <pre><code>function glQueryCounter(int $id, int $target) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$id</code> Specify the name of a query object into which to record the GL time.</li> <li><code>int</code> <code>$target</code> Specify the counter to query. target must be GL_TIMESTAMP.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glQueryCounter.html"},{"title":"glReadBuffer","text":"<p>select a color buffer source for pixels</p> <pre><code>function glReadBuffer(int $src) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$src</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glReadBuffer.html"},{"title":"glReadPixels","text":"<p>glReadPixels</p> <pre><code>function glReadPixels(int $x, int $y, int $width, int $height, int $format, int $type, \\GL\\Buffer\\BufferInterface $pixels) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$x</code> </li> <li><code>int</code> <code>$y</code> </li> <li><code>int</code> <code>$width</code> </li> <li><code>int</code> <code>$height</code> </li> <li><code>int</code> <code>$format</code> </li> <li><code>int</code> <code>$type</code> </li> <li><code>\\GL\\Buffer\\BufferInterface</code> <code>$pixels</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glReadPixels.html"},{"title":"glReleaseShaderCompiler","text":"<p>release resources consumed by the implementation's shader compiler</p> <pre><code>function glReleaseShaderCompiler() : void\n</code></pre>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glReleaseShaderCompiler.html"},{"title":"glRenderbufferStorage","text":"<p>establish data storage, format and dimensions of a     renderbuffer object's image</p> <pre><code>function glRenderbufferStorage(int $target, int $internalformat, int $width, int $height) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies a binding target of the allocation for glRenderbufferStorage function. Must be GL_RENDERBUFFER.</li> <li><code>int</code> <code>$internalformat</code> Specifies the internal format to use for the renderbuffer object's image.</li> <li><code>int</code> <code>$width</code> Specifies the width of the renderbuffer, in pixels.</li> <li><code>int</code> <code>$height</code> Specifies the height of the renderbuffer, in pixels.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glRenderbufferStorage.html"},{"title":"glRenderbufferStorageMultisample","text":"<p>establish data storage, format, dimensions and sample count of     a renderbuffer object's image</p> <pre><code>function glRenderbufferStorageMultisample(int $target, int $samples, int $internalformat, int $width, int $height) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies a binding target of the allocation for glRenderbufferStorageMultisample function. Must be GL_RENDERBUFFER.</li> <li><code>int</code> <code>$samples</code> Specifies the number of samples to be used for the renderbuffer object's storage.</li> <li><code>int</code> <code>$internalformat</code> Specifies the internal format to use for the renderbuffer object's image.</li> <li><code>int</code> <code>$width</code> Specifies the width of the renderbuffer, in pixels.</li> <li><code>int</code> <code>$height</code> Specifies the height of the renderbuffer, in pixels.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glRenderbufferStorageMultisample.html"},{"title":"glResumeTransformFeedback","text":"<p>resume transform feedback operations</p> <pre><code>function glResumeTransformFeedback() : void\n</code></pre>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glResumeTransformFeedback.html"},{"title":"glSampleCoverage","text":"<p>specify multisample coverage parameters</p> <pre><code>function glSampleCoverage(float $value, bool $invert) : void\n</code></pre>  arguments  <ol> <li><code>float</code> <code>$value</code> Specify a single floating-point sample coverage value. The value is clamped to the range    0 1  . The initial value is 1.0.</li> <li><code>bool</code> <code>$invert</code> Specify a single boolean value representing if the coverage masks should be inverted.  GL_TRUE and GL_FALSE are accepted.  The initial value is GL_FALSE.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glSampleCoverage.html"},{"title":"glSampleMaski","text":"<p>set the value of a sub-word of the sample mask</p> <pre><code>function glSampleMaski(int $maskNumber, int $mask) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$maskNumber</code> Specifies which 32-bit sub-word of the sample mask to update.</li> <li><code>int</code> <code>$mask</code> Specifies the new value of the mask sub-word.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glSampleMaski.html"},{"title":"glSamplerParameterIiv","text":"<p>glSamplerParameterIiv</p> <pre><code>function glSamplerParameterIiv(int $sampler, int $pname, \\GL\\Buffer\\IntBuffer|array $param) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$sampler</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>\\GL\\Buffer\\IntBuffer|array</code> <code>$param</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glSamplerParameterIiv.html"},{"title":"glSamplerParameterIuiv","text":"<p>glSamplerParameterIuiv</p> <pre><code>function glSamplerParameterIuiv(int $sampler, int $pname, \\GL\\Buffer\\UIntBuffer|array $param) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$sampler</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$param</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glSamplerParameterIuiv.html"},{"title":"glSamplerParameterf","text":"<p>glSamplerParameterf</p> <pre><code>function glSamplerParameterf(int $sampler, int $pname, float $param) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$sampler</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>float</code> <code>$param</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glSamplerParameterf.html"},{"title":"glSamplerParameterfv","text":"<p>glSamplerParameterfv</p> <pre><code>function glSamplerParameterfv(int $sampler, int $pname, \\GL\\Buffer\\FloatBuffer|array $param) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$sampler</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$param</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glSamplerParameterfv.html"},{"title":"glSamplerParameteri","text":"<p>glSamplerParameteri</p> <pre><code>function glSamplerParameteri(int $sampler, int $pname, int $param) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$sampler</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$param</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glSamplerParameteri.html"},{"title":"glSamplerParameteriv","text":"<p>glSamplerParameteriv</p> <pre><code>function glSamplerParameteriv(int $sampler, int $pname, \\GL\\Buffer\\IntBuffer|array $param) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$sampler</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>\\GL\\Buffer\\IntBuffer|array</code> <code>$param</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glSamplerParameteriv.html"},{"title":"glScissor","text":"<p>define the scissor box</p> <pre><code>function glScissor(int $x, int $y, int $width, int $height) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$x</code> Specify the lower left corner of the scissor box. Initially (0, 0).</li> <li><code>int</code> <code>$y</code> </li> <li><code>int</code> <code>$width</code> Specify the width and height of the scissor box. When a GL context is first attached to a window, width and height are set to the dimensions of that window.</li> <li><code>int</code> <code>$height</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glScissor.html"},{"title":"glScissorArrayv","text":"<p>glScissorArrayv</p> <pre><code>function glScissorArrayv(int $first, \\GL\\Buffer\\IntBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$first</code> </li> <li><code>\\GL\\Buffer\\IntBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glScissorArrayv.html"},{"title":"glScissorIndexed","text":"<p>define the scissor box for a specific viewport</p> <pre><code>function glScissorIndexed(int $index, int $left, int $bottom, int $width, int $height) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> Specifies the index of the viewport whose scissor box to modify.</li> <li><code>int</code> <code>$left</code> Specify the coordinate of the bottom left corner of the scissor box, in pixels.</li> <li><code>int</code> <code>$bottom</code> </li> <li><code>int</code> <code>$width</code> Specify ths dimensions of the scissor box, in pixels.</li> <li><code>int</code> <code>$height</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glScissorIndexed.html"},{"title":"glScissorIndexedv","text":"<p>glScissorIndexedv</p> <pre><code>function glScissorIndexedv(int $index, \\GL\\Buffer\\IntBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\IntBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glScissorIndexedv.html"},{"title":"glSecondaryColorP3ui","text":"<p>glSecondaryColorP3ui</p> <pre><code>function glSecondaryColorP3ui(int $type, int $color) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$type</code> </li> <li><code>int</code> <code>$color</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glSecondaryColorP3ui.html"},{"title":"glSecondaryColorP3uiv","text":"<p>glSecondaryColorP3uiv</p> <pre><code>function glSecondaryColorP3uiv(int $type, \\GL\\Buffer\\UIntBuffer|array $color) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$type</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$color</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glSecondaryColorP3uiv.html"},{"title":"glShaderSource","text":"<p>Replaces the source code in a shader object.</p> <pre><code>function glShaderSource(int $shader, string $source) : void\n</code></pre> <p>PHP-GLFW: As with PHP I don't see a reason to split up the shader source to multiple addresses. This is why the function in PHP is simplyfied.</p>  arguments  <ol> <li><code>int</code> <code>$shader</code> Specifies the handle of the shader object whose source code is to be replaced.</li> <li><code>string</code> <code>$source</code> Specifies a string containing the source code to be loaded into the shader.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glShaderSource.html"},{"title":"glStencilFunc","text":"<p>set front and back function and reference value for stencil testing</p> <pre><code>function glStencilFunc(int $func, int $ref, int $mask) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$func</code> Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.</li> <li><code>int</code> <code>$ref</code> Specifies the reference value for the stencil test. ref is clamped to the range    0  2 n  - 1   , where n is the number of bitplanes in the stencil buffer. The initial value is 0.</li> <li><code>int</code> <code>$mask</code> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glStencilFunc.html"},{"title":"glStencilFuncSeparate","text":"<p>set front and/or back function and reference value for stencil testing</p> <pre><code>function glStencilFuncSeparate(int $face, int $func, int $ref, int $mask) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$face</code> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.</li> <li><code>int</code> <code>$func</code> Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.</li> <li><code>int</code> <code>$ref</code> Specifies the reference value for the stencil test. ref is clamped to the range    0  2 n  - 1   , where n is the number of bitplanes in the stencil buffer. The initial value is 0.</li> <li><code>int</code> <code>$mask</code> Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done. The initial value is all 1's.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glStencilFuncSeparate.html"},{"title":"glStencilMask","text":"<p>control the front and back writing of individual bits in the stencil planes</p> <pre><code>function glStencilMask(int $mask) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$mask</code> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glStencilMask.html"},{"title":"glStencilMaskSeparate","text":"<p>control the front and/or back writing of individual bits in the stencil planes</p> <pre><code>function glStencilMaskSeparate(int $face, int $mask) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$face</code> Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.</li> <li><code>int</code> <code>$mask</code> Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is all 1's.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glStencilMaskSeparate.html"},{"title":"glStencilOp","text":"<p>set front and back stencil test actions</p> <pre><code>function glStencilOp(int $fail, int $zfail, int $zpass) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$fail</code> </li> <li><code>int</code> <code>$zfail</code> </li> <li><code>int</code> <code>$zpass</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glStencilOp.html"},{"title":"glStencilOpSeparate","text":"<p>set front and/or back stencil test actions</p> <pre><code>function glStencilOpSeparate(int $face, int $sfail, int $dpfail, int $dppass) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$face</code> Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.</li> <li><code>int</code> <code>$sfail</code> Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted: GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The initial value is GL_KEEP.</li> <li><code>int</code> <code>$dpfail</code> Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts the same symbolic constants as sfail. The initial value is GL_KEEP.</li> <li><code>int</code> <code>$dppass</code> Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the same symbolic constants as sfail. The initial value is GL_KEEP.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glStencilOpSeparate.html"},{"title":"glTexBuffer","text":"<p>attach a buffer object's data store to a buffer texture object</p> <pre><code>function glTexBuffer(int $target, int $internalformat, int $buffer) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies the target to which the texture is bound for glTexBuffer. Must be GL_TEXTURE_BUFFER.</li> <li><code>int</code> <code>$internalformat</code> Specifies the internal format of the data in the store belonging to buffer.</li> <li><code>int</code> <code>$buffer</code> Specifies the name of the buffer object whose storage to attach to the active buffer texture.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glTexBuffer.html"},{"title":"glTexCoordP1ui","text":"<p>glTexCoordP1ui</p> <pre><code>function glTexCoordP1ui(int $type, int $coords) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$type</code> </li> <li><code>int</code> <code>$coords</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glTexCoordP1ui.html"},{"title":"glTexCoordP1uiv","text":"<p>glTexCoordP1uiv</p> <pre><code>function glTexCoordP1uiv(int $type, \\GL\\Buffer\\UIntBuffer|array $coords) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$type</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$coords</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glTexCoordP1uiv.html"},{"title":"glTexCoordP2ui","text":"<p>glTexCoordP2ui</p> <pre><code>function glTexCoordP2ui(int $type, int $coords) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$type</code> </li> <li><code>int</code> <code>$coords</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glTexCoordP2ui.html"},{"title":"glTexCoordP2uiv","text":"<p>glTexCoordP2uiv</p> <pre><code>function glTexCoordP2uiv(int $type, \\GL\\Buffer\\UIntBuffer|array $coords) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$type</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$coords</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glTexCoordP2uiv.html"},{"title":"glTexCoordP3ui","text":"<p>glTexCoordP3ui</p> <pre><code>function glTexCoordP3ui(int $type, int $coords) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$type</code> </li> <li><code>int</code> <code>$coords</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glTexCoordP3ui.html"},{"title":"glTexCoordP3uiv","text":"<p>glTexCoordP3uiv</p> <pre><code>function glTexCoordP3uiv(int $type, \\GL\\Buffer\\UIntBuffer|array $coords) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$type</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$coords</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glTexCoordP3uiv.html"},{"title":"glTexCoordP4ui","text":"<p>glTexCoordP4ui</p> <pre><code>function glTexCoordP4ui(int $type, int $coords) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$type</code> </li> <li><code>int</code> <code>$coords</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glTexCoordP4ui.html"},{"title":"glTexCoordP4uiv","text":"<p>glTexCoordP4uiv</p> <pre><code>function glTexCoordP4uiv(int $type, \\GL\\Buffer\\UIntBuffer|array $coords) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$type</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$coords</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glTexCoordP4uiv.html"},{"title":"glTexImage2D","text":"<p>specify a two-dimensional texture image</p> <pre><code>function glTexImage2D(int $target, int $level, int $internalformat, int $width, int $height, int $border, int $format, int $type, ?\\GL\\Buffer\\BufferInterface $data) : void\n</code></pre>  <p>PHP-GLFW Note</p> <p>for This function has been modified to accept a <code>BufferInterface</code> object instead of a pointer. Also in this PHP OpenGL extension, the arguments are validated against the passed buffer object. If the buffer object is too small for the given width, height, and format an exception is thrown. This is done to prevent segfaults, this will unfortunately, make the function quite a bit slower. But as uploading textures is anyway a heavy operation the impact should not be noticeable in normal applications.</p>  <p>Example:</p> <pre><code>glGenTextures(1, $texture);\nglBindTexture(GL_TEXTURE_2D, $texture);\n\n// we just create a simple 2x2 texture with 4 channels\n$buffer = new GL\\Buffer\\UByteBuffer([\n    255, 0, 0, 255,\n    0, 255, 0, 255,\n    0, 0, 255, 255,\n    255, 255, 255, 255,\n]);\n\nglTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 4, 4, 0, GL_RGBA, GL_UNSIGNED_BYTE,\n$buffer);\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.</li> <li><code>int</code> <code>$level</code> Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.</li> <li><code>int</code> <code>$internalformat</code> Specifies the number of color components in the texture. Must be one of base internal formats given in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal formats given in Table 3, below.</li> <li><code>int</code> <code>$width</code> Specifies the width of the texture image. All implementations support texture images that are at least 1024 texels wide.</li> <li><code>int</code> <code>$height</code> Specifies the height of the texture image, or the number of layers in a texture array, in the case of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers deep.</li> <li><code>int</code> <code>$border</code> This value must be 0.</li> <li><code>int</code> <code>$format</code> Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER, GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.</li> <li><code>int</code> <code>$type</code> Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.</li> <li><code>?\\GL\\Buffer\\BufferInterface</code> <code>$data</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glTexImage2D.html"},{"title":"glTexImage2DMultisample","text":"<p>establish the data storage, format, dimensions, and number of samples of a multisample texture's image</p> <pre><code>function glTexImage2DMultisample(int $target, int $samples, int $internalformat, int $width, int $height, bool $fixedsamplelocations) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE.</li> <li><code>int</code> <code>$samples</code> The number of samples in the multisample texture's image.</li> <li><code>int</code> <code>$internalformat</code> The internal format to be used to store the multisample texture's image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format.</li> <li><code>int</code> <code>$width</code> The width of the multisample texture's image, in texels.</li> <li><code>int</code> <code>$height</code> The height of the multisample texture's image, in texels.</li> <li><code>bool</code> <code>$fixedsamplelocations</code> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glTexImage2DMultisample.html"},{"title":"glTexImage3DMultisample","text":"<p>establish the data storage, format, dimensions, and number of samples of a multisample texture's image</p> <pre><code>function glTexImage3DMultisample(int $target, int $samples, int $internalformat, int $width, int $height, int $depth, bool $fixedsamplelocations) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY.</li> <li><code>int</code> <code>$samples</code> The number of samples in the multisample texture's image.</li> <li><code>int</code> <code>$internalformat</code> The internal format to be used to store the multisample texture's image. internalformat must specify a color-renderable, depth-renderable, or stencil-renderable format.</li> <li><code>int</code> <code>$width</code> The width of the multisample texture's image, in texels.</li> <li><code>int</code> <code>$height</code> The height of the multisample texture's image, in texels.</li> <li><code>int</code> <code>$depth</code> </li> <li><code>bool</code> <code>$fixedsamplelocations</code> Specifies whether the image will use identical sample locations and the same number of samples for all texels in the image, and the sample locations will not depend on the internal format or size of the image.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glTexImage3DMultisample.html"},{"title":"glTexParameterIiv","text":"<p>glTexParameterIiv</p> <pre><code>function glTexParameterIiv(int $target, int $pname, \\GL\\Buffer\\IntBuffer|array $params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>\\GL\\Buffer\\IntBuffer|array</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glTexParameterIiv.html"},{"title":"glTexParameterIuiv","text":"<p>glTexParameterIuiv</p> <pre><code>function glTexParameterIuiv(int $target, int $pname, \\GL\\Buffer\\UIntBuffer|array $params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glTexParameterIuiv.html"},{"title":"glTexParameterf","text":"<p>glTexParameterf</p> <pre><code>function glTexParameterf(int $target, int $pname, float $param) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>float</code> <code>$param</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glTexParameterf.html"},{"title":"glTexParameterfv","text":"<p>glTexParameterfv</p> <pre><code>function glTexParameterfv(int $target, int $pname, \\GL\\Buffer\\FloatBuffer|array $params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glTexParameterfv.html"},{"title":"glTexParameteri","text":"<p>glTexParameteri</p> <pre><code>function glTexParameteri(int $target, int $pname, int $param) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>int</code> <code>$param</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glTexParameteri.html"},{"title":"glTexParameteriv","text":"<p>glTexParameteriv</p> <pre><code>function glTexParameteriv(int $target, int $pname, \\GL\\Buffer\\IntBuffer|array $params) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> </li> <li><code>int</code> <code>$pname</code> </li> <li><code>\\GL\\Buffer\\IntBuffer|array</code> <code>$params</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glTexParameteriv.html"},{"title":"glUniform1d","text":"<p>glUniform1d</p> <pre><code>function glUniform1d(int $location, float $x) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>float</code> <code>$x</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform1d.html"},{"title":"glUniform1dv","text":"<p>glUniform1dv</p> <pre><code>function glUniform1dv(int $location, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform1dv.html"},{"title":"glUniform1f","text":"<p>glUniform1f</p> <pre><code>function glUniform1f(int $location, float $v0) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>float</code> <code>$v0</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform1f.html"},{"title":"glUniform1fv","text":"<p>glUniform1fv</p> <pre><code>function glUniform1fv(int $location, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform1fv.html"},{"title":"glUniform1i","text":"<p>glUniform1i</p> <pre><code>function glUniform1i(int $location, int $v0) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>int</code> <code>$v0</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform1i.html"},{"title":"glUniform1iv","text":"<p>glUniform1iv</p> <pre><code>function glUniform1iv(int $location, \\GL\\Buffer\\IntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\IntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform1iv.html"},{"title":"glUniform1ui","text":"<p>glUniform1ui</p> <pre><code>function glUniform1ui(int $location, int $v0) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>int</code> <code>$v0</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform1ui.html"},{"title":"glUniform1uiv","text":"<p>glUniform1uiv</p> <pre><code>function glUniform1uiv(int $location, \\GL\\Buffer\\UIntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform1uiv.html"},{"title":"glUniform2d","text":"<p>glUniform2d</p> <pre><code>function glUniform2d(int $location, float $x, float $y) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>float</code> <code>$x</code> </li> <li><code>float</code> <code>$y</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform2d.html"},{"title":"glUniform2dv","text":"<p>glUniform2dv</p> <pre><code>function glUniform2dv(int $location, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform2dv.html"},{"title":"glUniform2f","text":"<p>glUniform2f</p> <pre><code>function glUniform2f(int $location, float $v0, float $v1) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>float</code> <code>$v0</code> </li> <li><code>float</code> <code>$v1</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform2f.html"},{"title":"glUniform2fv","text":"<p>glUniform2fv</p> <pre><code>function glUniform2fv(int $location, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform2fv.html"},{"title":"glUniform2i","text":"<p>glUniform2i</p> <pre><code>function glUniform2i(int $location, int $v0, int $v1) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>int</code> <code>$v0</code> </li> <li><code>int</code> <code>$v1</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform2i.html"},{"title":"glUniform2iv","text":"<p>glUniform2iv</p> <pre><code>function glUniform2iv(int $location, \\GL\\Buffer\\IntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\IntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform2iv.html"},{"title":"glUniform2ui","text":"<p>glUniform2ui</p> <pre><code>function glUniform2ui(int $location, int $v0, int $v1) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>int</code> <code>$v0</code> </li> <li><code>int</code> <code>$v1</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform2ui.html"},{"title":"glUniform2uiv","text":"<p>glUniform2uiv</p> <pre><code>function glUniform2uiv(int $location, \\GL\\Buffer\\UIntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform2uiv.html"},{"title":"glUniform3d","text":"<p>glUniform3d</p> <pre><code>function glUniform3d(int $location, float $x, float $y, float $z) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>float</code> <code>$x</code> </li> <li><code>float</code> <code>$y</code> </li> <li><code>float</code> <code>$z</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform3d.html"},{"title":"glUniform3dv","text":"<p>glUniform3dv</p> <pre><code>function glUniform3dv(int $location, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform3dv.html"},{"title":"glUniform3f","text":"<p>glUniform3f</p> <pre><code>function glUniform3f(int $location, float $v0, float $v1, float $v2) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>float</code> <code>$v0</code> </li> <li><code>float</code> <code>$v1</code> </li> <li><code>float</code> <code>$v2</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform3f.html"},{"title":"glUniform3fv","text":"<p>glUniform3fv</p> <pre><code>function glUniform3fv(int $location, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform3fv.html"},{"title":"glUniform3i","text":"<p>glUniform3i</p> <pre><code>function glUniform3i(int $location, int $v0, int $v1, int $v2) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>int</code> <code>$v0</code> </li> <li><code>int</code> <code>$v1</code> </li> <li><code>int</code> <code>$v2</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform3i.html"},{"title":"glUniform3iv","text":"<p>glUniform3iv</p> <pre><code>function glUniform3iv(int $location, \\GL\\Buffer\\IntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\IntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform3iv.html"},{"title":"glUniform3ui","text":"<p>glUniform3ui</p> <pre><code>function glUniform3ui(int $location, int $v0, int $v1, int $v2) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>int</code> <code>$v0</code> </li> <li><code>int</code> <code>$v1</code> </li> <li><code>int</code> <code>$v2</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform3ui.html"},{"title":"glUniform3uiv","text":"<p>glUniform3uiv</p> <pre><code>function glUniform3uiv(int $location, \\GL\\Buffer\\UIntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform3uiv.html"},{"title":"glUniform4d","text":"<p>glUniform4d</p> <pre><code>function glUniform4d(int $location, float $x, float $y, float $z, float $w) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>float</code> <code>$x</code> </li> <li><code>float</code> <code>$y</code> </li> <li><code>float</code> <code>$z</code> </li> <li><code>float</code> <code>$w</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform4d.html"},{"title":"glUniform4dv","text":"<p>glUniform4dv</p> <pre><code>function glUniform4dv(int $location, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform4dv.html"},{"title":"glUniform4f","text":"<p>glUniform4f</p> <pre><code>function glUniform4f(int $location, float $v0, float $v1, float $v2, float $v3) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>float</code> <code>$v0</code> </li> <li><code>float</code> <code>$v1</code> </li> <li><code>float</code> <code>$v2</code> </li> <li><code>float</code> <code>$v3</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform4f.html"},{"title":"glUniform4fv","text":"<p>glUniform4fv</p> <pre><code>function glUniform4fv(int $location, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform4fv.html"},{"title":"glUniform4i","text":"<p>glUniform4i</p> <pre><code>function glUniform4i(int $location, int $v0, int $v1, int $v2, int $v3) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>int</code> <code>$v0</code> </li> <li><code>int</code> <code>$v1</code> </li> <li><code>int</code> <code>$v2</code> </li> <li><code>int</code> <code>$v3</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform4i.html"},{"title":"glUniform4iv","text":"<p>glUniform4iv</p> <pre><code>function glUniform4iv(int $location, \\GL\\Buffer\\IntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\IntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform4iv.html"},{"title":"glUniform4ui","text":"<p>glUniform4ui</p> <pre><code>function glUniform4ui(int $location, int $v0, int $v1, int $v2, int $v3) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>int</code> <code>$v0</code> </li> <li><code>int</code> <code>$v1</code> </li> <li><code>int</code> <code>$v2</code> </li> <li><code>int</code> <code>$v3</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform4ui.html"},{"title":"glUniform4uiv","text":"<p>glUniform4uiv</p> <pre><code>function glUniform4uiv(int $location, \\GL\\Buffer\\UIntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniform4uiv.html"},{"title":"glUniformBlockBinding","text":"<p>assign a binding point to an active uniform block</p> <pre><code>function glUniformBlockBinding(int $program, int $uniformBlockIndex, int $uniformBlockBinding) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> The name of a program object containing the active uniform block whose binding to assign.</li> <li><code>int</code> <code>$uniformBlockIndex</code> The index of the active uniform block within program whose binding to assign.</li> <li><code>int</code> <code>$uniformBlockBinding</code> Specifies the binding point to which to bind the uniform block with index uniformBlockIndex within program.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniformBlockBinding.html"},{"title":"glUniformMatrix2dv","text":"<p>glUniformMatrix2dv</p> <pre><code>function glUniformMatrix2dv(int $location, bool $transpose, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniformMatrix2dv.html"},{"title":"glUniformMatrix2fv","text":"<p>glUniformMatrix2fv</p> <pre><code>function glUniformMatrix2fv(int $location, bool $transpose, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniformMatrix2fv.html"},{"title":"glUniformMatrix2x3dv","text":"<p>glUniformMatrix2x3dv</p> <pre><code>function glUniformMatrix2x3dv(int $location, bool $transpose, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniformMatrix2x3dv.html"},{"title":"glUniformMatrix2x3fv","text":"<p>glUniformMatrix2x3fv</p> <pre><code>function glUniformMatrix2x3fv(int $location, bool $transpose, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniformMatrix2x3fv.html"},{"title":"glUniformMatrix2x4dv","text":"<p>glUniformMatrix2x4dv</p> <pre><code>function glUniformMatrix2x4dv(int $location, bool $transpose, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniformMatrix2x4dv.html"},{"title":"glUniformMatrix2x4fv","text":"<p>glUniformMatrix2x4fv</p> <pre><code>function glUniformMatrix2x4fv(int $location, bool $transpose, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniformMatrix2x4fv.html"},{"title":"glUniformMatrix3dv","text":"<p>glUniformMatrix3dv</p> <pre><code>function glUniformMatrix3dv(int $location, bool $transpose, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniformMatrix3dv.html"},{"title":"glUniformMatrix3fv","text":"<p>glUniformMatrix3fv</p> <pre><code>function glUniformMatrix3fv(int $location, bool $transpose, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniformMatrix3fv.html"},{"title":"glUniformMatrix3x2dv","text":"<p>glUniformMatrix3x2dv</p> <pre><code>function glUniformMatrix3x2dv(int $location, bool $transpose, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniformMatrix3x2dv.html"},{"title":"glUniformMatrix3x2fv","text":"<p>glUniformMatrix3x2fv</p> <pre><code>function glUniformMatrix3x2fv(int $location, bool $transpose, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniformMatrix3x2fv.html"},{"title":"glUniformMatrix3x4dv","text":"<p>glUniformMatrix3x4dv</p> <pre><code>function glUniformMatrix3x4dv(int $location, bool $transpose, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniformMatrix3x4dv.html"},{"title":"glUniformMatrix3x4fv","text":"<p>glUniformMatrix3x4fv</p> <pre><code>function glUniformMatrix3x4fv(int $location, bool $transpose, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniformMatrix3x4fv.html"},{"title":"glUniformMatrix4dv","text":"<p>glUniformMatrix4dv</p> <pre><code>function glUniformMatrix4dv(int $location, bool $transpose, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniformMatrix4dv.html"},{"title":"glUniformMatrix4f","text":"<p>Sets a matrix (mat4x4) uniform value to the current shader program.</p> <pre><code>function glUniformMatrix4f(int $location, bool $transpose, \\GL\\Math\\Mat4 $matrix) : void\n</code></pre>  <p>PHP-GLFW Note</p> <p>This method is specifc to the php extension and not part of the original OpenGL API.</p>   arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Math\\Mat4</code> <code>$matrix</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniformMatrix4f.html"},{"title":"glUniformMatrix4fv","text":"<p>glUniformMatrix4fv</p> <pre><code>function glUniformMatrix4fv(int $location, bool $transpose, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniformMatrix4fv.html"},{"title":"glUniformMatrix4x2dv","text":"<p>glUniformMatrix4x2dv</p> <pre><code>function glUniformMatrix4x2dv(int $location, bool $transpose, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniformMatrix4x2dv.html"},{"title":"glUniformMatrix4x2fv","text":"<p>glUniformMatrix4x2fv</p> <pre><code>function glUniformMatrix4x2fv(int $location, bool $transpose, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniformMatrix4x2fv.html"},{"title":"glUniformMatrix4x3dv","text":"<p>glUniformMatrix4x3dv</p> <pre><code>function glUniformMatrix4x3dv(int $location, bool $transpose, \\GL\\Buffer\\DoubleBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniformMatrix4x3dv.html"},{"title":"glUniformMatrix4x3fv","text":"<p>glUniformMatrix4x3fv</p> <pre><code>function glUniformMatrix4x3fv(int $location, bool $transpose, \\GL\\Buffer\\FloatBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>bool</code> <code>$transpose</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniformMatrix4x3fv.html"},{"title":"glUniformSubroutinesuiv","text":"<p>glUniformSubroutinesuiv</p> <pre><code>function glUniformSubroutinesuiv(int $shadertype, \\GL\\Buffer\\UIntBuffer|array $indices) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$shadertype</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$indices</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniformSubroutinesuiv.html"},{"title":"glUniformVec2f","text":"<p>Sets a vector (vec2) uniform value to the current shader program.</p> <pre><code>function glUniformVec2f(int $location, \\GL\\Math\\Vec2 $vec) : void\n</code></pre>  <p>PHP-GLFW Note</p> <p>This method is specifc to the php extension and not part of the original OpenGL API.</p>   arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Math\\Vec2</code> <code>$vec</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniformVec2f.html"},{"title":"glUniformVec3f","text":"<p>Sets a vector (vec3) uniform value to the current shader program.</p> <pre><code>function glUniformVec3f(int $location, \\GL\\Math\\Vec3 $vec) : void\n</code></pre>  <p>PHP-GLFW Note</p> <p>This method is specifc to the php extension and not part of the original OpenGL API.</p>   arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Math\\Vec3</code> <code>$vec</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniformVec3f.html"},{"title":"glUniformVec4f","text":"<p>Sets a vector (vec4) uniform value to the current shader program.</p> <pre><code>function glUniformVec4f(int $location, \\GL\\Math\\Vec4 $vec) : void\n</code></pre>  <p>PHP-GLFW Note</p> <p>This method is specifc to the php extension and not part of the original OpenGL API.</p>   arguments  <ol> <li><code>int</code> <code>$location</code> </li> <li><code>\\GL\\Math\\Vec4</code> <code>$vec</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUniformVec4f.html"},{"title":"glUnmapBuffer","text":"<p>release the mapping of a buffer object's data store into the client's address space</p> <pre><code>function glUnmapBuffer(int $target) : bool\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$target</code> Specifies the target to which the buffer object is bound for glUnmapBuffer, which must be one of the buffer binding targets in the following table:</li> </ol>  returns  <p><code>bool</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUnmapBuffer.html"},{"title":"glUseProgram","text":"<p>Installs a program object as part of current rendering state</p> <pre><code>function glUseProgram(int $program) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> Specifies the handle of the program object whose executables are to be used as part of current rendering state.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUseProgram.html"},{"title":"glUseProgramStages","text":"<p>bind stages of a program object to a program pipeline</p> <pre><code>function glUseProgramStages(int $pipeline, int $stages, int $program) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$pipeline</code> Specifies the program pipeline object to which to bind stages from program.</li> <li><code>int</code> <code>$stages</code> Specifies a set of program stages to bind to the program pipeline object.</li> <li><code>int</code> <code>$program</code> Specifies the program object containing the shader executables to use in pipeline.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glUseProgramStages.html"},{"title":"glValidateProgram","text":"<p>Validates a program object</p> <pre><code>function glValidateProgram(int $program) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$program</code> Specifies the handle of the program object to be validated.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glValidateProgram.html"},{"title":"glValidateProgramPipeline","text":"<p>validate a program pipeline object against current GL state</p> <pre><code>function glValidateProgramPipeline(int $pipeline) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$pipeline</code> Specifies the name of a program pipeline object to validate.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glValidateProgramPipeline.html"},{"title":"glVertexAttrib1d","text":"<p>glVertexAttrib1d</p> <pre><code>function glVertexAttrib1d(int $index, float $x) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>float</code> <code>$x</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib1d.html"},{"title":"glVertexAttrib1dv","text":"<p>glVertexAttrib1dv</p> <pre><code>function glVertexAttrib1dv(int $index, \\GL\\Buffer\\DoubleBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib1dv.html"},{"title":"glVertexAttrib1f","text":"<p>glVertexAttrib1f</p> <pre><code>function glVertexAttrib1f(int $index, float $x) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>float</code> <code>$x</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib1f.html"},{"title":"glVertexAttrib1fv","text":"<p>glVertexAttrib1fv</p> <pre><code>function glVertexAttrib1fv(int $index, \\GL\\Buffer\\FloatBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib1fv.html"},{"title":"glVertexAttrib1s","text":"<p>glVertexAttrib1s</p> <pre><code>function glVertexAttrib1s(int $index, int $x) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$x</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib1s.html"},{"title":"glVertexAttrib1sv","text":"<p>glVertexAttrib1sv</p> <pre><code>function glVertexAttrib1sv(int $index, \\GL\\Buffer\\ShortBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\ShortBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib1sv.html"},{"title":"glVertexAttrib2d","text":"<p>glVertexAttrib2d</p> <pre><code>function glVertexAttrib2d(int $index, float $x, float $y) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>float</code> <code>$x</code> </li> <li><code>float</code> <code>$y</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib2d.html"},{"title":"glVertexAttrib2dv","text":"<p>glVertexAttrib2dv</p> <pre><code>function glVertexAttrib2dv(int $index, \\GL\\Buffer\\DoubleBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib2dv.html"},{"title":"glVertexAttrib2f","text":"<p>glVertexAttrib2f</p> <pre><code>function glVertexAttrib2f(int $index, float $x, float $y) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>float</code> <code>$x</code> </li> <li><code>float</code> <code>$y</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib2f.html"},{"title":"glVertexAttrib2fv","text":"<p>glVertexAttrib2fv</p> <pre><code>function glVertexAttrib2fv(int $index, \\GL\\Buffer\\FloatBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib2fv.html"},{"title":"glVertexAttrib2s","text":"<p>glVertexAttrib2s</p> <pre><code>function glVertexAttrib2s(int $index, int $x, int $y) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$x</code> </li> <li><code>int</code> <code>$y</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib2s.html"},{"title":"glVertexAttrib2sv","text":"<p>glVertexAttrib2sv</p> <pre><code>function glVertexAttrib2sv(int $index, \\GL\\Buffer\\ShortBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\ShortBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib2sv.html"},{"title":"glVertexAttrib3d","text":"<p>glVertexAttrib3d</p> <pre><code>function glVertexAttrib3d(int $index, float $x, float $y, float $z) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>float</code> <code>$x</code> </li> <li><code>float</code> <code>$y</code> </li> <li><code>float</code> <code>$z</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib3d.html"},{"title":"glVertexAttrib3dv","text":"<p>glVertexAttrib3dv</p> <pre><code>function glVertexAttrib3dv(int $index, \\GL\\Buffer\\DoubleBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib3dv.html"},{"title":"glVertexAttrib3f","text":"<p>glVertexAttrib3f</p> <pre><code>function glVertexAttrib3f(int $index, float $x, float $y, float $z) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>float</code> <code>$x</code> </li> <li><code>float</code> <code>$y</code> </li> <li><code>float</code> <code>$z</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib3f.html"},{"title":"glVertexAttrib3fv","text":"<p>glVertexAttrib3fv</p> <pre><code>function glVertexAttrib3fv(int $index, \\GL\\Buffer\\FloatBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib3fv.html"},{"title":"glVertexAttrib3s","text":"<p>glVertexAttrib3s</p> <pre><code>function glVertexAttrib3s(int $index, int $x, int $y, int $z) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$x</code> </li> <li><code>int</code> <code>$y</code> </li> <li><code>int</code> <code>$z</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib3s.html"},{"title":"glVertexAttrib3sv","text":"<p>glVertexAttrib3sv</p> <pre><code>function glVertexAttrib3sv(int $index, \\GL\\Buffer\\ShortBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\ShortBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib3sv.html"},{"title":"glVertexAttrib4Nbv","text":"<p>glVertexAttrib4Nbv</p> <pre><code>function glVertexAttrib4Nbv(int $index, \\GL\\Buffer\\ByteBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\ByteBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib4Nbv.html"},{"title":"glVertexAttrib4Niv","text":"<p>glVertexAttrib4Niv</p> <pre><code>function glVertexAttrib4Niv(int $index, \\GL\\Buffer\\IntBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\IntBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib4Niv.html"},{"title":"glVertexAttrib4Nsv","text":"<p>glVertexAttrib4Nsv</p> <pre><code>function glVertexAttrib4Nsv(int $index, \\GL\\Buffer\\ShortBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\ShortBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib4Nsv.html"},{"title":"glVertexAttrib4Nub","text":"<p>glVertexAttrib4Nub</p> <pre><code>function glVertexAttrib4Nub(int $index, int $x, int $y, int $z, int $w) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$x</code> </li> <li><code>int</code> <code>$y</code> </li> <li><code>int</code> <code>$z</code> </li> <li><code>int</code> <code>$w</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib4Nub.html"},{"title":"glVertexAttrib4Nubv","text":"<p>glVertexAttrib4Nubv</p> <pre><code>function glVertexAttrib4Nubv(int $index, \\GL\\Buffer\\UbyteBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\UbyteBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib4Nubv.html"},{"title":"glVertexAttrib4Nuiv","text":"<p>glVertexAttrib4Nuiv</p> <pre><code>function glVertexAttrib4Nuiv(int $index, \\GL\\Buffer\\UIntBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib4Nuiv.html"},{"title":"glVertexAttrib4Nusv","text":"<p>glVertexAttrib4Nusv</p> <pre><code>function glVertexAttrib4Nusv(int $index, \\GL\\Buffer\\UShortBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\UShortBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib4Nusv.html"},{"title":"glVertexAttrib4bv","text":"<p>glVertexAttrib4bv</p> <pre><code>function glVertexAttrib4bv(int $index, \\GL\\Buffer\\ByteBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\ByteBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib4bv.html"},{"title":"glVertexAttrib4d","text":"<p>glVertexAttrib4d</p> <pre><code>function glVertexAttrib4d(int $index, float $x, float $y, float $z, float $w) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>float</code> <code>$x</code> </li> <li><code>float</code> <code>$y</code> </li> <li><code>float</code> <code>$z</code> </li> <li><code>float</code> <code>$w</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib4d.html"},{"title":"glVertexAttrib4dv","text":"<p>glVertexAttrib4dv</p> <pre><code>function glVertexAttrib4dv(int $index, \\GL\\Buffer\\DoubleBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib4dv.html"},{"title":"glVertexAttrib4f","text":"<p>glVertexAttrib4f</p> <pre><code>function glVertexAttrib4f(int $index, float $x, float $y, float $z, float $w) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>float</code> <code>$x</code> </li> <li><code>float</code> <code>$y</code> </li> <li><code>float</code> <code>$z</code> </li> <li><code>float</code> <code>$w</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib4f.html"},{"title":"glVertexAttrib4fv","text":"<p>glVertexAttrib4fv</p> <pre><code>function glVertexAttrib4fv(int $index, \\GL\\Buffer\\FloatBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib4fv.html"},{"title":"glVertexAttrib4iv","text":"<p>glVertexAttrib4iv</p> <pre><code>function glVertexAttrib4iv(int $index, \\GL\\Buffer\\IntBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\IntBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib4iv.html"},{"title":"glVertexAttrib4s","text":"<p>glVertexAttrib4s</p> <pre><code>function glVertexAttrib4s(int $index, int $x, int $y, int $z, int $w) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$x</code> </li> <li><code>int</code> <code>$y</code> </li> <li><code>int</code> <code>$z</code> </li> <li><code>int</code> <code>$w</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib4s.html"},{"title":"glVertexAttrib4sv","text":"<p>glVertexAttrib4sv</p> <pre><code>function glVertexAttrib4sv(int $index, \\GL\\Buffer\\ShortBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\ShortBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib4sv.html"},{"title":"glVertexAttrib4ubv","text":"<p>glVertexAttrib4ubv</p> <pre><code>function glVertexAttrib4ubv(int $index, \\GL\\Buffer\\UbyteBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\UbyteBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib4ubv.html"},{"title":"glVertexAttrib4uiv","text":"<p>glVertexAttrib4uiv</p> <pre><code>function glVertexAttrib4uiv(int $index, \\GL\\Buffer\\UIntBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib4uiv.html"},{"title":"glVertexAttrib4usv","text":"<p>glVertexAttrib4usv</p> <pre><code>function glVertexAttrib4usv(int $index, \\GL\\Buffer\\UShortBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\UShortBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttrib4usv.html"},{"title":"glVertexAttribDivisor","text":"<p>modify the rate at which generic vertex attributes advance during instanced rendering</p> <pre><code>function glVertexAttribDivisor(int $index, int $divisor) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> Specify the index of the generic vertex attribute.</li> <li><code>int</code> <code>$divisor</code> Specify the number of instances that will pass between updates of the generic attribute at slot index.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribDivisor.html"},{"title":"glVertexAttribI1i","text":"<p>glVertexAttribI1i</p> <pre><code>function glVertexAttribI1i(int $index, int $x) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$x</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribI1i.html"},{"title":"glVertexAttribI1iv","text":"<p>glVertexAttribI1iv</p> <pre><code>function glVertexAttribI1iv(int $index, \\GL\\Buffer\\IntBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\IntBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribI1iv.html"},{"title":"glVertexAttribI1ui","text":"<p>glVertexAttribI1ui</p> <pre><code>function glVertexAttribI1ui(int $index, int $x) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$x</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribI1ui.html"},{"title":"glVertexAttribI1uiv","text":"<p>glVertexAttribI1uiv</p> <pre><code>function glVertexAttribI1uiv(int $index, \\GL\\Buffer\\UIntBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribI1uiv.html"},{"title":"glVertexAttribI2i","text":"<p>glVertexAttribI2i</p> <pre><code>function glVertexAttribI2i(int $index, int $x, int $y) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$x</code> </li> <li><code>int</code> <code>$y</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribI2i.html"},{"title":"glVertexAttribI2iv","text":"<p>glVertexAttribI2iv</p> <pre><code>function glVertexAttribI2iv(int $index, \\GL\\Buffer\\IntBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\IntBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribI2iv.html"},{"title":"glVertexAttribI2ui","text":"<p>glVertexAttribI2ui</p> <pre><code>function glVertexAttribI2ui(int $index, int $x, int $y) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$x</code> </li> <li><code>int</code> <code>$y</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribI2ui.html"},{"title":"glVertexAttribI2uiv","text":"<p>glVertexAttribI2uiv</p> <pre><code>function glVertexAttribI2uiv(int $index, \\GL\\Buffer\\UIntBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribI2uiv.html"},{"title":"glVertexAttribI3i","text":"<p>glVertexAttribI3i</p> <pre><code>function glVertexAttribI3i(int $index, int $x, int $y, int $z) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$x</code> </li> <li><code>int</code> <code>$y</code> </li> <li><code>int</code> <code>$z</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribI3i.html"},{"title":"glVertexAttribI3iv","text":"<p>glVertexAttribI3iv</p> <pre><code>function glVertexAttribI3iv(int $index, \\GL\\Buffer\\IntBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\IntBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribI3iv.html"},{"title":"glVertexAttribI3ui","text":"<p>glVertexAttribI3ui</p> <pre><code>function glVertexAttribI3ui(int $index, int $x, int $y, int $z) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$x</code> </li> <li><code>int</code> <code>$y</code> </li> <li><code>int</code> <code>$z</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribI3ui.html"},{"title":"glVertexAttribI3uiv","text":"<p>glVertexAttribI3uiv</p> <pre><code>function glVertexAttribI3uiv(int $index, \\GL\\Buffer\\UIntBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribI3uiv.html"},{"title":"glVertexAttribI4bv","text":"<p>glVertexAttribI4bv</p> <pre><code>function glVertexAttribI4bv(int $index, \\GL\\Buffer\\ByteBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\ByteBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribI4bv.html"},{"title":"glVertexAttribI4i","text":"<p>glVertexAttribI4i</p> <pre><code>function glVertexAttribI4i(int $index, int $x, int $y, int $z, int $w) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$x</code> </li> <li><code>int</code> <code>$y</code> </li> <li><code>int</code> <code>$z</code> </li> <li><code>int</code> <code>$w</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribI4i.html"},{"title":"glVertexAttribI4iv","text":"<p>glVertexAttribI4iv</p> <pre><code>function glVertexAttribI4iv(int $index, \\GL\\Buffer\\IntBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\IntBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribI4iv.html"},{"title":"glVertexAttribI4sv","text":"<p>glVertexAttribI4sv</p> <pre><code>function glVertexAttribI4sv(int $index, \\GL\\Buffer\\ShortBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\ShortBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribI4sv.html"},{"title":"glVertexAttribI4ubv","text":"<p>glVertexAttribI4ubv</p> <pre><code>function glVertexAttribI4ubv(int $index, \\GL\\Buffer\\UbyteBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\UbyteBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribI4ubv.html"},{"title":"glVertexAttribI4ui","text":"<p>glVertexAttribI4ui</p> <pre><code>function glVertexAttribI4ui(int $index, int $x, int $y, int $z, int $w) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$x</code> </li> <li><code>int</code> <code>$y</code> </li> <li><code>int</code> <code>$z</code> </li> <li><code>int</code> <code>$w</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribI4ui.html"},{"title":"glVertexAttribI4uiv","text":"<p>glVertexAttribI4uiv</p> <pre><code>function glVertexAttribI4uiv(int $index, \\GL\\Buffer\\UIntBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribI4uiv.html"},{"title":"glVertexAttribI4usv","text":"<p>glVertexAttribI4usv</p> <pre><code>function glVertexAttribI4usv(int $index, \\GL\\Buffer\\UShortBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\UShortBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribI4usv.html"},{"title":"glVertexAttribL1d","text":"<p>glVertexAttribL1d</p> <pre><code>function glVertexAttribL1d(int $index, float $x) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>float</code> <code>$x</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribL1d.html"},{"title":"glVertexAttribL1dv","text":"<p>glVertexAttribL1dv</p> <pre><code>function glVertexAttribL1dv(int $index, \\GL\\Buffer\\DoubleBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribL1dv.html"},{"title":"glVertexAttribL2d","text":"<p>glVertexAttribL2d</p> <pre><code>function glVertexAttribL2d(int $index, float $x, float $y) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>float</code> <code>$x</code> </li> <li><code>float</code> <code>$y</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribL2d.html"},{"title":"glVertexAttribL2dv","text":"<p>glVertexAttribL2dv</p> <pre><code>function glVertexAttribL2dv(int $index, \\GL\\Buffer\\DoubleBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribL2dv.html"},{"title":"glVertexAttribL3d","text":"<p>glVertexAttribL3d</p> <pre><code>function glVertexAttribL3d(int $index, float $x, float $y, float $z) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>float</code> <code>$x</code> </li> <li><code>float</code> <code>$y</code> </li> <li><code>float</code> <code>$z</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribL3d.html"},{"title":"glVertexAttribL3dv","text":"<p>glVertexAttribL3dv</p> <pre><code>function glVertexAttribL3dv(int $index, \\GL\\Buffer\\DoubleBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribL3dv.html"},{"title":"glVertexAttribL4d","text":"<p>glVertexAttribL4d</p> <pre><code>function glVertexAttribL4d(int $index, float $x, float $y, float $z, float $w) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>float</code> <code>$x</code> </li> <li><code>float</code> <code>$y</code> </li> <li><code>float</code> <code>$z</code> </li> <li><code>float</code> <code>$w</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribL4d.html"},{"title":"glVertexAttribL4dv","text":"<p>glVertexAttribL4dv</p> <pre><code>function glVertexAttribL4dv(int $index, \\GL\\Buffer\\DoubleBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\DoubleBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribL4dv.html"},{"title":"glVertexAttribP1ui","text":"<p>glVertexAttribP1ui</p> <pre><code>function glVertexAttribP1ui(int $index, int $type, bool $normalized, int $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$type</code> </li> <li><code>bool</code> <code>$normalized</code> </li> <li><code>int</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribP1ui.html"},{"title":"glVertexAttribP1uiv","text":"<p>glVertexAttribP1uiv</p> <pre><code>function glVertexAttribP1uiv(int $index, int $type, bool $normalized, \\GL\\Buffer\\UIntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$type</code> </li> <li><code>bool</code> <code>$normalized</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribP1uiv.html"},{"title":"glVertexAttribP2ui","text":"<p>glVertexAttribP2ui</p> <pre><code>function glVertexAttribP2ui(int $index, int $type, bool $normalized, int $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$type</code> </li> <li><code>bool</code> <code>$normalized</code> </li> <li><code>int</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribP2ui.html"},{"title":"glVertexAttribP2uiv","text":"<p>glVertexAttribP2uiv</p> <pre><code>function glVertexAttribP2uiv(int $index, int $type, bool $normalized, \\GL\\Buffer\\UIntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$type</code> </li> <li><code>bool</code> <code>$normalized</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribP2uiv.html"},{"title":"glVertexAttribP3ui","text":"<p>glVertexAttribP3ui</p> <pre><code>function glVertexAttribP3ui(int $index, int $type, bool $normalized, int $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$type</code> </li> <li><code>bool</code> <code>$normalized</code> </li> <li><code>int</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribP3ui.html"},{"title":"glVertexAttribP3uiv","text":"<p>glVertexAttribP3uiv</p> <pre><code>function glVertexAttribP3uiv(int $index, int $type, bool $normalized, \\GL\\Buffer\\UIntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$type</code> </li> <li><code>bool</code> <code>$normalized</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribP3uiv.html"},{"title":"glVertexAttribP4ui","text":"<p>glVertexAttribP4ui</p> <pre><code>function glVertexAttribP4ui(int $index, int $type, bool $normalized, int $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$type</code> </li> <li><code>bool</code> <code>$normalized</code> </li> <li><code>int</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribP4ui.html"},{"title":"glVertexAttribP4uiv","text":"<p>glVertexAttribP4uiv</p> <pre><code>function glVertexAttribP4uiv(int $index, int $type, bool $normalized, \\GL\\Buffer\\UIntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>int</code> <code>$type</code> </li> <li><code>bool</code> <code>$normalized</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribP4uiv.html"},{"title":"glVertexAttribPointer","text":"<p>define an array of generic vertex attribute data</p> <pre><code>function glVertexAttribPointer(int $index, int $size, int $type, bool $normalized, int $stride, int $offset) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> Specifies the index of the generic vertex attribute to be modified.</li> <li><code>int</code> <code>$size</code> Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.</li> <li><code>int</code> <code>$type</code> Specifies the data type of each component in the array. The symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE, GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.</li> <li><code>bool</code> <code>$normalized</code> For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed.</li> <li><code>int</code> <code>$stride</code> Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0.</li> <li><code>int</code> <code>$offset</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexAttribPointer.html"},{"title":"glVertexP2ui","text":"<p>glVertexP2ui</p> <pre><code>function glVertexP2ui(int $type, int $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$type</code> </li> <li><code>int</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexP2ui.html"},{"title":"glVertexP2uiv","text":"<p>glVertexP2uiv</p> <pre><code>function glVertexP2uiv(int $type, \\GL\\Buffer\\UIntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$type</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexP2uiv.html"},{"title":"glVertexP3ui","text":"<p>glVertexP3ui</p> <pre><code>function glVertexP3ui(int $type, int $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$type</code> </li> <li><code>int</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexP3ui.html"},{"title":"glVertexP3uiv","text":"<p>glVertexP3uiv</p> <pre><code>function glVertexP3uiv(int $type, \\GL\\Buffer\\UIntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$type</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexP3uiv.html"},{"title":"glVertexP4ui","text":"<p>glVertexP4ui</p> <pre><code>function glVertexP4ui(int $type, int $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$type</code> </li> <li><code>int</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexP4ui.html"},{"title":"glVertexP4uiv","text":"<p>glVertexP4uiv</p> <pre><code>function glVertexP4uiv(int $type, \\GL\\Buffer\\UIntBuffer|array $value) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$type</code> </li> <li><code>\\GL\\Buffer\\UIntBuffer|array</code> <code>$value</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glVertexP4uiv.html"},{"title":"glViewport","text":"<p>set the viewport</p> <pre><code>function glViewport(int $x, int $y, int $width, int $height) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$x</code> Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).</li> <li><code>int</code> <code>$y</code> </li> <li><code>int</code> <code>$width</code> Specify the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window.</li> <li><code>int</code> <code>$height</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glViewport.html"},{"title":"glViewportArrayv","text":"<p>glViewportArrayv</p> <pre><code>function glViewportArrayv(int $first, \\GL\\Buffer\\FloatBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$first</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glViewportArrayv.html"},{"title":"glViewportIndexedf","text":"<p>glViewportIndexedf</p> <pre><code>function glViewportIndexedf(int $index, float $x, float $y, float $w, float $h) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>float</code> <code>$x</code> </li> <li><code>float</code> <code>$y</code> </li> <li><code>float</code> <code>$w</code> </li> <li><code>float</code> <code>$h</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glViewportIndexedf.html"},{"title":"glViewportIndexedfv","text":"<p>glViewportIndexedfv</p> <pre><code>function glViewportIndexedfv(int $index, \\GL\\Buffer\\FloatBuffer|array $v) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$index</code> </li> <li><code>\\GL\\Buffer\\FloatBuffer|array</code> <code>$v</code> </li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glViewportIndexedfv.html"},{"title":"glWaitSync","text":"<p>instruct the GL server to block until the specified sync object becomes signaled</p> <pre><code>function glWaitSync(int $sync, int $flags, int $timeout) : void\n</code></pre>  arguments  <ol> <li><code>int</code> <code>$sync</code> Specifies the sync object whose status to wait on.</li> <li><code>int</code> <code>$flags</code> A bitfield controlling the command flushing behavior. flags may be zero.</li> <li><code>int</code> <code>$timeout</code> Specifies the timeout that the server should wait before continuing. timeout must be GL_TIMEOUT_IGNORED.</li> </ol>  returns  <p><code>void</code> </p>     <p>Copyright \u00a9 2010-2014 Khronos Group</p> <p>This material may be distributed subject to the terms and conditions set forth in the Open Publication License, v 1.0, 8 June 1999. https://opencontent.org/openpub/.</p>","location":"API/OpenGL/glWaitSync.html"},{"title":"Texture2D","text":"<p>The Texture2D class is part of the PHP-GLFW OpenGL extension. It loads images / textures from common formats like PNG, JPG, GIF, BMP, TGA etc. and converts the raw bitmap to a <code>GL\\UByteBuffer</code> instance. The <code>GL\\UByteBuffer</code> instance can be uploaded to the GPU using the <code>glTexImage2D</code> function.</p> <pre><code>namespace GL\\Texture\n{\n    class Texture2D {}\n}\n</code></pre>","location":"API/Texture/Texture2D.html"},{"title":"Usage","text":"<p>A very basic example of loading a file from disk and printing its metadata. Then creating A GPU texture and uploading the image data to the GPU.</p> <pre><code>// loading an image from disk (1024x1024)\n$textureData = Texture2D::fromDisk(__DIR__ . '/picture.png');\n\necho $textureData-&gt;width(); // prints: 1024\necho $textureData-&gt;height(); // prints: 1024\necho $textureData-&gt;channels(); // prints: 4\n\n// create &amp; upload the texture on the GPU\nglGenTextures(1, $texture);\nglBindTexture(GL_TEXTURE_2D, $texture);\nglTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, $textureData-&gt;width(), $textureData-&gt;height(), 0, GL_RGBA, GL_UNSIGNED_BYTE, $textureData-&gt;buffer());\n</code></pre> <p>Read more about the <code>glTexImage2D</code> function to learn about the arguments.</p>","location":"API/Texture/Texture2D.html#usage"},{"title":"Methods","text":"","location":"API/Texture/Texture2D.html#methods"},{"title":"<code>fromDisk</code>","text":"<p>Loads a texture / image from a file on disk and returns a Texture2D object.</p> <pre><code>static function fromDisk(string $path) : \\GL\\Texture\\Texture2D\n</code></pre>  arguments  <ol> <li><code>string</code> <code>$file</code> The path to the image file to load.</li> </ol>  returns  <p><code>\\GL\\Texture\\Texture2D</code> The loaded texture object.</p>","location":"API/Texture/Texture2D.html#fromdisk"},{"title":"<code>fromBuffer</code>","text":"<p>Loads a texture / image from a buffer and returns a Texture2D object.</p> <pre><code>static function fromBuffer(int $width, int $height, \\GL\\Buffer\\UByteBuffer $buffer, int $channels = \\GL\\Texture\\Texture2D::CHANNEL_RGBA) : \\GL\\Texture\\Texture2D\n</code></pre> <p>The buffer is not copied, the Texture2D object will hold a reference to the buffer given.</p>","location":"API/Texture/Texture2D.html#frombuffer"},{"title":"<code>width</code>","text":"<p>Returns the width of the image.</p> <pre><code>function width() : int\n</code></pre>  returns  <p><code>int</code> The width of the image.</p>","location":"API/Texture/Texture2D.html#width"},{"title":"<code>height</code>","text":"<p>Returns the height of the image.</p> <pre><code>function height() : int\n</code></pre>  returns  <p><code>int</code> The height of the image.</p>","location":"API/Texture/Texture2D.html#height"},{"title":"<code>channels</code>","text":"<p>Returns the number of channels of the image.</p> <pre><code>function channels() : int\n</code></pre>  returns  <p><code>int</code> The number of channels of the image.</p>","location":"API/Texture/Texture2D.html#channels"},{"title":"<code>buffer</code>","text":"<p>Returns a reference to the internal <code>UByteBuffer</code> instance of the current texture.</p> <pre><code>function buffer() : \\GL\\Buffer\\UByteBuffer\n</code></pre>  returns  <p><code>\\GL\\UByteBuffer</code> The loaded image data.</p>","location":"API/Texture/Texture2D.html#buffer"},{"title":"<code>writeJPG</code>","text":"<p>Writes the image data to a file on disk. (JPEG)</p> <pre><code>function writeJPG(string $path, int $quality = 100) : void\n</code></pre>  arguments  <ol> <li><code>string</code> <code>$file</code> The path to the file to write to.</li> <li><code>int</code> <code>$quality</code> The quality of the image. (0 - 100)</li> </ol>  returns  <p><code>void</code> </p>","location":"API/Texture/Texture2D.html#writejpg"},{"title":"<code>writePNG</code>","text":"<p>Writes the image data to a file on disk. (PNG)</p> <pre><code>function writePNG(string $path) : void\n</code></pre>  arguments  <ol> <li><code>string</code> <code>$file</code> The path to the file to write to.</li> </ol>","location":"API/Texture/Texture2D.html#writepng"},{"title":"<code>writeBMP</code>","text":"<p>Writes the image data to a file on disk. (BMP)</p> <pre><code>function writeBMP(string $path) : void\n</code></pre>  arguments  <ol> <li><code>string</code> <code>$file</code> The path to the file to write to.</li> </ol>","location":"API/Texture/Texture2D.html#writebmp"},{"title":"<code>writeTGA</code>","text":"<p>Writes the image data to a file on disk. (TGA)</p> <pre><code>function writeTGA(string $path) : void\n</code></pre>  arguments  <ol> <li><code>string</code> <code>$file</code> The path to the file to write to.</li> </ol>","location":"API/Texture/Texture2D.html#writetga"},{"title":"docs-assets","text":"<p>This repository is used to store the PHP-GLFW and VISU documentation assets. To not bloat the main repos.</p>","location":"docs-assets/index.html"},{"title":"About the examples","text":"<p>In this section you will find a collection of examples that demonstrate how to use PHP-GLFW. The examples are organized in a way that you can follow the progression of the examples and learn more about the library.</p>","location":"examples/00-about-examples.html"},{"title":"OpenSource Projects","text":"<ul> <li> <p>PHP CHIP-8</p>  <p></p> </li> <li> <p>Flappyphant</p>  <p></p> </li> </ul>","location":"examples/00-about-examples.html#opensource-projects"},{"title":"Basic examples","text":"<ul> <li> <p>1. Basic triangle</p>  <p></p> </li> <li> <p>2. Basic cube</p>  <p></p> </li> <li> <p>3. Textured cube</p>  <p></p> </li> <li> <p>4. Instancing</p>  <p></p> </li> <li> <p>5. Obj file loader</p>  <p> </p> </li> <li> <p>6. Simple lighting</p>  <p></p> </li> <li> <p>7. Text rendering</p>  <p></p> </li> <li> <p>8. Input &amp; Events</p>  <p></p> </li> </ul>","location":"examples/00-about-examples.html#basic-examples"},{"title":"Vector Graphics examples","text":"","location":"examples/00-about-examples.html#vector-graphics-examples"},{"title":"Color","text":"<ul> <li> <p>Color Constants</p>  <p></p> </li> <li> <p>Color Lightness</p>  <p></p> </li> </ul>","location":"examples/00-about-examples.html#color"},{"title":"Fun","text":"<ul> <li> <p>Visaulizing Bitshifting</p>  <p></p> </li> <li> <p>Plotting primes</p>  <p></p> </li> <li> <p>Genetic Car Pathfinding</p>  <p></p> </li> </ul>","location":"examples/00-about-examples.html#fun"},{"title":"Gradients","text":"<ul> <li> <p>Linear Gradient</p>  <p></p> </li> <li> <p>Radial Gradient</p>  <p></p> </li> <li> <p>Gradient Wave</p>  <p></p> </li> </ul>","location":"examples/00-about-examples.html#gradients"},{"title":"Images","text":"<ul> <li> <p>Image Filtering</p>  <p></p> </li> <li> <p>Image Repetition</p>  <p></p> </li> <li> <p>Image Rotation</p>  <p></p> </li> </ul>","location":"examples/00-about-examples.html#images"},{"title":"Input","text":"<ul> <li> <p>Joystick Input</p>  <p></p> </li> </ul>","location":"examples/00-about-examples.html#input"},{"title":"Noise","text":"<ul> <li> <p>Noise explorer</p>  <p></p> </li> <li> <p>Noise Grid</p>  <p></p> </li> </ul>","location":"examples/00-about-examples.html#noise"},{"title":"Text","text":"<ul> <li> <p>Text Alignment</p>  <p></p> </li> <li> <p>Text Boxes</p>  <p></p> </li> <li> <p>Colored Words</p>  <p></p> </li> <li> <p>Text with Shadow</p>  <p></p> </li> </ul>","location":"examples/00-about-examples.html#text"},{"title":"Advanced examples","text":"<ul> <li> <p>10. Sponza Scene</p>  <p></p> </li> </ul>","location":"examples/00-about-examples.html#advanced-examples"},{"title":"Basic triangle","text":"<p>This is the most basic example of how to use the GLFW library. You can think of it as a \"Hello World\" example. In this example, we create a window and render a triangle.</p> <p>This example does not utilize our helper class to keep it as basic as possible.</p>  <p> </p> A triangle drawn with OpenGL in PHP   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/01_triangle.php\n</code></pre>","location":"examples/opengl/01-tirangle.html"},{"title":"Basic 3D Cube","text":"<p>This example shows how to render a 3D cube using PHP OpenGL.</p>  <p> </p> A 3D Cube drawn with OpenGL in PHP   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/02_3D_cube.php\n</code></pre>","location":"examples/opengl/02-3d-cube.html"},{"title":"Textued 3D Cube","text":"<p>This example shows how to render a textured cube using PHP OpenGL. It provides an example of how to load a texture from a file and how to use it in a shader using the PHP-GLFW <code>GL\\Texture\\Texture2D</code> class.</p>  <p> </p> A textued 3D Cube drawn with OpenGL in PHP   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/03_textured_cube.php\n</code></pre>","location":"examples/opengl/03-textured-cube.html"},{"title":"Basic Instancing","text":"<p>This example shows how to render multiple instances of a single object using PHP OpenGL. It is just a basic example of how to use instanced rendering.</p>  <p> </p> OpenGL instancing in PHP   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/04_instancing.php\n</code></pre>","location":"examples/opengl/04-instacing.html"},{"title":"Object file loading","text":"<p>This example shows how to load a 3D object from a wavefront <code>.obj</code> file using PHP OpenGL. It displays how to utilize the <code>\\GL\\Geometry\\ObjFileParser</code> class to load a 3D object from a file and how to render it.</p>  <p> </p> Loading a .obj file in PHP   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/05_objloading.php\n</code></pre> <pre><code>--------------------------------------------------------------------------------\n-&gt; Press ESC to close the window\n-&gt; Press W to toggle wireframe mode\n--------------------------------------------------------------------------------\n</code></pre>","location":"examples/opengl/05-object-file-loading.html"},{"title":"Simple lighting","text":"<p>This example shows how to render a 3D object with simple lighting using PHP OpenGL. </p>  <p> </p> Basic lighting with OpenGL in PHP   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/06_basic_light.php\n</code></pre> <pre><code>--------------------------------------------------------------------------------\n-&gt; Use the mouse to rotate the object\n-&gt; Press ESC to close the window\n-&gt; Press W to toggle wireframe mode\n--------------------------------------------------------------------------------\n</code></pre>","location":"examples/opengl/06-basic-lighting.html"},{"title":"Text Rendering","text":"<p>This example shows how to render text using PHP OpenGL. It uses a simple bitmap font to render text on the screen.</p>  <p>Note</p> <p>This example shows how to implement text rendering with OpenGL from scratch. In most cases you want to use the  VectorGraphics API to render text. See the VectorGraphics Text Rendering.</p>   <p> </p> Text rendering with OpenGL in PHP   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/07_text_rendering.php\n</code></pre>","location":"examples/opengl/07-text-rendering.html"},{"title":"Input &amp; Events","text":"<p>This example shows how to handle input and events using PHP OpenGL. It implements all available input and window event callbacks and prints them to the console.</p>  <p> </p> Input and events with OpenGL in PHP   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/08_input_and_events.php\n</code></pre>","location":"examples/opengl/08-input-and-events.html"},{"title":"Sponza","text":"<p>This example loads and renders the Crytek Sponza sample. If you are familiar with rendering and game engine development you probably saw this model before. It is a very popular model for testing rendering techniques and performance.</p>     <p> </p> Sponza with OpenGL in PHP   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/10_sponza_scene.php\n</code></pre>","location":"examples/opengl/10-sponza.html"},{"title":"Color Constants","text":"<p>This example shows all the available color constants.</p>  <p></p>   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/vg/color_constants.php\n</code></pre>","location":"examples/vector-graphics/color_constants.html"},{"title":"Color Lightness","text":"<p>This example shows conversion between RGB and HLS color space and how to lighten and darken a color.</p>  <p></p>   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/vg/color_lightness.php\n</code></pre>","location":"examples/vector-graphics/color_lightness.html"},{"title":"Visaulizing Bitshifting","text":"<p>The first time you saw \"&gt;&gt;\" or \"&lt;&lt;\" in a programming language, you probably wondered WTF is this?  Or at least I did. The concept is actually quite simple, but it's hard to grasp at first.  Visaualizing it helps and allowing to play around with it helps a lot.</p>  <p></p>   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/vg/fun_bitshifting.php\n</code></pre> <p>Controls:</p> <ul> <li>Click on a bit to toggle it</li> <li>Click on the &lt;&lt; and &gt;&gt; buttons to shift the bits</li> <li>Click on the button on the top to set the number to a constant</li> </ul>","location":"examples/vector-graphics/fun_bitshifting.html"},{"title":"Plotting primes","text":"<p>Prime numbers are a fascinating! This example will plot the prime numbers in a grid.</p>  <p></p>   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/vg/fun_primes_1_full.php\n</code></pre> <p>Controls:</p> <ul> <li>Space: Toggle the plotting process on or off.</li> <li>R: Reset the plotting to its initial state, including the prime number sequence, view width, view height, zoom level, and offsets.</li> <li>Q / E: Decrease / Increase the view width. This will rebuild the framebuffer and resume plotting.</li> <li>A / D: Decrease / Increase the view height. This will rebuild the framebuffer and resume plotting.</li> <li>Scroll: Zoom in or out on the plot. Zooming is centered around the current view.</li> <li>Left Mouse Button (Drag): Click and drag to move the plot offset, allowing you to pan around the plotted area.</li> </ul>","location":"examples/vector-graphics/fun_primes_1_full.html"},{"title":"Linear Gradient","text":"<p>This PHP GLFW Vector Graphics example show how to create a linear gradient and apply it to a rectangle.</p>  <p></p>   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/vg/gradient_linear.php\n</code></pre>","location":"examples/vector-graphics/gradient_linear.html"},{"title":"Radial Gradient","text":"<p>This example demonstrates how to draw a radial gradient using the PHP GLFW Vector Graphics API.</p>  <p></p>   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/vg/gradient_radial.php\n</code></pre>","location":"examples/vector-graphics/gradient_radial.html"},{"title":"Gradient Wave","text":"<p>This PHP GLFW Vector Graphics example shows how a gradient paint can be applied over multiple shapes. In this case we are drawing a wave of circles with a linear gradient applied to them.</p>  <p></p>   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/vg/gradient_wave.php\n</code></pre>","location":"examples/vector-graphics/gradient_wave.html"},{"title":"Image Filtering","text":"<p>This exmaple show cases how to use the different image filtering options available in the PHP GLFW Vector Graphics API.</p>  <p></p>   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/vg/images_filtering.php\n</code></pre>","location":"examples/vector-graphics/images_filtering.html"},{"title":"Image Repetition","text":"<p>This example showcases how to use the different image repetition options available in the PHP GLFW Vector Graphics API.</p>  <p></p>   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/vg/images_repeating.php\n</code></pre>","location":"examples/vector-graphics/images_repeating.html"},{"title":"Image Rotation","text":"<p>This example showcases how an image can be rotated using the PHP GLFW Vector Graphics API.</p>  <p></p>   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/vg/images_texture_rotation.php\n</code></pre>","location":"examples/vector-graphics/images_texture_rotation.html"},{"title":"Joystick Input","text":"<p>Example showcasing how to access a joystick or gamepad / controller using PHP.</p>  <p></p>   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/vg/input_joystick.php\n</code></pre>","location":"examples/vector-graphics/input_joystick.html"},{"title":"Genetic Car Pathfinding","text":"<p>Genetic algorithms are aweomse, to be fair they are quite close to just brute forcing a solution but they work and most importantly they are fun to watch. Also they are easy to understand and implement.</p>  <p></p>   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/vg/ml_genetic_cars.php\n</code></pre>  <p>Note</p> <pre><code> It would be an easy fix, but im lazy. Sometimes a obstacle will spawn where the cars spawn and they will die instantly. \n Just restart the simulation if that happens.\n</code></pre>  <p>Controls:</p> <ul> <li>Space: Toggle VSync on or off. The simulation will just run as fast as possible when VSync is off.</li> <li>D: Toggle display labels on or off. Labels provide additional information about the cars in the simulation.</li> <li>B: Toggle rendering mode between all cars and only the best-performing car.</li> <li>P: Dump the instructions of the best-performing car. This outputs the specific instructions that guide the car's behavior.</li> </ul>","location":"examples/vector-graphics/ml_genetic_cars.html"},{"title":"Noise explorer","text":"<p>A simple example that demonstrates how to use the noise functions, and how they look like.</p>  <p></p>   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/vg/noise_explorer.php\n</code></pre>","location":"examples/vector-graphics/noise_explorer.html"},{"title":"Noise Grid","text":"<p>Just a simple &amp; fun visual effect that can be achieved with noise functions.</p>  <p></p>   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/vg/noise_grid.php\n</code></pre>","location":"examples/vector-graphics/noise_grid.html"},{"title":"Text Alignment","text":"<p>This interactive example shows how to align text horizontally and vertically.</p>  <p></p>   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/vg/text_alignment.php\n</code></pre>","location":"examples/vector-graphics/text_alignment.html"},{"title":"Text Boxes","text":"<p>This interactive example shows how text boxes can used to render multi-line text.</p>  <p></p>   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/vg/text_boxes.php\n</code></pre>","location":"examples/vector-graphics/text_boxes.html"},{"title":"Colored Words","text":"<p>This examples demonstrates how to render a sentence with each word having a different color. To  achieve this we have to draw each word separately.</p>  <p></p>   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/vg/text_color_words.php\n</code></pre>","location":"examples/vector-graphics/text_color_words.html"},{"title":"Text with Shadow","text":"<p>This example shows how to render text with a shadow. Which acutally is just a blurred version of the text rendered behind the actual text.</p>  <p></p>   <p>Check out the Code</p>  <p>Run this example:</p> <pre><code>php examples/vg/text_intro.php\n</code></pre>","location":"examples/vector-graphics/text_intro.html"},{"title":"Using textures","text":"","location":"getting-started/04_drawing_textures.html"},{"title":"Rendering a 3D cube","text":"","location":"getting-started/05_rendering-a-cube.html"},{"title":"Drawing a Triangle","text":"<p>Now things start to get a bit more interesting and we are going to draw our first triangle. We will use the same window from the previous example, so make sure you have that running.</p>  <p> </p> Trinagle drawn in OpenGL with PHP   <p>Full Source</p> <p>This getting started tutorial is based on the examples provided with PHP-GLFW. You can check out the complete source code here: 01_triangle.php</p>","location":"getting-started/drawing_a_triangle.html"},{"title":"Why a Triangle?","text":"<p>Why draw a triangle? Well, it's the simplest geometry you can draw and it's a good starting point to get familiar with the rendering pipeline. I honestly was kinda blown away when I realized that every object/model/mesh could be represented as a collection of triangles. (That sentence is going to make a few math people mad) but let me explain.</p> <p>A square is made up of two triangles. A cube is made up of six squares, and so on. So if you can draw a triangle, you can draw anything. (Well, almost anything...)</p> <p></p> <p>My next level drawing skills besides, lets talk about the rendering pipeline.</p>","location":"getting-started/drawing_a_triangle.html#why-a-triangle"},{"title":"The Rendering Pipeline","text":"<p>The rendering pipeline simplified, is a series of steps that are executed to transform a 3D model into a 2D image that can be displayed on the screen. The OpenGL pipeline in this example is divided into two parts, the vertex processing and fragment processing. There are many more steps/stages which we will not cover here to keep things simple. (If you are interested, you can read more about it here)</p> <p>Each of these steps/stages is performed by a shader, a small program executed on the GPU. The vertex shader is executed for each vertex (point) in the your geometry, and the fragment shader is executed for each pixel on the screen.</p> <p></p> <p>Some of these shaders can be programmed by the user. The GPU driver handles others. Shaders are written in a language called GLSL, which is a C-like language with some extensions to make it easier to write shaders.</p> <p>In PHP-GLFW (PHP OpenGL) you still write your shaders in GLSL. We could have written a transpiler of some sort to convert PHP to GLSL, but that would have been a lot of work and would have made the library a lot more complex, and I also believe it would ultimately defeat the purpose. </p>","location":"getting-started/drawing_a_triangle.html#the-rendering-pipeline"},{"title":"Vertex Arrays (VAO and VBO)","text":"<p>In order to draw a triangle, we need to define the vertices that make up the triangle. A vertex array is not necessarily just an array of vertex positions. It can also contain other information such as color, texture coordinates, normals, etc. </p> <p>Note the vertex array object (VAO) does not directly store the vertices. It holds the state of the vertex array. For example, the VAO stores the vertex attribute configuration, which tells the GPU how to interpret the vertex data. The actual vertex data is stored in the vertex buffer object (VBO), which is really just a blob of data.</p> <pre><code>// create a vertex array (VertextArrayObject -&gt; VAO)\nglGenVertexArrays(1, $VAO);\n\n// create a buffer for our vertices (VertextBufferObject -&gt; VBO)\nglGenBuffers(1, $VBO);\n\n// bind the buffer to our VAO \nglBindVertexArray($VAO);\nglBindBuffer(GL_ARRAY_BUFFER, $VBO);\n</code></pre> <p>So what is happing here? We are creating a vertex array object (VAO) using the <code>glGenVertexArrays</code> function. We are also creating a buffer for our vertices using the <code>glGenBuffers</code> function. Using the <code>glBindVertexArray</code> and <code>glBindBuffer</code> functions we are binding the buffer (VBO) and our vertex array object (VAO) to the current context.</p>","location":"getting-started/drawing_a_triangle.html#vertex-arrays-vao-and-vbo"},{"title":"Uploading the vertex data","text":"<p>PHP-GLFW provides a few helper classes to make it easier to upload data to the GPU. PHP unfortunately, does not have built-in tools to work with \"real\" arrays of data (like C/C++). So this extension comes with custom buffer classes that can be used to upload data to the GPU \"directly\".</p> <p>So let's declare our triangle vertices and upload them to the GPU using <code>glBufferData</code>.</p> <pre><code>$buffer = new \\GL\\Buffer\\FloatBuffer([ # (1)!\n   // positions     // colors\n   0.5, -0.5, 0.0,  1.0, 0.0, 0.0,  // bottom right\n  -0.5, -0.5, 0.0,  0.0, 1.0, 0.0,  // bottom left\n   0.0,  0.5, 0.0,  0.0, 0.0, 1.0   // top \n]);\n\nglBufferData(GL_ARRAY_BUFFER, $buffer, GL_STATIC_DRAW);\n</code></pre> <ol> <li>The FloatBuffer class is just one of many buffer helpers.     Also available are:<ul> <li>ByteBuffer</li> <li>UByteBuffer</li> <li>ShortBuffer</li> <li>UShortBuffer</li> <li>IntBuffer</li> <li>UIntBuffer</li> <li>FloatBuffer</li> <li>HFloatBuffer</li> <li>DoubleBuffer</li> </ul> </li> </ol> <p>But what does the data actually mean? If not clear from the code here a visual representation of the data.</p> <p></p>","location":"getting-started/drawing_a_triangle.html#uploading-the-vertex-data"},{"title":"Vertex attribute pointers","text":"<p>We now know how that buffer data is to be interpreted, but we still need to tell the GPU how to interpret the data. We do this by setting the vertex attribute pointers using the <code>glVertexAttribPointer</code> function.</p> <p>A vertex attribute pointer consists of 3 central values to allow the GPU to iterate over your vertex data. Lets assume a type uniform vertex buffer for now:</p> <ul> <li><code>size</code> - The number of components per vertex attribute</li> <li><code>stride</code> - The offset between consecutive vertex attributes</li> <li><code>offset</code> - The offset of the first component of the vertex attribute</li> </ul> <p></p> <p>Now in practice the <code>glVertexAttribPointer</code> function is declared like this:</p> <pre><code>function glVertexAttribPointer(\n  int $index,      // Specifies the index of the generic vertex attribute to be modified.\n  int $size,       // Specifies the number of components\n  int $type,       // Specifies the data type of each component\n  bool $normalized,// Specifies whether fixed-point data values should be normalized\n  int $stride,     // Specifies the byte offset between consecutive generic vertex attributes\n  int $offset      // Specifies a offset of the first component of the first generic vertex attribute \n) : void\n</code></pre> <p>In case of our triangle we have 6 components per vertex. The first 3 components are the position of the vertex and the last 3 components are the color of the vertex.</p> <pre><code>// positions\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, GL_SIZEOF_FLOAT * 6, 0);\nglEnableVertexAttribArray(0);\n\n// colors\nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, GL_SIZEOF_FLOAT * 6, GL_SIZEOF_FLOAT * 3);\nglEnableVertexAttribArray(1);\n</code></pre> <p><code>$stride</code> and <code>$offset</code> expects the number of bytes. PHP-GLFW exposes the size of the data types as constants. For example <code>GL_SIZEOF_FLOAT</code> is the size of a float in bytes. So you can simply multiply the number of components by the size of the data type to get the stride.</p> <p>I know you probably did not expect a simple triangle to be so complicated. But this is the bare minimum you need to know to get started with OpenGL. In the next section we will look at the shaders.</p>","location":"getting-started/drawing_a_triangle.html#vertex-attribute-pointers"},{"title":"Shaders","text":"<p>As we already touch on in the rendering pipeline, we need to cover two shading stages to render a triangle. The vertex shader and the fragment shader. The vertex shader is responsible for transforming the vertices into clip space. The fragment shader is responsible for calculating the color of each pixel.</p>","location":"getting-started/drawing_a_triangle.html#shaders"},{"title":"Vertex Shader","text":"<p>The vertex shader is used to transform the input vertices from the vertex buffer object into clip space. This means transforming vertices from 3D space to 2D space, by multiplying them by our projection and view matrix. The output of the vertex shader is the position of the vertex on the screen, as a point in the normalized device coordinates (NDC) space. (i.e., values between -1 and 1).</p> <pre><code>#version 330 core\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 color;\n\nout vec4 pcolor;\n\nvoid main()\n{\n    pcolor = vec4(color, 1.0f);\n    gl_Position = vec4(position, 1.0f);\n}\n</code></pre> <p>In the above example, we define our vertex shader to expect a vertex position using <code>layout (location = 0) in vec3 position;</code> and a color using <code>layout (location = 1) in vec3 color;</code>. We then take that <code>position</code> and set it as the <code>gl_Position</code>. That's it. No fancy math. You can do fancy math in the vertex shader, but we are keeping things simple here. </p> <p>This <code>gl_Position</code> is how we tell OpenGL where our vertex is in clip space. </p> <p>Also notice the <code>out vec4 pcolor;</code> to pass the color from the vertex shader to the fragment shader. We will cover this in the next section.</p>","location":"getting-started/drawing_a_triangle.html#vertex-shader"},{"title":"Fragment Shader","text":"<p>The fragment shader takes as input <code>pcolor</code> which represents the color of the current pixel (which we output from the vertex shader), and outputs the final pixel color.</p> <pre><code>#version 330 core\n\nout vec4 fragment_color;\nin vec4 pcolor;\n\nvoid main()\n{\n    fragment_color = pcolor;\n} \n</code></pre> <p>Again, not much happening here, we just set the <code>fragment_color</code> to the <code>pcolor</code> we got from the vertex shader.</p>","location":"getting-started/drawing_a_triangle.html#fragment-shader"},{"title":"Compiling the shaders","text":"<p>To make use of the shaders we need to compile and link them to a shader program. This requires a few steps:</p> <ol> <li>Create a shader program</li> <li>Create a vertex shader</li> <li>Compile the vertex shader</li> <li>Create a fragment shader</li> <li>Compile the fragment shader</li> <li>Attach the vertex shader to the shader program</li> <li>Attach the fragment shader to the shader program</li> <li>Link the shader program   </li> </ol> <p>In this example we just define the shader source code as strings. In most applications I worked on we built a system to compile the shaders from the filesystem with an include system etc.. But for this example we will keep it simple.</p> <pre><code>$vertexShaderSource =  &lt;&lt;&lt; 'GLSL'\n#version 330 core\nlayout (location = 0) in vec3 position;\nlayout (location = 1) in vec3 color;\nout vec4 pcolor;\nvoid main()\n{\n    pcolor = vec4(color, 1.0f);\n    gl_Position = vec4(position, 1.0f);\n}\nGLSL;\n\n$fragmentShaderSource = &lt;&lt;&lt; 'GLSL'\n#version 330 core\nout vec4 fragment_color;\nin vec4 pcolor;\nvoid main()\n{\n    fragment_color = pcolor;\n} \nGLSL;\n</code></pre> <p>To create a new shader program we use the <code>glCreateProgram</code> function. This function returns a handle to the shader program. We will use this handle to attach the shaders.</p> <pre><code>$shaderProgram = glCreateProgram(); // 1. \n</code></pre> <p>Next we need to create the vertex shader, load the source code into it and compile it.</p> <pre><code>// create, upload and compile the vertex shader\n$vertexShader = glCreateShader(GL_VERTEX_SHADER); // 2.\nglShaderSource($vertexShader, $vertexShaderSource);\nglCompileShader($vertexShader); // 3.\n</code></pre> <p>OpenGL by itself does not throw any exceptions or erros and as we try to stay close to the original API this holds true for PHP-GLFW as well. So we need to check for errors ourselves. We do this by calling <code>glGetShaderiv</code> to get the compile status of the shader. If the compile status is not <code>true</code> we throw an exception.</p> <pre><code>// check for errors\nglGetShaderiv($vertexShader, GL_COMPILE_STATUS, $success);\nif (!$success) {\n    throw new Exception(\"Vertex shader could not be compiled.\");\n}\n</code></pre> <p>For the fragment shader we repeat the same steps as for the vertex shader.</p> <pre><code>// create, upload and compile the fragment shader\n$fragShader = glCreateShader(GL_FRAGMENT_SHADER); // 4.\nglShaderSource($fragShader, $fragmentShaderSource);\nglCompileShader($fragShader); // 5.\n\n// check for errors\nglGetShaderiv($fragShader, GL_COMPILE_STATUS, $success);\nif (!$success) {\n    throw new Exception(\"Fragment shader could not be compiled.\");\n}\n</code></pre> <p>Now we just need to attach the shaders to the shader program and link it.</p> <pre><code>// attach the shaders to the shader program and link it\nglAttachShader($shaderProgram, $vertexShader); // 6.\nglAttachShader($shaderProgram, $fragShader); // 7.\nglLinkProgram($shaderProgram); // 8.\n\n// check for errors\nglGetProgramiv($shaderProgram, GL_LINK_STATUS, $linkSuccess);\nif (!$linkSuccess) {\n    throw new Exception(\"Shader program could not be linked.\");\n}\n</code></pre> <p>Thats it now we can use the shader with the <code>glUseProgram</code> function to draw our triangle.</p>","location":"getting-started/drawing_a_triangle.html#compiling-the-shaders"},{"title":"Note on VISU","text":"<p>To simplify the handling of shaders, it is recommended to abstract the necessary steps. Shader handling can often become complex and cumbersome otherwise. For this purpose, the VISU Framework offers a range of abstractions for tasks such as shader loading, handling, and compiling, as exemplified by the ShaderProgram class.</p>","location":"getting-started/drawing_a_triangle.html#note-on-visu"},{"title":"Draw loop","text":"<p>Similar to the previous example \"Window Creation\" we need to create a draw loop. The draw loop is the main loop of our application. It is responsible for rendering the scene and handling user input. </p> <p>Here is the draw loop for our triangle example:</p> <pre><code>while (!glfwWindowShouldClose($window))\n{\n     // setting the clear color to black and clearing the color buffer\n    glClearColor(0, 0, 0, 1);\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    // use the shader, will active the given shader program\n    // for the coming draw calls.\n    glUseProgram($shaderProgram);\n\n    // bind &amp; draw the vertex array\n    glBindVertexArray($VAO);\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n\n    // swap the windows framebuffer and\n    // poll queued window events.\n    glfwSwapBuffers($window);\n    glfwPollEvents();\n}\n</code></pre> <p>Now in details what do these new lines of code do?</p> <pre><code>glUseProgram($shaderProgram);\n</code></pre> <p>The <code>glUseProgram</code> function activates the given shader program. This means that all draw calls after this function will use the given shader program. Again OpenGL is a state machine and we are responsible for setting the correct state. </p> <pre><code>glBindVertexArray($VAO);\n</code></pre> <p>The <code>glBindVertexArray</code> function binds the given vertex array object. This means that all draw calls after this function will use the given vertex array object. This vertex array contains our triangle vertices and colors if you rember.</p> <pre><code>glDrawArrays(GL_TRIANGLES, 0, 3);\n</code></pre> <p>The <code>glDrawArrays</code> function then instructs OpenGL to draw the vertices as triangles. The first parameter is the primitive type, in this case triangles. The second parameter is the starting index of the vertex array and the third parameter is the number of vertices we want to draw.</p>","location":"getting-started/drawing_a_triangle.html#draw-loop"},{"title":"Full Source Code","text":"<p>The full source code can be found here: 01_triangle.php</p>","location":"getting-started/drawing_a_triangle.html#full-source-code"},{"title":"Additional resources","text":"<ol> <li>https://www.khronos.org/opengl/wiki/Vertex_Specification</li> <li>http://www.opengl-tutorial.org/beginners-tutorials/tutorial-2-the-first-triangle/</li> <li>https://learnopengl.com/Getting-started/Hello-Triangle</li> </ol>","location":"getting-started/drawing_a_triangle.html#additional-resources"},{"title":"Getting Started with PHP &amp; OpenGL","text":"<p>This getting started guide is not specifically just about PHP-GLFW. I also try to explain some basics about OpenGL and how to use it with PHP. So see this more as a Tutorial to learn OpenGL with PHP. Or an OpenGL crash course in PHP.</p>  <ul> <li> <p> Install in 5 minutes</p>  <p>If you haven't installed PHP-GLFW yet, follow the installation guide for your platform.</p> <p> Installation Linux</p> <p> Installation MacOS</p> <p> Installation Windows</p> </li> <li> <p> PHP OpenGL Tutorial</p>  <p></p> <p>Everything ready to get started? Jump right into the first chapter of the tutorial.</p> <p> Getting Started (Create Window)</p> </li> </ul>","location":"getting-started/getting-started-with-php-and-opengl.html"},{"title":"PHP Vector Graphics API","text":"<p>Are you looking for the HTML Canvas inspired API for PHP? Check out the PHP Vector Graphics API.</p>  <ul> <li> <p> Getting Started with VG</p>  <p></p> <p>Want to learn how to use the vector graphics API? Check out our getting started guide.</p> <p> Getting Started</p> </li> <li> <p> Fun PHP VG Examples</p>  <p></p> <p>We craftet a ton of interactive examples to play around with. Check them out!</p> <p> Vector Graphics Examples</p> </li> </ul>","location":"getting-started/getting-started-with-php-and-opengl.html#php-vector-graphics-api"},{"title":"What is OpenGL?","text":"<p>Imagine you want to build a chair. Where would you begin?</p> <p>You could start by planting a tree, waiting for it to grow, and then using a rock to chop it down. From there, you could carve wooden tools out of the tree stump then... ok, you get where im getting at.</p> <p>We could also not start from zero. (Ignoring the fact that you could take this game much further...) </p> <p>Realistically, you would likely use some pre-made tools, equipment, and perhaps some pre-cut wooden planks to build a simple chair.</p> <p>The same concept applies here. Think of OpenGL as a set of basic tools that allow you to work with your material, which in this case is the GPU.</p>","location":"getting-started/getting-started-with-php-and-opengl.html#what-is-opengl"},{"title":"Why OpenGL?","text":"<p>There are other very popular graphics APIs, such as Vulkan, Metal, and DirectX. </p> <ul> <li>OpenGL is incredibly simple, has a wealth of resources available to learn from, is cross-platform, and has been used to build games for literally decades.</li> <li>Vulkan is awesome, but its very low-level nature would make it an absolute pain to use with PHP while essentially losing all the benefits such a low-level API would give you.</li> <li>Metal is only available on Apple devices and DirectX is only available on Windows, making OpenGL the clear choice here.</li> </ul>","location":"getting-started/getting-started-with-php-and-opengl.html#why-opengl"},{"title":"State Machine","text":"<p>As a PHP developer, you are likely familiar with object-oriented programming (OOP) or the old school PHP Spaghetti\u00ae.</p> <p>To my knowledge, there aren't any popular state machine APIs in PHP userland. </p> <p>However, OpenGL is one.</p> <p>If you've never worked with a state machine API before, it may feel a bit strange at first. Especially if you're used to classic OOP, this will feel wrong and you won't stop thinking about the potential bugs with so much global state that everybody can and will change!</p> <p>In real-time rendering, performance plays a massive role, so reducing unnecessary operations is key. Clever algorithms are obviously indispensable as well. Try to suppress your OOP instincts and embrace the state machine.</p> <p>(If you are already thinking of creating a superclass <code>Drawable</code> with a <code>draw()</code> method which all of your objects will inherit from, don't...)</p>","location":"getting-started/getting-started-with-php-and-opengl.html#state-machine"},{"title":"Vector Graphics API","text":"<p>PHP-GLFW also includes a Vector Graphics (VG) API, which is inspired by the HTML Canvas API. This API provides a convenient way to draw graphics on the screen and rapidly prototype ideas and concepts.</p> <p>The VG API is based on a modified version of NanoVG and, like the rest of PHP-GLFW, is a state machine.</p> <p>Personally, I find it useful to visualize concepts, and the VG API is perfect for that. You can quickly put ideas on the screen and see how they look and feel.</p> <p>Additionally, you can freely combine the VG API with a custom OpenGL rendering pipeline. For example, you can use the VG API to draw a user interface (UI) and then use OpenGL to render a 3D scene underneath it.</p>","location":"getting-started/getting-started-with-php-and-opengl.html#vector-graphics-api"},{"title":"Additional Resources","text":"<p>I took a lot of inspiration from multiple sources to write this tutorial. Especially the LearnOpenGL website was a great help and went into much more detail than I could for PHP-GLFW. I highly recommend you check it out, as most things are directly applicable to PHP-GLFW.</p> <ol> <li>https://learnopengl.com</li> <li>http://www.opengl-tutorial.org</li> <li>https://nicolbolas.github.io/oldtut/index.html</li> <li>https://www.khronos.org/opengl/wiki/Getting_Started</li> </ol>","location":"getting-started/getting-started-with-php-and-opengl.html#additional-resources"},{"title":"Opening a Window","text":"<p>Before we get to drawing anything, we need to open a window and create a context in which we can actually draw in. This requires some boilerplate code which we discuss in this guide.</p> <p>Opening a window is a operating system specific task, so we usally would have to write a different program for each platform. However, as the name of this extension suggests PHP-GLFW is built on top of the GLFW library, which provides a cross-platform API for opening a window, creating a context and receiving input events for us. Having plattform specific code in PHP just doesnt feel right, so we use GLFW to do the dirty work for us.</p>  <p>PHP-GLFW already installed?</p> <p>Follow the installation guide if you haven't installed the extension yet!</p>   <p> </p> GLFW Window with OpenGL context in PHP.  <p>Not a very exciting screenshot, I know. But first things first, the fun stuff is coming later.</p>  <p>Full Source</p> <p>This getting started tutorial is based on the examples provided with PHP-GLFW. You can check out the complete source code here: 01_triangle.php</p>","location":"getting-started/window-creation.html"},{"title":"Initalizing GLFW","text":"<p>At the very beginning we want to call glfwInit, which you probably can guess from the name will initialize GLFW. </p> <p>GLFW is a multi-platform library that handles window creation, input &amp; context for us.</p> <pre><code>if (!glfwInit()) {\n    throw new Exception('GLFW could not be initialized!');\n}\n</code></pre>","location":"getting-started/window-creation.html#initalizing-glfw"},{"title":"Creating a Window","text":"<p>Using the function glfwWindowHint we can declare properties / options aka hints for the to be created window.</p> <pre><code>// allow the window to be resized by the user\nglfwWindowHint(GLFW_RESIZABLE, GL_TRUE);\n\n// set the OpenGL context version and profile \nglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\nglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);\nglfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\n// enable forward compatibility, @see glfw docs for details\nglfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n</code></pre> <p>After declaring the window hints we can call the glfwCreateWindow to create a window resource. Hints like <code>GLFW_RESIZABLE</code> are completely optional.</p> <pre><code>if (!$window = glfwCreateWindow(800, 600, \"PHP GLFW Demo\")) {\n    throw new Exception('OS Window could not be initialized!');\n}\n</code></pre> <p><code>$window</code> is now an instance of the <code>GLFWwindow</code> class, which holds the internal resource to the actual window.</p> <p>The first two parameters are the width and height of the window in pixels. The third parameter is the title of the window. If the window creation fails, the function returns <code>NULL</code> and we throw an exception.</p>","location":"getting-started/window-creation.html#creating-a-window"},{"title":"Binding GL Context","text":"<p>By calling glfwMakeContextCurrent glfw will make the given window object the one that is bound to the current GL context. In other words, all GL commands will be executed in the context of this window. Special in PHP-GLFW is that this will also initialize glad.</p> <pre><code>glfwMakeContextCurrent($window);\n</code></pre> <p>Because I don't particularly appreciate it when my notebook sounds like a jet engine, I enable V-Sync next so that frames are not swapped faster then the displays refresh rate.</p> <pre><code>glfwSwapInterval(1); #(1)\n</code></pre> <ol> <li>Check glfwSwapInterval </li> </ol>","location":"getting-started/window-creation.html#binding-gl-context"},{"title":"Main Loop","text":"<p>Because we want the application to run as long as the user wishes to, we have to create a \"main loop\".  Basically, a subroutine that keeps on running until we want to exit the application.</p> <p>In our main loop, we got to take care of a few things, a simplified common main loop looks something like this:</p> <pre><code>graph LR\n A[Start] --&gt; B[Window should close?];\n B --&gt;|No| C[Poll events];\n C --&gt; D[Do things &amp; Render];\n D --&gt; E[Swap Buffer];\n E --&gt; B;\n B ----&gt;|Yes| F[Cleanup &amp; stop];</code></pre> <p>To make this example a bit more interesting, we change the clear color based on the current mouse position.</p> <pre><code>while (!glfwWindowShouldClose($window))\n{\n    glfwPollEvents();\n\n    // setting the clear color to black and clearing the color buffer\n    glfwGetCursorPos($window, $mouseX, $mouseY); # (1)!\n    glClearColor(sin($mouseX / 300), sin($mouseY / 300), cos($mouseY / 300), 1);\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    // swap the windows framebuffer and\n    // poll queued window events.\n    glfwSwapBuffers($window);\n}\n</code></pre> <ol> <li>Check out glfwGetCursorPos for more information.     It will return the last known mouse position in the given window.</li> </ol> <p>Glfw holds an internal state which can be fetched using <code>glfwWindowShouldClose</code>, which will also return true if the user requested to close the window. (By clicking the close icon on the window for example).</p> <p>In the loop, the function <code>glfwPollEvents</code> will poll all queued window events and call the appropriate callback functions. Calling this function continuously is important to make sure that the window is responsive to user input and does not freeze.</p> <pre><code>glfwGetCursorPos($window, $mouseX, $mouseY);\nglClearColor(sin($mouseX / 300), sin($mouseY / 300), cos($mouseY / 300), 1);\nglClear(GL_COLOR_BUFFER_BIT);\n</code></pre> <p>Here we simply get the current mouse position and use it to set the clear color. The clear color is used to clear the color buffer before rendering a new frame. Think of it as the background color of the window.</p> <p>Finally in the loop we call <code>glfwSwapBuffers</code> to swap the windows framebuffer with the one that is currently being rendered to. This is a double buffered window, which means that there are two framebuffers, one that is currently being rendered to and one that is currently being displayed. By swapping the buffers, we make the rendered frame visible to the user.</p> <p>For good mesure, let's clean up after the loop.</p> <pre><code>glfwDestroyWindow($window);\nglfwTerminate();\n</code></pre>","location":"getting-started/window-creation.html#main-loop"},{"title":"Demo","text":"<p>Here you go, a colored window! Not the peak of excitement, but we are getting there slowly.</p>    <p>Next up we are going to create our first geometry and render a triangle in our window.</p>","location":"getting-started/window-creation.html#demo"},{"title":"Full Source Code","text":"<pre><code>&lt;?php\nif (!glfwInit()) {\n    throw new Exception('GLFW could not be initialized!');\n}\n\nglfwWindowHint(GLFW_RESIZABLE, GL_TRUE);\nglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\nglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);\nglfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\nglfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n\nif (!$window = glfwCreateWindow(800, 600, \"PHP GLFW Demo\")) {\n    throw new Exception('OS Window could not be initialized!');\n}\n\nglfwMakeContextCurrent($window);\nglfwSwapInterval(1);\n\nwhile (!glfwWindowShouldClose($window))\n{\n    glfwPollEvents();\n    glfwGetCursorPos($window, $mouseX, $mouseY);\n    glClearColor(sin($mouseX / 300), sin($mouseY / 300), cos($mouseY / 300), 1);\n    glClear(GL_COLOR_BUFFER_BIT);\n    glfwSwapBuffers($window);\n}\n\nglfwDestroyWindow($window);\nglfwTerminate();\n</code></pre>","location":"getting-started/window-creation.html#full-source-code"},{"title":"Additional resources","text":"<ol> <li>https://www.glfw.org/docs/latest/window_guide.html</li> <li>https://learnopengl.com/Getting-started/Hello-Window</li> </ol>","location":"getting-started/window-creation.html#additional-resources"},{"title":"PHP-GLFW IDE Setup","text":"","location":"getting-started/installation/ide-setup.html"},{"title":"Stubs","text":"<p>Since PHP-GLFW is a PHP extension, your editor / IDE may not support auto-completion and doc lookups without some help. To address this, we have created a composer package that you can include as a dev dependency to have full support:</p> <pre><code>composer require --dev phpgl/ide-stubs\n</code></pre>","location":"getting-started/installation/ide-setup.html#stubs"},{"title":"Linux","text":"<ul> <li> <p> Install on MacOS</p>  <p> MacOS Installation</p> </li> <li> <p> Install on Windows</p>  <p> Windows Installation</p> </li> </ul>","location":"getting-started/installation/install-linux.html"},{"title":"Installing PHP-GLFW on Linux","text":"<p>We currently do not provide an installer script for Linux like we do for MacOS. However, the \"manual\" installation process should be straightforward for Linux users.</p>","location":"getting-started/installation/install-linux.html#installing-php-glfw-on-linux"},{"title":"Manual installation","text":"<p>Ensure that you have installed the required <code>php-dev</code>, <code>git</code>, and <code>cmake</code> packages.</p> <pre><code>sudo apt install -y cmake git \n</code></pre> <p>Clone the repository:</p> <pre><code>git clone https://github.com/mario-deluna/php-glfw\ncd php-glfw\n</code></pre> <p>Configure and build the extension:</p> <pre><code>sudo phpize &amp;&amp; ./configure --enable-glfw\nsudo make install\n</code></pre> <p>Ensure that you add <code>glfw.so</code> to your <code>php.ini</code> file.</p> <p>You can determine the path to your <code>php.ini</code> file using the following command:</p> <pre><code>php -i | grep php.ini\n</code></pre> <p>Edit that file using your favorite editor:</p> <pre><code>sudo vi /usr/local/etc/php/8.1/php.ini\n</code></pre> <p>Then, add the following line at the end of the file:</p> <pre><code>extension=\"glfw.so\"\n</code></pre>","location":"getting-started/installation/install-linux.html#manual-installation"},{"title":"MacOS","text":"<ul> <li> <p> Install on Linux</p>  <p> Linux Installation</p> </li> <li> <p> Install on Windows</p>  <p> Windows Installation</p> </li> </ul>","location":"getting-started/installation/install-macos.html"},{"title":"Installing PHP-GLFW on MacOS","text":"<p>To make the installation on MacOS as painless as possible we provide an installer script that in most scenarios installs the extension in a one liner. </p>","location":"getting-started/installation/install-macos.html#installing-php-glfw-on-macos"},{"title":"Installer","text":"<p>Run the following command to download and execute the installer. Having PHP installed locally is required!</p> <pre><code>php -r \"copy('https://raw.githubusercontent.com/mario-deluna/php-glfw/master/install/macos-installer.php', 'phpglfw-installer.php');\" &amp;&amp; php phpglfw-installer.php\n</code></pre>  <p>Thats it, if you see the text \"Installation finished!\" you should be ready to go!</p>","location":"getting-started/installation/install-macos.html#installer"},{"title":"Manual installation","text":"<p>If you prefer a \"manual\" approach, ensure you have installed the <code>php-dev</code>, <code>git</code> and <code>cmake</code> packages. They are required!</p> <p>Clone the repository:</p> <pre><code>git clone https://github.com/mario-deluna/php-glfw\ncd php-glfw\n</code></pre> <p>Configure and build the extension</p> <pre><code>sudo phpize &amp;&amp; ./configure --enable-glfw\nsudo make install\n</code></pre> <p>make sure to add <code>glfw.so</code> in the <code>php.ini</code> file.</p> <p>You can figure out the path to your php.ini file using:</p> <pre><code>php -i | grep php.ini\n</code></pre> <p>Edit that file using you favorite editor:</p> <pre><code>sudo vim /usr/local/etc/php/8.1/php.ini\n</code></pre> <p>And add the following line at the end of the file</p> <pre><code>extension=\"glfw.so\"\n</code></pre>","location":"getting-started/installation/install-macos.html#manual-installation"},{"title":"Windows","text":"<ul> <li> <p> Install on Linux</p>  <p> Linux Installation</p> </li> <li> <p> Install on MacOS</p>  <p> MacOS Installation</p> </li> </ul>","location":"getting-started/installation/install-windows.html"},{"title":"Installing PHP-GLFW on Windows","text":"<p>PHP-GLFW will not run properly under WSL (Windows Subsystem) so make sure you install PHP natively on windows.  If you haven't already done so, check out the Installing PHP natively on Windows section.</p>","location":"getting-started/installation/install-windows.html#installing-php-glfw-on-windows"},{"title":"Download DLL","text":"<p>For Windows, we provide a prebuilt <code>DLL</code> which you can simply download and place into your PHP extension folder.</p> <ol> <li>See the releases page for the latest <code>DLL</code> downloads: PHP-GLFW Releases</li> <li>Download the matching <code>DLL</code> for your local PHP installation. (If you are following this guide <code>ts_x64</code>)</li> <li>Move and rename the downloaded <code>dll</code> to your PHP's <code>ext</code> folder. Usually <code>C:\\php\\ext\\php_glfw.dll</code>. </li> <li>Enable the extension in your <code>php.ini</code> (usually at <code>C:\\php\\php.ini</code>)     <pre><code>extension=glfw\n</code></pre></li> </ol>  <p>That's it, You can check if the extension is loaded properly with <code>php -m</code>.</p>","location":"getting-started/installation/install-windows.html#download-dll"},{"title":"Installing PHP natively on Windows","text":"<p>PHP-GLFW will not run properly under WSL (Windows Subsystem) so make sure you install PHP natively on windows. If you have already done so you can skip the next section.</p> <ol> <li>Go to https://windows.php.net/download#php-8.1 and download a x64 thread safe version of PHP.</li> <li>Extract the zip file and move the contents to <code>C:\\php</code>. (You have to create that directory)</li> <li>Ensure this path is valid now, and points to an executable: <code>C:\\php\\php.exe</code>.</li> <li>Add <code>C:\\php</code> to the <code>Path</code> environment variable. <ol> <li>Press on windows start and search for environment.</li> <li>\"Edit the system environment variables\" should popup, open it.</li> <li>In the dialog, click on the tab \"Advanced\" and then on the button \"Environment Variables...\"</li> <li>In the \"System Variables\" list scroll down and edit the <code>Path</code> variable.</li> <li>In the edit dialog, click on the \"New\" and enter <code>C:\\php</code>.</li> </ol> </li> <li>Open up a NEW powershell or CMD and type <code>php -v</code> to verify the installation.</li> </ol>","location":"getting-started/installation/install-windows.html#installing-php-natively-on-windows"},{"title":"Build from Source","text":"<p>In order to build PHP-GLFW we need to the \"Development Package\".</p>  <ol> <li>Clone the php-sdk: <code>git clone https://github.com/php/php-sdk-binary-tools.git php-sdk</code>, to drive root (<code>C:\\</code>)</li> <li><code>cd C:\\php-sdk</code></li> <li>Run the setup bat file, in my case I use the same architecture and SDK version as the downloaded precompiled PHP for windows. (<code>phpsdk-vs16-x64.bat</code>)</li> <li><code>phpsdk_buildtree phpmaster</code> </li> <li><code>git clone https://github.com/php/php-src.git &amp;&amp; cd php-src</code></li> <li><code>phpsdk_deps --update --branch 8.1</code></li> <li>Copy PHP-GLFW source into <code>ext/glfw</code> of the cloned PHP source code.</li> <li>run: <code>buildconf &amp;&amp; configure --disable-all --enable-cli --enable-glfw=shared &amp;&amp; nmake</code></li> <li>the resulting <code>dll</code> should be located depending on your choosen build under <code>x64\\Release_TS\\php_glfw.dll</code>. </li> </ol>","location":"getting-started/installation/install-windows.html#build-from-source"},{"title":"PHP Audio Engine","text":"<p>PHP-GLFW ships with high level audio playback that is powered by miniaudio.  The <code>GL\\Audio</code> namespace gives you a lightweight engine that can stream compressed files, control per sound playback, and leverage spatial audio by combining the audio module with the math utilities that already ship with the extension.</p> <p>This guide walks through the main building blocks:</p> <ul> <li>Creating and configuring the audio engine</li> <li>Loading sounds from disk</li> <li>Basic playback, looping, and volume controls</li> <li>Seeking, fading, and querying playback state</li> <li>Spatial audio features (listener, positions, min/max distance)</li> <li>Reading PCM frames for visualisation or DSP</li> </ul>","location":"user-guide/audio/audio_engine.html"},{"title":"Example","text":"<p>You can try everything live by running the music player example:</p> <pre><code>php examples/vg/audio_musicplayer.php\n</code></pre>  <p></p>","location":"user-guide/audio/audio_engine.html#example"},{"title":"Engine setup","text":"<p>Create a new <code>GL\\Audio\\Engine</code> instance once in your application.  By default it initialises the output device immediately, but you can opt out and start the engine later.</p> <pre><code>use GL\\Audio\\Engine;\nuse GL\\Math\\Vec3;\n\n$audio = new Engine(); # (1)!\n\n$audio-&gt;setMasterVolume(0.8);\n\n// configure the listener so spatial audio matches your world\n$audio-&gt;setListenerPosition(new Vec3(0.0, 1.6, 0.0));\n$audio-&gt;setListenerDirection(new Vec3(0.0, 0.0, -1.0));\n$audio-&gt;setListenerWorldUp(new Vec3(0.0, 1.0, 0.0));\n</code></pre> <ol> <li>You can pass an optional config array to the constructor to tweak engine and device settings (see below).    \u00a0    <pre><code>$audio = new Engine([\n 'channels' =&gt; 2,\n 'sampleRate' =&gt; 48000,\n // etc..\n]);\n</code></pre></li> </ol> <p>The constructor accepts an optional array of configuration options:</p>    Option Type Description     <code>listenerCount</code> <code>int</code> Number of active 3D listeners (1 default, max 4).   <code>channels</code> <code>int</code> Override output channels (default taken from the device).   <code>sampleRate</code> <code>int</code> Request a specific device sample rate.   <code>periodSizeInFrames</code> <code>int</code> Custom device period size in frames.   <code>periodSizeInMilliseconds</code> <code>int</code> Alternative way to define the device period size.   <code>gainSmoothTimeInFrames</code> <code>int</code> Number of frames used when smoothing master volume changes.   <code>gainSmoothTimeInMilliseconds</code> <code>int</code> Same as above but in milliseconds.   <code>defaultVolumeSmoothTimeInPCMFrames</code> <code>int</code> Fade duration for per sound volume automation.   <code>noAutoStart</code> <code>bool</code> Skip automatic engine start. Call <code>$engine-&gt;start()</code> manually.   <code>monoExpansionMode</code> <code>int</code> Choose how mono sources expand to stereo. Use <code>GL_MA_MONO_EXPANSION_MODE_*</code> constants.     <p>Tip</p> <p>The engine automatically shuts down in the object destructor, so you rarely have to call <code>$engine-&gt;stop()</code> manually unless you manage devices explicitly.</p>","location":"user-guide/audio/audio_engine.html#engine-setup"},{"title":"Loading sounds from disk","text":"<p>Use <code>soundFromDisk()</code> to create a <code>GL\\Audio\\Sound</code> instance.  The method returns a fully initialised sound that keeps track of format, channel count, sample rate, and length information on the PHP side.</p> <pre><code>$sound = $audio-&gt;soundFromDisk(__DIR__ . '/assets/music_loop.ogg');\n\necho $sound-&gt;getChannels();      // e.g. 2\necho $sound-&gt;getSampleRate();    // e.g. 48000\necho $sound-&gt;getLength();        // seconds\n</code></pre> <p>MiniAudio supports a wide range of formats (WAV, MP3, FLAC, Ogg/Vorbis, and more).  The decoder is streaming-based, so memory usage stays reasonable even for long files.</p>","location":"user-guide/audio/audio_engine.html#loading-sounds-from-disk"},{"title":"Basic playback controls","text":"<p>Every sound shares the same engine but exposes independent playback state.  The most common actions are straightforward:</p> <pre><code>$sound-&gt;setLoop(true);\n$sound-&gt;setVolume(0.65);\n$sound-&gt;setPitch(1.1);\n$sound-&gt;setPan(-0.25); // -1.0 left, 1.0 right\n\n// and play it!\n$sound-&gt;play();\n</code></pre> <p>Use <code>$sound-&gt;stop()</code> to halt playback without rewinding.  Query playback position via <code>getCursor()</code> (seconds) or <code>getCursorPCM()</code> (frames).  When looping is enabled the cursor wraps automatically.</p>","location":"user-guide/audio/audio_engine.html#basic-playback-controls"},{"title":"Seeking, trimming, and fading","text":"<p>You can seek and constrain playback ranges without reloading the asset:</p> <pre><code>$sound-&gt;setStartMs(500);   // begin 0.5 seconds into the file\n$sound-&gt;setStopMs(3500);   // stop after 3.5 seconds\n\n$sound-&gt;seekTo(42.0);      // jump to 42 seconds (returns bool)\n$sound-&gt;seekToPCM(22050);  // or directly in PCM frames\n</code></pre> <p>Fades are expressed in seconds and run on the miniaudio mixer thread:</p> <pre><code>$sound-&gt;fadeIn(2.0);                 // ramp current volume to 1.0 in 2 seconds\n$sound-&gt;fadeOut(1.5);                // ramp down to silence\n$sound-&gt;setFade(0.2, 0.8, 3.0);      // custom fade from 0.2 -&gt; 0.8\n$current = $sound-&gt;getCurrentFadeVolume();\n</code></pre>","location":"user-guide/audio/audio_engine.html#seeking-trimming-and-fading"},{"title":"Spatial audio","text":"<p>Combine the audio engine with <code>Vec3</code> to position sounds in 3D.  The listener properties typically follow your camera, while sound positions follow moving entities.</p> <pre><code>use GL\\Math\\Vec3;\n\n$engine-&gt;setListenerPosition($camera-&gt;position);\n$engine-&gt;setListenerDirection($camera-&gt;forward);\n$engine-&gt;setListenerWorldUp(new Vec3(0.0, 1.0, 0.0));\n\n$gunShot = $engine-&gt;soundFromDisk(__DIR__ . '/assets/gun_shot.wav');\n$gunShot-&gt;setLoop(true);\n$gunShot-&gt;setPosition(new Vec3(-3.0, 0.0, 1.5));\n$gunShot-&gt;setMinDistance(1.0);   // distance where full volume is kept\n$gunShot-&gt;setMaxDistance(25.0);  // distance where attenuation stops\n$gunShot-&gt;setVelocity(new Vec3(0.0, 0.0, 2.0));\n$gunShot-&gt;play();\n</code></pre> <p>Call <code>getPosition()</code>, <code>getDirection()</code>, and <code>getVelocity()</code> to fetch the current values if you need to debug spatial settings.</p>","location":"user-guide/audio/audio_engine.html#spatial-audio"},{"title":"Reading PCM data","text":"<p><code>readFrames()</code> lets you stream raw audio frames into one of the native buffer types.  Choose the buffer that matches the sound format (float, signed 16-bit, or unsigned 8-bit) and reuse it between calls.</p> <pre><code>use GL\\Buffer\\FloatBuffer;\n\n$frames = new FloatBuffer();\n$requested = 2048;\n$readCount = $sound-&gt;readFrames($requested, $frames);\n\nprintf(\"Read %d frames (%.2f ms)\\n\", $readCount, $readCount / $sound-&gt;getSampleRate() * 1000);\n</code></pre> <p>The method returns the number of frames read and resizes the buffer automatically. You can feed these samples into FFT analysis, visualisers, or streaming uploads similar to the <code>audio_musicplayer</code> example.</p>","location":"user-guide/audio/audio_engine.html#reading-pcm-data"},{"title":"Debugging OpenGL Calls with apitrace","text":"<p>Every OpenGL developer, at some point, will face the challenge of a black screen or a crash without a clear understanding of what went wrong. In these situations, recording and replaying OpenGL calls in a debugger can be invaluable. Several tools can help you achieve this, but one of the most popular is apitrace. Apitrace stands out due to its simplicity, ease of use, and cross-platform compatibility, supporting all major operating systems.</p>","location":"user-guide/debugging/debug_opengl_with_apitrace.html"},{"title":"Alternative Debugging Tools","text":"<p>While apitrace is a great choice, other tools might be better suited to your specific needs or preferences. Here are some alternatives:</p> <ul> <li>NVIDIA Nsight: A fantastic tool, but limited to Windows. My personal favorite.</li> <li>RenderDoc: A versatile, graphics debugging tool.</li> <li>Intel GPA: Tailored for Intel chips, it may not work with other chipsets.</li> <li>glintercept: An OpenGL function call interceptor for Windows.</li> <li>vogl: A powerful, open-source debugger created by Valve Software.</li> </ul>","location":"user-guide/debugging/debug_opengl_with_apitrace.html#alternative-debugging-tools"},{"title":"Tracing OpenGL Calls","text":"<p>When working with PHP-GLFW, tracing OpenGL calls is a straightforward process, similar to tracing calls in a C++ OpenGL application. To trace your PHP OpenGL application, use the following command:</p> <pre><code>apitrace trace --api gl php my_php_application.php\n</code></pre> <p>This command launches your application and generates a file named <code>php.trace</code> in the current directory. This file records all the OpenGL calls made during the PHP script's execution.</p>","location":"user-guide/debugging/debug_opengl_with_apitrace.html#tracing-opengl-calls"},{"title":"Analyzing Traced Calls","text":"<p>To examine the recorded calls, use the <code>qapitrace</code> command. This command opens a GUI that allows you to easily navigate and analyze the calls:</p> <pre><code>qapitrace php.trace\n</code></pre> <p>Through the <code>qapitrace</code> GUI, you can scrutinize the OpenGL calls, view their results, buffers, textures, states etc. This information can help you understand what's happening behind the scenes and improve the stability and performance of your PHP-GLFW applications.</p> <p>Happy debugging!</p>","location":"user-guide/debugging/debug_opengl_with_apitrace.html#analyzing-traced-calls"},{"title":"Wavefront object files","text":"<p>Warning</p> <p>The parser expects fully triangulated meshes. Convert quads or n-gons inside your DCC tool before exporting, otherwise the import will fail.</p>","location":"user-guide/geometry/wavefront-object-files.html"},{"title":"Wavefront Object Files","text":"<p><code>GL\\Geometry\\ObjFileParser</code> lets you pull Wavefront <code>.obj</code> assets straight into your PHP runtime. This page walks you through loading a model, shaping the vertex layout you need, handling materials, and producing indexed meshes that drop into your renderer.</p> <ul> <li>Keep your <code>.mtl</code> files beside the <code>.obj</code>, since materials resolve paths relative to the model.</li> <li>Want a quick demo? Run the example:</li> </ul> <pre><code>php examples/05_objloading.php\n</code></pre>  <p></p>","location":"user-guide/geometry/wavefront-object-files.html#wavefront-object-files"},{"title":"Loading Models","text":"<p>Creating the parser is the only setup step. Point it at a file path, and it opens a shared resource that keeps vertex data, indices, and materials in native memory.</p> <pre><code>use GL\\Geometry\\ObjFileParser;\n\n$parser = new ObjFileParser(__DIR__ . '/my_asset.obj');\n\nprintf(\"Loaded %d materials\\n\", count($parser-&gt;materials));\nprintf(\"Loaded %d groups\\n\", count($parser-&gt;groups));\nprintf(\"Loaded %d objects\\n\", count($parser-&gt;objects)); \n</code></pre> <p>Will print something like:</p> <pre><code>Loaded 5 materials\nLoaded 1 groups\nLoaded 19 objects\n</code></pre>","location":"user-guide/geometry/wavefront-object-files.html#loading-models"},{"title":"Vertex Layouts","text":"<p><code>getVertices</code> returns a <code>FloatBuffer</code>. You can control the what attributes are included into the buffer by passing a layout string. Each character becomes a vertex attribute in the order provided.</p> <pre><code>$vertices = $parser-&gt;getVertices('pntbc', $specifcGroup); // &lt;- pass layout\n</code></pre>    Token Components Description     <code>p</code> 3 Position <code>(x, y, z)</code>   <code>n</code> 3 Normal from the file   <code>N</code> 3 Generated flat normal   <code>c</code> 2 Texture coordinates <code>(u, v)</code>   <code>t</code> 3 Generated tangent   <code>b</code> 3 Generated bitangent     <p>Tip</p> <p>Tangents, bitangents and flat normals are generated on demand. </p>  <p>Examples:</p> <ul> <li><code>pnc</code> yields <code>[px, py, pz, nx, ny, nz, u, v, ...]</code>.</li> <li><code>p</code> yields just positions <code>[px, py, pz, ...]</code>.</li> <li><code>pN</code> yields positions and flat normals <code>[px, py, pz, nfx, nfy, nfz, ...]</code>.</li> <li>etc..</li> </ul>","location":"user-guide/geometry/wavefront-object-files.html#vertex-layouts"},{"title":"Uploading to OpenGL","text":"<p>The returned buffer object can then be uploaded to your GPU, when using VISU we have a convenient class to handle this for us:</p> VISUPHP-GLFW   <pre><code>use VISU\\Graphics\\BasicVertexArray;\n\n// fetch all vertices\n$vertices = $parser-&gt;getVertices('pnc'); // &lt;- note the 'pnc' layout\n\n// create a basic vertex array [px, py, pz, nx, ny, nz, u, v] aka [3, 3, 2]\n$vao = new BasicVertexArray($gl, [3, 3, 2]);\n$vao-&gt;upload($vertices);\n</code></pre>   <pre><code>// fetch all vertices\n$vertices = $parser-&gt;getVertices('pnc');\n\n// build OpenGL VAO/VBO\n// [position (3), normal (3), texcoord (2)]\n$stride = 3 + 3 + 2; // floats per vertex\n\n// create &amp; bind buffers\n$vao = glGenVertexArrays(1);\n$buffer = glGenBuffers(1);\n\nglBindVertexArray($vao);\nglBindBuffer(GL_ARRAY_BUFFER, $buffer);\nglBufferData(GL_ARRAY_BUFFER, $vertices, GL_STATIC_DRAW);\n\n// setup vertex attributes\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, $stride * GL_SIZEOF_FLOAT, 0);\nglEnableVertexAttribArray(0);\n\nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, $stride * GL_SIZEOF_FLOAT, 3 * GL_SIZEOF_FLOAT);\nglEnableVertexAttribArray(1);\n\nglVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, $stride * GL_SIZEOF_FLOAT, 6 * GL_SIZEOF_FLOAT);\nglEnableVertexAttribArray(2);\n</code></pre>    <p>Leave the <code>$group</code> argument empty to merge the entire file. Supply a <code>Group</code> from <code>$parser-&gt;groups</code> or <code>$parser-&gt;objects</code> when you only want the geometry for a single section.</p>","location":"user-guide/geometry/wavefront-object-files.html#uploading-to-opengl"},{"title":"Working With Materials","text":"<p><code>getMeshes()</code> slices the model by Material and returns an array of <code>Mesh</code> objects. Each mesh bundles everything you need to draw: a vertex buffer, an optional index buffer, a material descriptor, and an axis-aligned bounding box.</p> <pre><code>$meshes = $parser-&gt;getMeshes('pnc'); // &lt;- pass layout\n\nforeach ($meshes as $mesh) {\n    $material = $mesh-&gt;material;\n    echo $material-&gt;name . \"\\n\";\n    echo str_repeat(\"-\", strlen($material-&gt;name)) . \"\\n\";\n\n    if ($material) {\n        echo \"  Diffuse color: \" .  $material-&gt;diffuse . \"\\n\";\n        echo \"  Specular color: \" .  $material-&gt;specular . \"\\n\";\n        $vertices = $mesh-&gt;vertices; // FloatBuffer\n        // etc..\n    }\n    echo \"\\n\";\n}\n</code></pre> <p>Will print something like:</p> <pre><code>iron\n----\n  Diffuse color: vec3(0.3765, 0.3765, 0.3765)\n  Specular color: vec3(0.25, 0.25, 0.25)\n\ntextile\n-------\n  Diffuse color: vec3(0.8196, 0.7529, 0.6706)\n  Specular color: vec3(0.25, 0.25, 0.25)\n</code></pre> <p>Material properties mirror common MTL fields such as <code>ambient</code>, <code>diffuse</code>, <code>specular</code>, <code>shininess</code>, <code>dissolve</code>, and <code>illuminationModel</code>. Use them to drive your shader uniforms or to build the inputs for a lightweight PBR workflow.</p> <p>Bounding boxes are available through <code>aabbMin</code> and <code>aabbMax</code> (<code>Vec3</code>). They are perfect for quick frustum checks, simple collisions, or framing a camera before the first draw call.</p>","location":"user-guide/geometry/wavefront-object-files.html#working-with-materials"},{"title":"Groups and Objects","text":"<p>Wavefront files distinguish between <code>g</code> groups and <code>o</code> objects. The parser keeps both exposed through <code>$parser-&gt;groups</code> and <code>$parser-&gt;objects</code>, each providing <code>name</code>, <code>faceCount</code>, <code>faceOffset</code>, and <code>indexOffset</code>. In php-glfw we consider both as <code>Group</code> instances since they behave identically from a geometry extraction standpoint.</p> <p>Groups allow you to partially access the model geometry. This is useful to:</p> <ul> <li>render only a subsection of a complex asset</li> <li>apply distinct transforms or materials per part</li> </ul> <pre><code>// $parser-&gt;groups or $parser-&gt;objects\nforeach ($parser-&gt;groups as $group) {\n    printf(\"Group %s spans %d faces\\n\", $group-&gt;name, $group-&gt;faceCount);\n    $buffer = $parser-&gt;getVertices('p', $group);\n}\n</code></pre>","location":"user-guide/geometry/wavefront-object-files.html#groups-and-objects"},{"title":"Putting It All Together","text":"<p>The following example is going to use <code>VISU</code>, as making a plain OpenGL example would be too verbose and contain 90% boilerplate code.</p>  <p>VISU Note</p> <p>The examples below expect you to have <code>VISU</code> available.</p> <p>Install VISU via Composer if you haven't already:</p> <pre><code>composer require phpgl/visu\n</code></pre> <p>Create a new PHP file (e.g. <code>example.php</code>) and add the following code:</p> <pre><code>&lt;?php\n\nuse VISU\\Quickstart;\nuse VISU\\Quickstart\\{QuickstartApp, QuickstartOptions};\nuse VISU\\Graphics\\RenderTarget;\nuse VISU\\Graphics\\Rendering\\RenderContext;\n\nrequire __DIR__ . '/vendor/phpgl/visu/bootstrap_inline.php';\n\n$quickstart = new Quickstart(function(QuickstartOptions $options)\n{\n    $options-&gt;ready = function(QuickstartApp $app) {\n        // initialize\n    };\n\n    $options-&gt;draw = function(QuickstartApp $app, RenderContext $renderContext, RenderTarget $renderTarget) {\n        // draw loop\n    };\n});\n\n$quickstart-&gt;run();\n</code></pre> <p>Running this will open a window with an OpenGL context and a basic render loop.</p>  <p>So first as usual we create a parser instance and load an obj file:</p> <pre><code>use GL\\Geometry\\ObjFileParser;\n\n$parser = new ObjFileParser(__DIR__ . '/assets/ship.obj');\n</code></pre>","location":"user-guide/geometry/wavefront-object-files.html#putting-it-all-together"},{"title":"Building a Buffer","text":"<p>Next we build a vertex buffer with the positions of our mesh and collect material infos like the diffuse color:</p> <p>So that we do not have to deal with multiple buffers for each mesh, we create a single large vertex buffer and append each mesh's vertices to it. That way we also don't have to re-bind multiple buffers when rendering.</p> <pre><code>$vertexBuffer = new FloatBuffer();\n$vertexOffset = 0;\n$objects = [];\nforeach($parser-&gt;getMeshes('p') as $mesh) \n{\n    // append the mesh vertices to the main buffer\n    $vertexBuffer-&gt;append($mesh-&gt;vertices);\n\n    // every vertex has 3 floats (x, y, z)\n    $vertexCount = $mesh-&gt;vertices-&gt;size() / 3;\n\n    // store the object info\n    $objects[] = [\n        'vertexOffset' =&gt; $vertexOffset,\n        'vertexCount' =&gt; $vertexCount,\n        'color' =&gt; $mesh-&gt;material-&gt;diffuse,\n    ];\n\n    // update the vertex offset for the next object\n    $vertexOffset += $vertexCount;\n}\n</code></pre> <p><code>$vertexBuffer</code> now contains all vertices of the entire model, while <code>$objects</code> holds the necessary info to render each mesh separately. Which we want to do so that we can apply the correct material color.</p>","location":"user-guide/geometry/wavefront-object-files.html#building-a-buffer"},{"title":"Uploading to GPU","text":"<p>Now we need to upload the vertex buffer to the GPU. So that we can render it, for simple buffers VISU provides the <code>BasicVertexArray</code> class which wraps a VAO and VBO for us:</p> <pre><code>$vao = new BasicVertexArray($gl, [3]);\n$vao-&gt;upload($vertexBuffer);\n</code></pre>","location":"user-guide/geometry/wavefront-object-files.html#uploading-to-gpu"},{"title":"Rendering the objects","text":"<p>Then in the render loop we bind the VAO and draw each object separately, applying the correct color uniform before each draw call:</p> <pre><code>// bind the VAO\n$vao-&gt;bind();\n\n// draw each object\nforeach($state-&gt;objects as $object)\n{\n    $shader-&gt;setUniformVec3(\"u_color\", $object['color']);\n    $vao-&gt;draw($object['vertexOffset'], $object['vertexCount']);\n}\n</code></pre>","location":"user-guide/geometry/wavefront-object-files.html#rendering-the-objects"},{"title":"Full Example","text":"<p>All of the above combined into into a full example looks like this:</p> <pre><code>&lt;?php\n\nuse GL\\Buffer\\FloatBuffer;\nuse GL\\Math\\{Mat4, Vec3};\nuse VISU\\Graphics\\{BasicVertexArray, RenderTarget, ShaderProgram, ShaderStage};\nuse VISU\\Graphics\\Rendering\\RenderContext;\nuse VISU\\Quickstart;\nuse VISU\\Quickstart\\{QuickstartApp, QuickstartOptions};\n\nrequire __DIR__ . '/vendor/phpgl/visu/bootstrap_inline.php';\n\nclass ExampleState {\n    public ShaderProgram $shader;\n    public BasicVertexArray $vao;\n    public FloatBuffer $vertexBuffer;\n    public array $objects = [];\n};\n\n$state = new ExampleState();\n\n$quickstart = new Quickstart(function(QuickstartOptions $options) use($state)\n{   \n    $options-&gt;ready = function(QuickstartApp $app) use($state)\n    {\n        $parser = new \\GL\\Geometry\\ObjFileParser(__DIR__ . '/ship_light.obj');\n\n        $state-&gt;objects = [];\n        $state-&gt;vertexBuffer = new FloatBuffer();\n        $vertexOffset = 0;\n        foreach($parser-&gt;getMeshes('p') as $mesh) \n        {\n            // append the mesh vertices to the main buffer\n            $state-&gt;vertexBuffer-&gt;append($mesh-&gt;vertices);\n\n            // every vertex has 3 floats (x, y, z)\n            $vertexCount = $mesh-&gt;vertices-&gt;size() / 3;\n\n            // store the object info\n            $state-&gt;objects[] = [\n                'vertexOffset' =&gt; $vertexOffset,\n                'vertexCount' =&gt; $vertexCount,\n                'color' =&gt; $mesh-&gt;material-&gt;diffuse,\n            ];\n\n            // update the vertex offset for the next object\n            $vertexOffset += $vertexCount;\n        }\n\n        // now create the VAO\n        $state-&gt;vao = new BasicVertexArray($app-&gt;gl, [3]);\n        $state-&gt;vao-&gt;upload($state-&gt;vertexBuffer);\n\n        // create the shader program\n        $state-&gt;shader = new ShaderProgram($app-&gt;gl);\n        $state-&gt;shader-&gt;attach(ShaderStage::vertex(&lt;&lt;&lt;GLSL\n        #version 330 core\n\n        layout(location = 0) in vec3 a_pos;\n\n        uniform mat4 u_proj_matrix;\n        uniform mat4 u_view_matrix;\n        uniform mat4 u_model_matrix;\n\n        void main()\n        {\n            gl_Position = u_proj_matrix * u_view_matrix * u_model_matrix * vec4(a_pos, 1.0);\n        }\n        GLSL\n        ));\n\n        $state-&gt;shader-&gt;attach(ShaderStage::fragment(&lt;&lt;&lt;GLSL\n        #version 330 core\n        out vec4 fragment_color;\n        uniform vec3 u_color;\n        void main()\n        {\n            fragment_color = vec4(u_color, 1.0);\n        }\n        GLSL\n        ));\n        $state-&gt;shader-&gt;link();\n    };\n\n    $options-&gt;draw = function(QuickstartApp $app, RenderContext $renderContext, RenderTarget $renderTarget) use($state)\n    {\n        // clear the screen\n        $renderTarget-&gt;framebuffer()-&gt;clear();\n\n        // enable depth testing\n        glEnable(GL_DEPTH_TEST);\n\n        // bind the VAO\n        $state-&gt;vao-&gt;bind();\n        $state-&gt;shader-&gt;use();\n\n        // set up the camera matrices\n        $aspectRatio = $renderTarget-&gt;width() / $renderTarget-&gt;height();\n        $projMatrix = new Mat4();\n        $projMatrix-&gt;perspective(45.0, $aspectRatio, 0.1, 100.0);\n        $viewMatrix = new Mat4();\n        $viewMatrix-&gt;translate(new Vec3(0.0, -5.0, -15.0));\n        $modelMatrix = new Mat4();\n        $modelMatrix-&gt;rotate(glfwGetTime() * 0.5, new Vec3(0.0, 1.0, 0.0));\n\n        $state-&gt;shader-&gt;setUniformMat4(\"u_proj_matrix\", false, $projMatrix);\n        $state-&gt;shader-&gt;setUniformMat4(\"u_view_matrix\", false, $viewMatrix);\n        $state-&gt;shader-&gt;setUniformMat4(\"u_model_matrix\", false, $modelMatrix);\n\n        // draw each object\n        foreach($state-&gt;objects as $object)\n        {\n            $state-&gt;shader-&gt;setUniformVec3(\"u_color\", $object['color']);\n            $state-&gt;vao-&gt;draw($object['vertexOffset'], $object['vertexCount']);\n        }\n    };\n});\n\n$quickstart-&gt;run();\n</code></pre>","location":"user-guide/geometry/wavefront-object-files.html#full-example"},{"title":"Math Functions","text":"<p>The PHP OpenGL extension, PHP-GLFW, offers a collection of math functions designed to perform common mathematical operations required in computer graphics. These functions are implemented in C and are accessible within the <code>GL\\Math</code> namespace.</p> <p>One unique aspect of these objects in PHP is the use of overloaded operators. This allows you to use the <code>+</code> operator for adding two vectors together or the <code>*</code> operator for multiplying a vector by a scalar.</p> <p>These functions and classes are also fast. Learn more about their performance here.</p>  <p>Warning</p> <p>There is currently an issue in the Zend Engine where multiplication operands are switched in certain expressions. This can be problematic when multiplying matrices, as the order is critical compared to regular multiplications.</p> <p>To work around this, use parentheses to enforce the correct order.</p> <p>https://github.com/php/php-src/issues/9175</p>","location":"user-guide/math/math_functions.html"},{"title":"Vector Usage","text":"<p>There are three vector classes available: <code>Vec2</code>, <code>Vec3</code>, and <code>Vec4</code>.</p> <p>The number in the class name indicates the number of components the vector has:</p> <ul> <li><code>Vec2</code> has 2 components (<code>$x</code>, <code>$y</code>)</li> <li><code>Vec3</code> has 3 components (<code>$x</code>, <code>$y</code>, <code>$z</code>)</li> <li><code>Vec4</code> has 4 components (<code>$x</code>, <code>$y</code>, <code>$z</code>, <code>$w</code>)</li> </ul> <pre><code>use GL\\Math\\Vec3;\n\n$vec = new Vec3(1.0, 2.0, 3.0);\n\necho $vec; // prints vec3(1.0, 2.0, 3.0)\n</code></pre> <p>You can access the components of a vector using the <code>$x</code>, <code>$y</code>, <code>$z</code>, <code>$w</code> properties.</p> <pre><code>echo $vec-&gt;x; // prints 1.0\necho $vec-&gt;y; // prints 2.0\necho $vec-&gt;z; // prints 3.0\n</code></pre> <p>You can also set the components of a vector using the <code>$x</code>, <code>$y</code>, <code>$z</code>, <code>$w</code> properties.</p> <pre><code>$vec-&gt;x = 4.0;\n$vec-&gt;y = 5.0;\n$vec-&gt;z = 6.0;\n</code></pre> <p>Vector properties are virtual, meaning they are not stored in the vector object as real PHP properties. This allows multiple keys to map to the same property. For example, the <code>$x</code> property is also mapped to <code>$r</code>. The following code is valid:</p> <pre><code>$vec-&gt;r = 42.0;\necho $vec-&gt;x; // prints 42.0\n$vec-&gt;y = 100.0;\necho $vec-&gt;g; // prints 100.0\n// etc..\n</code></pre>","location":"user-guide/math/math_functions.html#vector-usage"},{"title":"Operators","text":"<p>Vector classes have overloaded operators, which means you can use the <code>+</code> operator to add two vectors together or the <code>*</code> operator to multiply a vector with another vector or a scalar.</p> <pre><code>$vec1 = new Vec3(1.0, 2.0, 3.0);\n$vec2 = new Vec3(4.0, 5.0, 6.0);\n\n// addition\necho $vec1 + $vec2; // vec3(5.0, 7.0, 9.0)\n\n// subtraction\necho $vec1 - $vec2; // vec3(-3.0, -3.0, -3.0)\n\n// multiplication\necho $vec1 * $vec2; // vec3(4.0, 10.0, 18.0)\n\n// division\necho $vec1 / $vec2; // vec3(0.25, 0.4, 0.5)\n</code></pre> <p>You can also apply scalar operations to the vectors.</p> <pre><code>$vec1 = new Vec3(1.0, 2.0, 3.0);\n\n// addition\necho $vec1 + 2.0; // vec3(3.0, 4.0, 5.0)\n\n// substraction\necho $vec1 - 2.0; // vec3(-1.0, 0.0, 1.0)\n\n// multiplication\necho $vec1 * 2.0; // vec3(2.0, 4.0, 6.0)\n\n// division\necho $vec1 / 2.0; // vec3(0.5, 1.0, 1.5)\n</code></pre>","location":"user-guide/math/math_functions.html#operators"},{"title":"Functions","text":"<p>You can read about the functions available in the <code>Vec2</code>, <code>Vec3</code>, <code>Vec4</code> classes in the API documentation.</p>","location":"user-guide/math/math_functions.html#functions"},{"title":"Normalize","text":"<p>You can normalize a vector using the <code>normalize()</code> function, or the <code>normalized()</code> static function.</p> <p>The difference between these two functions is that the <code>normalize()</code> function modifies the vector in place, while the <code>normalized()</code> function returns a new vector.</p> <pre><code>$vec1 = new Vec3(1.0, 2.0, 3.0);\n$vec2 =  Vec3::normalized($vec1); \necho $vec2; // prints vec3(0.2673, 0.5345, 0.8018)\n</code></pre> <p>Or using normalize to modify the vector in place:</p> <pre><code>$vec1 = new Vec3(1.0, 2.0, 3.0);\n$vec1-&gt;normalize();\necho $vec1; // prints vec3(0.2673, 0.5345, 0.8018)\n</code></pre>","location":"user-guide/math/math_functions.html#normalize"},{"title":"Length","text":"<p>You can get the length of a vector using the <code>length()</code> function.</p> <pre><code>$vec1 = new Vec3(1.0, 2.0, 3.0);\necho $vec1-&gt;length(); // prints 3.7416574954987\n</code></pre>","location":"user-guide/math/math_functions.html#length"},{"title":"Dot Product","text":"<p>You can get the dot product of two vectors using the <code>dot()</code> function.</p> <pre><code>$vec1 = new Vec3(5.0, 12.5, 7.5);\n$vec2 = new Vec3(0.5, 2.0, 0.75);\n\necho Vec3::dot($vec1, $vec2); // prints 33.125\n</code></pre>","location":"user-guide/math/math_functions.html#dot-product"},{"title":"Distance","text":"<p>Or simply the distance between two vectors using the <code>distance()</code> function.</p> <pre><code>$vec1 = new Vec3(5.0, 12.5, 7.5);\n$vec2 = new Vec3(0.5, 2.0, 0.75);\n\necho Vec3::distance($vec1, $vec2); // prints 13.268\n</code></pre>","location":"user-guide/math/math_functions.html#distance"},{"title":"Quaternion Usage","text":"<p>There is a <code>Quat</code> class available for working with quaternions.</p> <p>You can think of a quaternion as a 4D vector, but it is not a vector in the same sense as a <code>Vec4</code> is. A quaternion is usally used to represent a rotation in 3D space. In our implementation a quaternion has its components stored in <code>$w</code>, <code>$x</code>, <code>$y</code>, <code>$z</code> properties. This is not the same as the <code>Vec4</code> class, where the components are stored in <code>$x</code>, <code>$y</code>, <code>$z</code>, <code>$w</code> properties.</p> <pre><code>use GL\\Math\\Quat;\n\n$quat = new Quat();\n\necho $quat; // prints quat(1.0, 0.0, 0.0, 0.0)\n</code></pre> <p>You can access the components of the quaternion using the <code>$w</code>, <code>$x</code>, <code>$y</code>, <code>$z</code> properties.</p> <pre><code>echo $quat-&gt;w; // prints 1.0\necho $quat-&gt;x; // prints 0.0\n// etc..\n</code></pre> <p>You can also set the components of the quaternion using the <code>$w</code>, <code>$x</code>, <code>$y</code>, <code>$z</code> properties.</p> <pre><code>$quat-&gt;w = 2.0;\n// etc..\n</code></pre>","location":"user-guide/math/math_functions.html#quaternion-usage"},{"title":"Operators","text":"<p>Just like the Vector classes the quaternion class <code>Quat</code> has overloaded operators. This means that you can use the <code>*</code> operator to multiply two quaternions together, which can be used to combine rotations. This continues to work even if you multiply a quaternion with a vector. The result will be a vector that has been rotated by the quaternion.</p> <pre><code>// creates a quat that rotates 90 degrees on the y axis\n$quat = new Quat;\n$quat-&gt;rotate(GLM::radians(90), new Vec3(0, 1, 0));\n\n// create a directional vector pointing in the x direction (right)\n$vec = new Vec3(1, 0, 0);\n\n// rotate the vector by the quaternion\n$rotated = $quat * $vec;\n\n// print the vector witch should now be pointing in the -z direction (forward)\necho $rotated; // prints vec3(0.0, 0.0, -1.0)\n</code></pre>","location":"user-guide/math/math_functions.html#operators_1"},{"title":"Functions","text":"<p>Just like the vector classes there are a number of functions available for working with quaternions. You can read about the functions available in the <code>Quat</code> class in the API documentation.</p> <p>To just give a few common examples:</p>","location":"user-guide/math/math_functions.html#functions_1"},{"title":"Normalize","text":"<p>You can normalize a quaternion using the <code>normalize</code> function. This will make the quaternion a unit quaternion. This modifies the quaternion in place.</p> <pre><code>$quat = new Quat(1, 2, 3, 4);\n$quat-&gt;normalize(); \n\necho $quat; // prints quat(0.182574, 0.365148, 0.547723, 0.730297)\n</code></pre> <p>You can also use the <code>normalized</code> function to create a new quaternion that is a normalized version of the original quaternion.</p> <pre><code>$quat = new Quat(1, 2, 3, 4);\n$normalized = Quat::normalized($quat);\n</code></pre>","location":"user-guide/math/math_functions.html#normalize_1"},{"title":"Rotate","text":"<p>You can rotate a quaternion using the <code>rotate</code> function. This will rotate the quaternion by the given angle around the given axis.</p> <pre><code>$quat = new Quat;\n$quat-&gt;rotate(GLM::radians(90), new Vec3(0, 1, 0));\n</code></pre>","location":"user-guide/math/math_functions.html#rotate"},{"title":"Matrix Usage","text":"<p>There is a <code>Mat4</code> class available for working with 4x4 matrices. A matrix (in our implementation) has no accessable properties. You can only access the elements of the matrix using the array access operator <code>[]</code>. We store the values in a flat 1 dimensional array.</p> <pre><code>use GL\\Math\\Mat4;\n\n$mat = new Mat4;\n\necho $mat[0]; // prints 1.0\necho $mat[1]; // prints 0.0\necho $mat[15]; // prints 1.0\n// etc..\n</code></pre> <p>You can also set the elements of the matrix using the array access operator <code>[]</code>.</p> <pre><code>$mat[0] = 2.0;\n// etc..\n</code></pre>","location":"user-guide/math/math_functions.html#matrix-usage"},{"title":"Operators","text":"<p>Just like the other math classes the matrix class <code>Mat4</code> has overloaded operators. This means that you can use the <code>*</code> operator to multiply two matrices together. This continues to work even if you multiply a matrix with a vector. The result will be a vector that has been transformed by the matrix.</p> <pre><code>$mat1 = new Mat4;\n$mat2 = new Mat4;\n\n$mat3 = $mat1 * $mat2;\n</code></pre> <p>Transforming a point in space using a matrix is done by multiplying the matrix with a vector. The vector is treated as a point, and the result is a vector that represents the transformed point.</p> <pre><code>$mat = new Mat4;\n$mat-&gt;translate(new Vec3(10, 50, 1));\n$mat-&gt;scale(new Vec3(2, 2, 2));\n$mat-&gt;rotate(GLM::radians(90), new Vec3(0, 0, 1));\n\n$point = new Vec3(10, 10, 5);\n\n$transformed = $mat * $point;\n</code></pre>","location":"user-guide/math/math_functions.html#operators_2"},{"title":"Functions","text":"<p>Just like the vector classes there are a number of functions available for working with matrices. You can read about the functions available in the <code>Mat4</code> class in the API documentation.</p> <p>To just give a few common examples:</p>","location":"user-guide/math/math_functions.html#functions_2"},{"title":"Inverse","text":"<p>You can invert a matrix using the <code>inverse</code> function or the <code>inverted</code> function. The <code>inverse</code> function modifies the matrix in place, while the <code>inverted</code> function returns a new matrix that is the inverse of the original matrix.</p> <pre><code>$mat = new Mat4;\n$mat-&gt;translate(new Vec3(10, 50, 1));\n$mat-&gt;inverse();\n\n// or \n\n$mat = new Mat4;\n$mat-&gt;translate(new Vec3(10, 50, 1));\n$mat2 = $mat = Mat4::inverted($mat);\n</code></pre>","location":"user-guide/math/math_functions.html#inverse"},{"title":"Performance","text":"<p>The math functions are implemented in C, and each component of a vector is stored as a float, so the overhead of using these functions is minimal. (at least for PHP).</p> <p>Benchmarks are always controversial and depend on the use case, but here are some benchmarks for the <code>GL\\Math\\Vec4</code> class. Once implemented in PHP and once using the extension functions.</p> <p>This is the code:</p> <pre><code>$v1 = new Vec4(1.0, 2.0, 3.0, 4.0);\n$v2 = new Vec4(5.0, 6.0, 7.0, 8.0);\n$v3 = $v1 * $v2 * $v1;\n$v3-&gt;normalize();\n</code></pre> <p>I'm using a PHP implementation of Vec4 that can be found here: Vec4.php</p> <pre><code>$v1 = new Vec4PHP(1.0, 2.0, 3.0, 4.0);\n$v2 = new Vec4PHP(5.0, 6.0, 7.0, 8.0);\n$v3 = Vec4PHP::_multiplyVec4($v1, $v2);\n$v3 = Vec4PHP::_multiplyVec4($v3, $v1);\n$v3 = Vec4PHP::_normalize($v3);\n</code></pre> <p>The benchmarks are executed using phpbench, each test case is run 10'000 times which iterates the above code 1000 times. So it ran 10'000'000 times in total.</p>","location":"user-guide/math/math_functions.html#performance"},{"title":"Results","text":"<pre><code>Average iteration times by variant\n\n1.8ms     \u2502   \u2588\n1.5ms     \u2502   \u2588\n1.3ms     \u2502   \u2588\n1.1ms     \u2502   \u2588\n881.0\u03bcs   \u2502   \u2588\n660.7\u03bcs   \u2502   \u2588\n440.5\u03bcs   \u2502 \u2588 \u2588\n220.2\u03bcs   \u2502 \u2588 \u2588\n          \u2514\u2500\u2500\u2500\u2500\u2500\n            1 2\n\n+-----------------------+---------+-----------+--------+---------+\n| subject               | memory  | mode      | rstdev | stdev   |\n+-----------------------+---------+-----------+--------+---------+\n| benchVec4PHPMulGL ()  | 1.615mb | 420.948\u03bcs | \u00b10.00% | 0.000\u03bcs |\n| benchVec4PHPMulPHP () | 1.615mb | 1.762ms   | \u00b10.00% | 0.000\u03bcs |\n+-----------------------+---------+-----------+--------+---------+\n</code></pre> <p>So in this simple test GL functions are about 400% faster than the PHP implementation.</p>","location":"user-guide/math/math_functions.html#results"},{"title":"Matrix Multiplication Performance","text":"<p>Obviously the more complex the operation the more the performance difference will be. As in this particular situation, the PHP overhead becomes a clear bottleneck. I do not claim my PHP implementation is perfectly optimized, but so aint the C implementation either...</p> <p>PHP GLFW Code:</p> <pre><code>$m1 = new Mat4;\n$m2 = new Mat4;\n$m3 = $m1 * $m2;\n$m4 = $m3-&gt;inverse();\n</code></pre> <p>Mat4 PHP implementation code can be found here Mat4.php</p> <pre><code>$m1 = new Mat4PHP();\n$m2 = new Mat4PHP();\n$m3 = Mat4PHP::_multiply($m1, $m2);\n$m4 = $m3-&gt;inverse();\n</code></pre>","location":"user-guide/math/math_functions.html#matrix-multiplication-performance"},{"title":"Results","text":"<p>As expected the performance difference is even more pronounced here. PHP-GLFW is about 1'500% faster than the PHP implementation. But again this is not really a fair comparison.</p> <pre><code>3.8ms     \u2502       \u2588\n3.4ms     \u2502       \u2588\n2.9ms     \u2502       \u2588\n2.4ms     \u2502   \u2586   \u2588\n1.9ms     \u2502   \u2588   \u2588\n1.4ms     \u2502   \u2588   \u2588\n961.7\u03bcs   \u2502   \u2588   \u2588\n480.9\u03bcs   \u2502 \u2584 \u2588 \u2585 \u2588\n          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n            1 2 3 4\n\n+-----------------------+---------+-----------+--------+---------+\n| subject               | memory  | mode      | rstdev | stdev   |\n+-----------------------+---------+-----------+--------+---------+\n| benchMat4PHPMulGL ()  | 1.615mb | 215.356\u03bcs | \u00b10.00% | 0.000\u03bcs |\n| benchMat4PHPMulPHP () | 1.615mb | 2.240ms   | \u00b10.00% | 0.000\u03bcs |\n| benchMat4PHPInvGL ()  | 1.615mb | 249.179\u03bcs | \u00b10.00% | 0.000\u03bcs |\n| benchMat4PHPInvPHP () | 1.615mb | 3.847ms   | \u00b10.00% | 0.000\u03bcs |\n+-----------------------+---------+-----------+--------+---------+\n</code></pre>","location":"user-guide/math/math_functions.html#results_1"},{"title":"Noise Functions","text":"<p>PHP-GFLW comes with a number of basic noise functions. Noise is used in games for many procedural generation tasks, such as generating terrain, textures, clouds, and more. Noise can be looked at as a pseudo-random number generator that generates a smooth, continuous, and random-looking output. </p>  <p></p>  <p>You can run this demo:</p> <pre><code>php examples/vg/noise_explorer.php\n</code></pre> <p>The following noise functions are available:</p>","location":"user-guide/noise/noise_functions.html"},{"title":"Perlin Noise","text":"<p></p> <p>To fetch a single value of Perlin noise, use the <code>perlin</code> function:</p> <pre><code>$noiseValue = GL\\Noise::perlin($x, $y, $z);\n</code></pre> <p>You can also directly fill a 2D buffer with Perlin noise values, this is basically a 2D texture of noise:</p> <pre><code>$buffer = new GL\\Buffer\\FloatBuffer();\nGL\\Noise::perlinFill2D($buffer, 256, 256, 3.0);\n</code></pre> <p>These are the arguments respectively:</p> <ul> <li><code>perlin()</code>:</li> <li><code>$x</code>, <code>$y</code>, <code>$z</code>: The coordinates of the noise.</li> <li><code>$wrapX</code>, <code>$wrapY</code>, <code>$wrapZ</code>: The wrapping of the noise.</li> <li><code>$seed</code>: The seed of the noise.</li> <li><code>perlinFill2D()</code>:</li> <li><code>$buffer</code>: The buffer to fill.</li> <li><code>$width</code>, <code>$height</code>: The size of the buffer.</li> <li><code>$scale</code>: The scale of the noise.</li> <li><code>$offsetX</code>, <code>$offsetY</code>: The offset of the noise.</li> <li><code>$wrapX</code>, <code>$wrapY</code>: The wrapping of the noise.</li> <li><code>$seed</code>: The seed of the noise.</li> </ul>","location":"user-guide/noise/noise_functions.html#perlin-noise"},{"title":"Ridge Noise","text":"<p></p> <p>Ridge noise is a variant of Perlin noise that generates sharp, jagged ridges instead of smooth gradients. This is often used in terrain generation to create mountainous landscapes or other features with steep changes in height.</p> <p>To fetch a single value of Ridge noise, use the <code>ridge</code> function:</p> <pre><code>$noiseValue = GL\\Noise::ridge($x, $y, $z);\n</code></pre> <p>You can also directly fill a 2D buffer with Ridge noise values:</p> <pre><code>$buffer = new GL\\Buffer\\FloatBuffer();\nGL\\Noise::ridgeFill2D($buffer, 256, 256, 3.0);\n</code></pre> <p>These are the arguments respectively:</p> <p><code>ridge()</code></p> <ol> <li><code>$x</code>, <code>$y</code>, <code>$z</code>: The coordinates of the noise.</li> <li><code>$lacunarity</code>: The frequency multiplier for each octave (default <code>2.0</code>).</li> <li><code>$gain</code>: The amplitude reduction factor for each octave (default <code>0.5</code>).</li> <li><code>$offset</code>: The offset applied to the noise (default <code>1.0</code>).</li> <li><code>$octaves</code>: The number of octaves to sum (default <code>6</code>).</li> </ol> <p><code>ridgeFill2D()</code></p> <ul> <li><code>$buffer</code>: The buffer to fill.</li> <li><code>$width</code>, <code>$height</code>: The size of the buffer.</li> <li><code>$scale</code>: The scale of the noise.</li> <li><code>$offsetX</code>, <code>$offsetY</code>: The offset of the noise.</li> <li><code>$lacunarity</code>: The frequency multiplier for each octave.</li> <li><code>$gain</code>: The amplitude reduction factor for each octave.</li> <li><code>$offset</code>: The offset applied to the noise.</li> <li><code>$octaves</code>: The number of octaves to sum.</li> </ul>","location":"user-guide/noise/noise_functions.html#ridge-noise"},{"title":"Fractal Brownian Motion (fBm) Noise","text":"<p></p> <p>Fractal Brownian Motion (fBm) is a method of combining multiple layers (octaves) of noise at different frequencies and amplitudes to create more complex patterns. This is commonly used in generating natural-looking textures like clouds or landscapes.</p> <p>To fetch a single value of fBm noise, use the <code>fbm</code> function:</p> <pre><code>$noiseValue = GL\\Noise::fbm($x, $y, $z);\n</code></pre> <p>You can also fill a 2D buffer with fBm noise values:</p> <pre><code>$buffer = new GL\\Buffer\\FloatBuffer();\nGL\\Noise::fbmFill2D($buffer, 256, 256, 3.0);\n</code></pre> <p>These are the arguments respectively:</p> <p><code>fbm()</code></p> <ul> <li><code>$x</code>, <code>$y</code>, <code>$z</code>: The coordinates of the noise.</li> <li><code>$lacunarity</code>: The frequency multiplier for each octave (default <code>2.0</code>).</li> <li><code>$gain</code>: The amplitude reduction factor for each octave (default <code>0.5</code>).</li> <li><code>$octaves</code>: The number of octaves to sum (default <code>6</code>).</li> </ul> <p><code>fbmFill2D()</code></p> <ul> <li><code>$buffer</code>: The buffer to fill.</li> <li><code>$width</code>, <code>$height</code>: The size of the buffer.</li> <li><code>$scale</code>: The scale of the noise.</li> <li><code>$offsetX</code>, <code>$offsetY</code>: The offset of the noise.</li> <li><code>$lacunarity</code>: The frequency multiplier for each octave.</li> <li><code>$gain</code>: The amplitude reduction factor for each octave.</li> <li><code>$octaves</code>: The number of octaves to sum.</li> </ul>","location":"user-guide/noise/noise_functions.html#fractal-brownian-motion-fbm-noise"},{"title":"Turbulence Noise","text":"<p></p> <p>Turbulence noise is similar to fBm but applies an absolute value function to the noise, which results in a more chaotic, turbulent pattern. This type of noise is often used for creating textures like marble or water.</p> <p>To fetch a single value of Turbulence noise, use the <code>turbulence</code> function:</p> <pre><code>$noiseValue = GL\\Noise::turbulence($x, $y, $z);\n</code></pre> <p>You can also fill a 2D buffer with Turbulence noise values:</p> <pre><code>$buffer = new GL\\Buffer\\FloatBuffer();\nGL\\Noise::turbulenceFill2D($buffer, 256, 256, 3.0);\n</code></pre> <p>These are the arguments respectively:</p> <p><code>turbulence()</code></p> <ul> <li><code>$x</code>, <code>$y</code>, <code>$z</code>: The coordinates of the noise.</li> <li><code>$lacunarity</code>: The frequency multiplier for each octave (default <code>2.0</code>).</li> <li><code>$gain</code>: The amplitude reduction factor for each octave (default <code>0.5</code>).</li> <li><code>$octaves</code>: The number of octaves to sum (default <code>6</code>).</li> </ul> <p><code>turbulenceFill2D()</code></p> <ul> <li><code>$buffer</code>: The buffer to fill.</li> <li><code>$width</code>, <code>$height</code>: The size of the buffer.</li> <li><code>$scale</code>: The scale of the noise.</li> <li><code>$offsetX</code>, <code>$offsetY</code>: The offset of the noise.</li> <li><code>$lacunarity</code>: The frequency multiplier for each octave.</li> <li><code>$gain</code>: The amplitude reduction factor for each octave.</li> <li><code>$octaves</code>: The number of octaves to sum.</li> </ul>","location":"user-guide/noise/noise_functions.html#turbulence-noise"},{"title":"Island Noise","text":"<p></p> <p>Island noise is a specialized noise function designed to generate island-like shapes in 2D. It can be useful for procedural generation of terrain maps where islands are required.</p> <p>To generate a 2D buffer filled with Island noise values, use the <code>islandFill2D</code> function:</p> <pre><code>$buffer = new GL\\Buffer\\FloatBuffer();\nGL\\Noise::islandFill2D($buffer, 256, 256);\n</code></pre> <p>These are the arguments respectively:</p> <p><code>islandFill2D()</code></p> <ul> <li><code>$buffer</code>: The buffer to fill.</li> <li><code>$width</code>, <code>$height</code>: The size of the buffer.</li> <li><code>$islandseed</code>: The seed for island generation (default <code>42</code>).</li> <li><code>$scale</code>: The scale of the noise.</li> <li><code>$islandmix</code>: The amount of island shape influence on the final noise (default <code>0.7</code>).</li> <li><code>$lacunarity</code>: The frequency multiplier for each octave.</li> <li><code>$gain</code>: The amplitude reduction factor for each octave.</li> <li><code>$octaves</code>: The number of octaves to sum.</li> </ul>","location":"user-guide/noise/noise_functions.html#island-noise"},{"title":"Rendering to an Image","text":"<p>You can render your OpenGL scene or parts of it to an image using PHP-GLFW.</p> <p>The <code>Texture2D</code> class can be constructed using a buffer of pixel data. </p> <pre><code>// create a buffer to store the pixel data in\n// we currently only support extracting unsigned byte data from the framebuffer\n$pixelBuffer = new \\GL\\Buffer\\UByteBuffer();\n\n// read the pixels from the current framebuffer into the buffer object `$pixelBuffer`\n// glReadPixels(x, y, width, height, format, type, buffer)\nglReadPixels(0, 0, 800, 800, GL_RGB, GL_UNSIGNED_BYTE, $pixelBuffer);\n\n// creates a texture object with the pixel data and writes it to a file in JPEG format\nTexture2D::fromBuffer(800, 800, $pixelBuffer, Texture2D::CHANNEL_RGB)\n    -&gt;writeJPG('frame.jpg');\n</code></pre>","location":"user-guide/offscreen/render-to-image.html"},{"title":"High DPI Screens","text":"<p>If you are using a high DPI screen, your framebuffer might be larger than the window size. </p> <p>This is why you should fetch the framebuffer size first if you plan to export the entire screen.</p> <pre><code>// get the framebuffer size\nglfwGetFramebufferSize($window, $width, $height);\n\n// rest just as before..\nglReadPixels(0, 0, $width, $height, GL_RGB, GL_UNSIGNED_BYTE, $pixelBuffer);\nTexture2D::fromBuffer($width, $height, $pixelBuffer, Texture2D::CHANNEL_RGB)\n    -&gt;writeJPG('frame.jpg');\n</code></pre>  <p>Note</p> <p>This also depends on other settings like, <code>GLFW_SCALE_TO_MONITOR</code> and <code>GLFW_COCOA_RETINA_FRAMEBUFFER</code>.</p>  <p>You have multiple formats to choose from when writing the image to disk:</p> <ul> <li> <p><code>writePNG</code>: PNG format with lossless compression, preserving all image data and supporting transparency. </p> </li> <li> <p><code>writeJPG</code> JPGs are lossy compressed images, by expirience they are best for images with high entropy, like noisy scenes or photographs.</p> </li> <li> <p><code>writeBMP</code>: BMP format stores images without compression, ensuring complete fidelity of the original data.</p> </li> <li> <p><code>writeTGA</code>: TGA, super simple to write and read, but not very space efficient.</p> </li> </ul>","location":"user-guide/offscreen/render-to-image.html#high-dpi-screens"},{"title":"Colors","text":"<p>The vector graphics API of PHP-GLFW provides a set of functions for working with colors.</p>","location":"user-guide/vector-graphics/colors.html"},{"title":"Color Construction","text":"<p>Colors can be constructed by calling the <code>VGColor</code> constructor and passing the desired red, green, blue, and alpha values to the constructor:</p> <pre><code>$color = new VGColor(0.5, 0.5, 0.5, 1.0); // r, g, b, a\n</code></pre> <p>You may access the individual color components via the <code>r</code>, <code>g</code>, <code>b</code>, and <code>a</code> properties. Note that these values are stored internally as 32-bit floats, so they are converted to userland floats every time they are accessed:</p> <pre><code>echo $color-&gt;r; // 0.5\n</code></pre>","location":"user-guide/vector-graphics/colors.html#color-construction"},{"title":"Color Constants","text":"<p>PHP-GLFW provides a variety of color constants.</p>  <p> </p> Run this <code>php examples/vg/color_constants.php</code>  <p>A color constant may be retrieved using the <code>VGColor::</code> prefix. For example, to retrieve the red color constant, you would use:</p> <pre><code>$red = VGColor::red();\n</code></pre> <p>These are the available color constants:</p>    Colors Contrasts Random     <code>VGColor::red()</code> <code>VGColor::gray()</code> <code>VGColor::random()</code>   <code>VGColor::green()</code> <code>VGColor::darkGray()</code> <code>VGColor::randomGray()</code>   <code>VGColor::blue()</code> <code>VGColor::lightGray()</code>    <code>VGColor::yellow()</code> <code>VGColor::white()</code>    <code>VGColor::cyan()</code> <code>VGColor::black()</code>    <code>VGColor::magenta()</code> <code>VGColor::transparent()</code>    <code>VGColor::orange()</code>     <code>VGColor::pink()</code>     <code>VGColor::purple()</code>     <code>VGColor::brown()</code>       <p>Note</p> <p>The <code>VGColor::random()</code> and <code>VGColor::randomGray()</code> functions return, as you might guess, a random color.  This can be useful for debugging purposes, such as when visualizing groups of objects.</p>","location":"user-guide/vector-graphics/colors.html#color-constants"},{"title":"Color Lightness","text":"<p>You may lighten and darken a color using the <code>lighten()</code> and <code>darken()</code> methods. Both methods accept a float value representing the amount of lightness to add or remove, respectively. The value should be between 0 and 1.</p> <p>Internally, the RGB color is converted to the HSL color space, the lightness is modified, and then the color is converted back to RGB.</p>  <p> </p> Run this <code>php examples/vg/color_lightness.php</code>  <pre><code>// darken\n$darkerRed = VGColor::red()-&gt;darken(0.3);\n// lighten\n$ligherRed = VGColor::red()-&gt;lighten(0.3);\n</code></pre>","location":"user-guide/vector-graphics/colors.html#color-lightness"},{"title":"Color Constrcutors","text":"<p>There are a few color constructors available:</p>","location":"user-guide/vector-graphics/colors.html#color-constrcutors"},{"title":"From RGB","text":"<p>Constructs a color from RGB values. The values should be between 0 and 1. </p> <pre><code>$color = VGColor::rgb(0.5, 0.5, 0.5); // Alpha is set to 1.\n$color = VGColor::rgba(0.5, 0.5, 0.5, 0.8);\n</code></pre>","location":"user-guide/vector-graphics/colors.html#from-rgb"},{"title":"From HSL","text":"<p>Constructs a color from HSL values. The values should be between 0 and 1.</p> <pre><code>$color = VGColor::hsl(0.5, 0.5, 0.5); //  Alpha is set to 1.\n$color = VGColor::hsla(0.5, 0.5, 0.5, 0.8);\n</code></pre>","location":"user-guide/vector-graphics/colors.html#from-hsl"},{"title":"From IRGB","text":"<p>Constructs a color from RGB values. The values should be between 0 and 255.</p> <pre><code>$white = VGColor::irgb(255, 255, 255); // Alpha is set to 255.\n$transparent = VGColor::irgb(255, 255, 255, 50);\n</code></pre>","location":"user-guide/vector-graphics/colors.html#from-irgb"},{"title":"Inverting","text":"<p>You may invert a color using the <code>invert()</code> method. This method returns a new color.</p> <pre><code>$inverted = VGColor::red()-&gt;invert();\n</code></pre>","location":"user-guide/vector-graphics/colors.html#inverting"},{"title":"Conversion between Vectors","text":"<p>You may convert a color to a vector using the <code>getVec3()</code> and <code>getVec4()</code> methods. You may also construct a color from a vector using the <code>fromVec3()</code> and <code>fromVec4()</code> methods.</p> <pre><code>// VGColor(1.0, 0.0, 0.0, 1.0)\n$red = VGColor::fromVec3(new Vec3(1.0, 0.0, 0.0));\n</code></pre> <pre><code> // Vec3(1.0, 0.0, 0.0)\n$vec = VGColor::red()-&gt;getVec3();\n</code></pre> <p>This way you can utilize the vector functions to manipulate colors.</p> <pre><code>$red = VGColor::red()-&gt;getVec3();\n$green = VGColor::green()-&gt;getVec3();\n\n$mixed = Vec3::mix($red, $green, 0.5);\n</code></pre>","location":"user-guide/vector-graphics/colors.html#conversion-between-vectors"},{"title":"Getting Started","text":"<p>Before we can start drawing anything, we need to create a window and create a context in which we can draw.</p> <p>Please see Creating a Window for more information on how to create a window and a context.</p> <p>We are not going to discuss the details of creating a window and a context in this tutorial.</p>  <p>PHP-GLFW already installed?</p> <p>Follow the installation guide if you haven't installed the extension yet!</p>        <p>You can run this example by <code>php examples/11_vector_graphics.php</code>.</p>","location":"user-guide/vector-graphics/creating_a_vgcontext.html"},{"title":"Creating a VG Context","text":"<p>To properly utilize the vector graphics API, we need to create a <code>VGContext</code> object. This object will hold all the internal state that the vector graphics state machine needs to operate. (You can have multiple.)</p> <pre><code>use GL\\VectorGraphics\\{VGContext};\n\n// code to initalize GLFW and create a window here...\n\n// initalize the a vector graphics context\n$vg = new VGContext(VGContext::ANTIALIAS);\n</code></pre> <p>As you can see the <code>VGContext</code> constructor takes flags as an argument. In this example we pass <code>VGContext::ANTIALIAS</code> to enable (you gussed it) antialiasing.</p> <p>The following flags are available:</p> <ul> <li><code>VGContext::ANTIALIAS</code> - Enables geometry-based anti-aliasing. Useful for smoothing edges in rendering. May not be necessary with multi-sample anti-aliasing (MSAA).</li> <li><code>VGContext::STENCIL_STROKES</code> - Utilizes the stencil buffer for stroke drawing. Ensures correct rendering of path overlaps and sharp turns, with each segment drawn only once. Slightly slower but provides precision.</li> <li><code>VGContext::DEBUG</code> - Activates additional debug checks. Helpful for development and troubleshooting.</li> </ul>","location":"user-guide/vector-graphics/creating_a_vgcontext.html#creating-a-vg-context"},{"title":"Beginnig and ending a frame","text":"<p>In your application's render loop you need to call <code>beginFrame()</code> and <code>endFrame()</code> on the <code>VGContext</code> object. The context will queue all draw commands until you call <code>endFrame()</code>. </p> BasicFull Example   <pre><code>$vg-&gt;beginFrame($width, $height, $devicePixelRatio);\n\n// draw stuff here...\n\n$vg-&gt;endFrame();\n</code></pre>   <pre><code>use GL\\VectorGraphics\\VGContext;\n\nif (!glfwInit()) {\n    throw new Exception('GLFW could not be initialized!');\n}\n\n// make sure to set the GLFW context version to the same \n// version the GLFW extension has been compiled with, default 4.1\nglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\nglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);\nglfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\nglfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n\n// Create a window \nif (!$window = glfwCreateWindow(800, 600, \"PHP GLFW Demo\")) {\n    throw new Exception('OS Window could not be initialized!');\n}\n\nglfwMakeContextCurrent($window);\nglfwSwapInterval(1);\n\n// initalize the a vector graphics context\n$vg = new VGContext(VGContext::ANTIALIAS);\n\n// Main Loop\nwhile (!glfwWindowShouldClose($window))\n{\n    glClearColor(0, 0, 0, 1);\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    // start a new vector graphics frame\n    $vg-&gt;beginFrame(800, 600, 1);\n\n    // DRAW STUFF HERE...\n\n    // end the frame will dispatch all the draw commands to the GPU\n    $vg-&gt;endFrame();\n\n    // swap the windows framebuffer and\n    // poll queued window events.\n    glfwSwapBuffers($window);\n    glfwPollEvents();\n}\n\nglfwDestroyWindow($window);\nglfwTerminate();\n</code></pre>    <p>The <code>beginFrame()</code> method takes 3 arguments:</p> <ul> <li><code>width</code> - The width of the window in points. This will almost always be the same as the width of your window.</li> <li><code>height</code> - The height of the window in points. Just like the width, this will almost always be the same as the height of your window.</li> <li><code>devicePixelRatio</code> - The ratio between the window's backing pixels and the window's points. This is usually <code>1.0</code> on normal displays and <code>2.0</code> on retina displays.  You can find out the device pixel ratio of your window by calling <code>glfwGetWindowContentScale()</code>.     <pre><code>glfwGetWindowContentScale($window, $scaleX, $scaleY);\nglfwGetWindowSize($window, $windowWidth, $windowHeight);\n$vg-&gt;beginFrame($windowWidth, $windowHeight, $scaleX);\n</code></pre></li> </ul>","location":"user-guide/vector-graphics/creating_a_vgcontext.html#beginnig-and-ending-a-frame"},{"title":"Drawing","text":"<p>Now that we have a context and a frame, we can start drawing. The vector graphics API is very similar to the HTML Canvas API. If you have ever used the HTML Canvas API, you will feel right at home.</p> <p>The first thing we need to do is create a path. A path is a collection of points, lines, curves and shapes. We can then stroke or fill the path to draw it to the screen.</p> <pre><code>$vg-&gt;beginPath();\n</code></pre> <p>Now that we have a path, we can start drawing shapes. The vector graphics API provides a few methods to draw basic shapes.</p> <pre><code>// rect(x, y, width, height)\n$vg-&gt;rect(10, 10, 100, 100);\n</code></pre> <p>To set the color of a shape, we can use the <code>fillColor()</code> and <code>strokeColor()</code> methods.</p> <p>The <code>VGColor</code> class provides a few static methods to create colors from a basic palette.</p> <pre><code>// set the fill color to red\n$vg-&gt;fillColor(VGColor::red());\n</code></pre> <p>To fill a shape, we can use the <code>fill()</code> method. To stroke a shape, we can use the <code>stroke()</code> method.</p> <pre><code>// fill the shape with the current fill color\n$vg-&gt;fill();\n</code></pre>","location":"user-guide/vector-graphics/creating_a_vgcontext.html#drawing"},{"title":"Putting it all together","text":"<p>All together, this is how you would draw a red rectangle to the screen.</p>  <p></p>  BasicFull Example   <pre><code>$vg-&gt;beginPath();\n$vg-&gt;rect(10, 10, 100, 100);\n$vg-&gt;fillColor(VGColor::red());\n$vg-&gt;fill();\n</code></pre>   <pre><code>use GL\\VectorGraphics\\VGColor;\nuse GL\\VectorGraphics\\VGContext;\n\nif (!glfwInit()) {\n    throw new Exception('GLFW could not be initialized!');\n}\n\n// make sure to set the GLFW context version to the same \n// version the GLFW extension has been compiled with, default 4.1\nglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\nglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);\nglfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\nglfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n\n// Create a window \nif (!$window = glfwCreateWindow(800, 600, \"PHP GLFW Demo\")) {\n    throw new Exception('OS Window could not be initialized!');\n}\n\nglfwMakeContextCurrent($window);\nglfwSwapInterval(1);\n\n// initalize the a vector graphics context\n$vg = new VGContext(VGContext::ANTIALIAS);\n\n// Main Loop\nwhile (!glfwWindowShouldClose($window))\n{\n    glClearColor(0, 0, 0, 1);\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    // start a new vector graphics frame\n    $vg-&gt;beginFrame(800, 600, 1);\n\n    $vg-&gt;beginPath();\n    $vg-&gt;rect(10, 10, 100, 100);\n    $vg-&gt;fillColor(VGColor::red());\n    $vg-&gt;fill();\n\n    // end the frame will dispatch all the draw commands to the GPU\n    $vg-&gt;endFrame();\n\n    glfwSwapBuffers($window);\n    glfwPollEvents();\n}\n\nglfwDestroyWindow($window);\nglfwTerminate();\n</code></pre>","location":"user-guide/vector-graphics/creating_a_vgcontext.html#putting-it-all-together"},{"title":"Adding some interaction","text":"<p>To not end this \"Getting Started\" tutorial with a static image, let's add some interaction to our example. We are going to draw a circle that follows the mouse cursor.</p> <p>To get the mouse position, we can use the <code>glfwGetCursorPos()</code> function.</p> <pre><code>glfwGetCursorPos($window, $mouseX, $mouseY);\n</code></pre> <p>Then we just replace our call to <code>rect()</code> with a call to <code>circle()</code> and use the mouse position as the center of the circle.</p> <pre><code>$vg-&gt;beginPath();\n$vg-&gt;circle($mouseX, $mouseY, 50);\n$vg-&gt;fillColor(VGColor::red());\n$vg-&gt;fill();\n</code></pre> <p>As simple as that, we now have a circle that follows the mouse cursor. </p>      <p>In the next chapter we are going to dive a bit more into the basics.</p>","location":"user-guide/vector-graphics/creating_a_vgcontext.html#adding-some-interaction"},{"title":"Additional Resources","text":"<ul> <li>The vector graphics API is based on a modified version of the amazing NanoVG library. </li> </ul>","location":"user-guide/vector-graphics/creating_a_vgcontext.html#additional-resources"},{"title":"Filling and Stroking","text":"<p>In the PHP-GLFW vector graphics context, shapes can be rendered on-screen using two methods: filling and stroking.</p> <ul> <li> <p>Filling a shape colors its entire interior area. When you fill a shape, like a circle, the entire circle is covered with the fill color.</p> </li> <li> <p>Stroking a shape outlines it without filling the interior. Stroking a circle, for example, results in just the circle's edge being drawn, using the stroke color. </p> </li> </ul>  <p></p>  StrokeFill   <pre><code>$vg-&gt;beginPath();\n$vg-&gt;rect(200, 100, 400, 200);\n$vg-&gt;strokeColor(VGColor::red());\n$vg-&gt;strokeWidth(20); // note that we additinally set the stroke width\n$vg-&gt;stroke();\n</code></pre>   <pre><code>$vg-&gt;beginPath();\n$vg-&gt;rect(200, 100, 400, 200);\n$vg-&gt;fillColor(VGColor::red());\n$vg-&gt;fill();\n</code></pre>","location":"user-guide/vector-graphics/fill-vs-stroke.html"},{"title":"Filling and Stroking Together","text":"<p>These two methods can be used together to create borders and outlines for shapes.</p>  <p></p>  <pre><code>$vg-&gt;beginPath();\n$vg-&gt;rect(200, 100, 400, 200);\n$vg-&gt;fillColor(VGColor::orange());\n$vg-&gt;strokeColor(VGColor::red());\n$vg-&gt;strokeWidth(20);\n$vg-&gt;fill();\n$vg-&gt;stroke();\n</code></pre>","location":"user-guide/vector-graphics/fill-vs-stroke.html#filling-and-stroking-together"},{"title":"Stroke Width","text":"<p>The stroke width is the thickness of the stroke. The default stroke width is 1.0. The stroke width is always centered on the path, meaning that half of the stroke width is drawn on the inside of the path, and half on the outside.</p>  <p></p>","location":"user-guide/vector-graphics/fill-vs-stroke.html#stroke-width"},{"title":"Stroke Inside and Outside","text":"<p>Again, the stroke width is always centered on the path so if you want to draw a stroke that is entirely inside or outside the path, you need to adjust the path itself.</p> Stroke InsideStroke Outside   <p>To draw a stroke that is entirely inside the path, you need to move the path inwards by half the stroke width.</p> <p>  </p> <pre><code>$rectX = 200;\n$rectY = 100;\n$rectWidth = 400;\n$rectHeight = 200;\n$strokeWidth = 20;\n\n$vg-&gt;beginPath();\n$vg-&gt;rect(\n    $rectX + $strokeWidth / 2, \n    $rectY + $strokeWidth / 2, \n    $rectWidth - $strokeWidth, \n    $rectHeight - $strokeWidth\n);\n$vg-&gt;strokeColor(VGColor::red());\n$vg-&gt;strokeWidth($strokeWidth);\n$vg-&gt;stroke();\n</code></pre>   <p>To draw a stroke that is entirely outside the path, you need to move the path outwards by half the stroke width.</p> <p>  </p> <pre><code>$rectX = 200;\n$rectY = 100;\n$rectWidth = 400;\n$rectHeight = 200;\n$strokeWidth = 20;\n\n$vg-&gt;beginPath();\n$vg-&gt;rect(\n    $rectX - $strokeWidth / 2, \n    $rectY - $strokeWidth / 2, \n    $rectWidth + $strokeWidth, \n    $rectHeight + $strokeWidth\n);\n$vg-&gt;strokeColor(VGColor::red());\n$vg-&gt;strokeWidth($strokeWidth);\n$vg-&gt;stroke();\n</code></pre>","location":"user-guide/vector-graphics/fill-vs-stroke.html#stroke-inside-and-outside"},{"title":"Color Gradients","text":"<p>Gradients allow you to fill shapes with colors that smoothly transition from one to another. You can use gradients to paint any path (unfortunately, text is not yet supported), and we support two types: linear and radial.</p> <p>One important thing to note: when you use gradients in PHP-GLFW's Vector Graphics API, the position and size of your shape don't change the gradient itself. Instead, they affect how the gradient maps onto your shape. It's a bit like stretching out a large sheet of gift wrap and then using your shape to cut out a piece of it.</p> <p>Images follow a similar concept; check out Images &amp; Graphics.</p>","location":"user-guide/vector-graphics/gradients.html"},{"title":"Linear Gradients","text":"<p>A linear gradient requires just two points to work: where it starts and where it ends.</p>     Run this <code>php examples/vg/gradient_linear.php</code>  <p>Gradients, just like images/textures, are applied using a <code>VGPaint</code> object. </p> <p>To create a linear paint:</p> <pre><code>$x1 = 50;    \n$y1 = 150;\n$x2 = 350;\n$y2 = 450;\n$color1 = new VGColor(0.051, 0.682, 0.914, 1.0);\n$color2 = new VGColor(0.169, 0.961, 0.596, 1.0);\n\n$paint = $vg-&gt;linearGradient($x1, $y1, $x2, $y2, $color1, $color2);\n</code></pre> <p>This paint can then be applied to all kinds of shapes.</p>","location":"user-guide/vector-graphics/gradients.html#linear-gradients"},{"title":"Rectangles","text":"<p></p>  <pre><code>$vg-&gt;beginPath();\n$vg-&gt;fillPaint($paint);\n$vg-&gt;rect(50, 150, 300, 300);\n$vg-&gt;fill();\n</code></pre>","location":"user-guide/vector-graphics/gradients.html#rectangles"},{"title":"Circles","text":"<p></p>  <pre><code>$vg-&gt;beginPath();\n$vg-&gt;fillPaint($paint);\n$vg-&gt;circle(200, 300, 150);\n$vg-&gt;fill();\n</code></pre> <p>Rember the Vector Graphics API is a state machine, so you can reuse the paint object for multiple shapes.</p>  <p> </p> Run this <code>php examples/vg/gradient_wave.php</code>  <pre><code>$waveY = ExampleHelper::WIN_HEIGHT / 2;\n$dotSize = 10;\n$dotDistance = 20;\n$waveLength = 0.1;\n\n$vg-&gt;fillPaint($paint);\n\nfor($x = 0; $x &lt; ExampleHelper::WIN_WIDTH; $x += $dotDistance) {\n    $value = sin($x * $waveLength / 20 + glfwGetTime());\n    $vg-&gt;beginPath();\n    $vg-&gt;circle($x, $waveY + $value * 100, $dotSize);\n    $vg-&gt;fill();\n}\n</code></pre>","location":"user-guide/vector-graphics/gradients.html#circles"},{"title":"Radial Gradients","text":"<p>A radial gradient is created by defining a central point and a radius, resulting in a smooth transition of colors that radiates outward in a circular pattern from the center to the outer edge.</p>  <p> </p> Run this <code>php examples/vg/gradient_radial.php</code>  <p>to create a radial paint:</p> <pre><code>$centerX = 300;\n$centerY = 300;\n$innerRadius = 0;\n$outerRadius = 150;\n$color1 = new VGColor(0.051, 0.682, 0.914, 1.0);\n$color2 = new VGColor(0.169, 0.961, 0.596, 1.0);\n\n$paint = $vg-&gt;radialGradient($centerX, $centerY, $innerRadius, $outerRadius, $color1, $color2);\n</code></pre>","location":"user-guide/vector-graphics/gradients.html#radial-gradients"},{"title":"Images &amp; Graphics","text":"<p>Until now, we have only been using solid colors to fill shapes. However, you can also use images or bitmaps as a fill pattern.</p>      <p>There are three steps required to achieve this:</p> <ol> <li>Loading the image from disk into memory.</li> <li>Uploading the texture to the GPU.</li> <li>Creating a <code>VGPaint</code> from the texture that can be used as a fill pattern.</li> </ol>","location":"user-guide/vector-graphics/images.html"},{"title":"Loading Images","text":"<p>The first step is to load the image from disk into memory. This can be done with the <code>Texture2D</code> class.</p> <pre><code>$texture = Texture2D::fromDisk('/path/to/your/image.png', Texture2D::CHANNEL_RGBA, false);\n</code></pre> <p>In the Vector Graphics API, only RGBA (4-channel) images are supported. The last parameter is a boolean that indicates whether the image should be flipped vertically. This is required because OpenGL and the Vector Graphics API use different coordinate systems.</p>","location":"user-guide/vector-graphics/images.html#loading-images"},{"title":"Uploading the Texture","text":"<p>The next step is to upload the texture to the GPU. </p> <pre><code>$image = $vg-&gt;imageFromTexture($texture);\n</code></pre> <p>Note that there are two optional arguments that can be passed to this method:</p> <ol> <li> <p>Repeat Mode: This can be either <code>VGImage::REPEAT_XY</code>, <code>VGImage::REPEAT_X</code>, <code>VGImage::REPEAT_Y</code>, or <code>VGImage::REPEAT_NONE</code>. This controls how the image is repeated when the shape is larger than the image. The default is <code>VGImage::REPEAT_NONE</code>.</p> <p>  </p> </li> <li> <p>Filter Mode: This can be either <code>VGImage::FILTER_LINEAR</code> or <code>VGImage::FILTER_NEAREST</code>. This controls how the image is filtered when it is scaled. The default is <code>VGImage::FILTER_LINEAR</code>.</p> <p>    </p> </li> </ol> <p>A complete function call would look like this:</p> <pre><code>$image = $vg-&gt;imageFromTexture($texture, VGImage::REPEAT_XY, VGImage::FILTER_LINEAR);\n</code></pre>","location":"user-guide/vector-graphics/images.html#uploading-the-texture"},{"title":"Creating a Paint","text":"<p>The final step is to create a paint from the image. The paint is defined in global space and can be used to fill or stroke any shape.</p> <pre><code>// makePaint(x, y, width, height, angle, alpha)\n$imagePaint = $image-&gt;makePaint(0, 0, 500, 500);\n</code></pre> <p>The <code>makePaint</code> method takes six arguments:</p> <ol> <li>x: The x-coordinate of the top left corner of the paint.</li> <li>y: The y-coordinate of the top left corner of the paint.</li> <li>width: The width of the paint.</li> <li>height: The height of the paint.</li> <li>angle: The angle of the paint in radians. (The rotation is around the top left corner of the paint.)</li> <li>alpha: The alpha value of the paint.</li> </ol>","location":"user-guide/vector-graphics/images.html#creating-a-paint"},{"title":"Using the Paint","text":"<p>The paint can now be used to fill or stroke any shape.</p> <pre><code>$vg-&gt;beginPath();\n$vg-&gt;rect(0, 0, 500, 500);\n$vg-&gt;fillPaint($imagePaint);\n$vg-&gt;fill();\n</code></pre>  <p></p>","location":"user-guide/vector-graphics/images.html#using-the-paint"},{"title":"In Global Space?","text":"<p>The paint is defined in global space, meaning it will NOT be affected by the shape it is used to fill. This might seem counterintuitive at first.</p> <p>A simple example to visualize this is to create a paint that covers the entire screen and then draw a rectangle in the middle of the screen with that paint.</p>  <p></p>  <pre><code>$paint = $myImage-&gt;makePaint(0, 0, 512, 512);\n$vg-&gt;beginPath();\n$vg-&gt;rect(100, 100, 200, 200);\n$vg-&gt;fillPaint($paint);\n$vg-&gt;fill();\n</code></pre>","location":"user-guide/vector-graphics/images.html#in-global-space"},{"title":"Scaling a Paint","text":"<p>If you are now confused about how to set the size of an image, this is controlled by the parameters passed to <code>makePaint</code>. The <code>width</code> and <code>height</code> parameters define the size of the paint in global space.</p> <p></p> <p>A quick example:</p> <pre><code>$vg-&gt;beginPath();\n$vg-&gt;rect(100, 100, 200, 200);\n$paint = $myImage-&gt;makePaint(100, 100, 200, 200);\n$vg-&gt;fillPaint($paint);\n$vg-&gt;fill();\n\n// slightly smaller\n$vg-&gt;beginPath();\n$vg-&gt;rect(350, 100, 100, 100);\n$paint = $myImage-&gt;makePaint(350, 100, 100, 100);\n$vg-&gt;fillPaint($paint);\n$vg-&gt;fill();\n\n// even smaller\n$vg-&gt;beginPath();\n$vg-&gt;rect(500, 100, 50, 50);\n$paint = $myImage-&gt;makePaint(500, 100, 50, 50);\n$vg-&gt;fillPaint($paint);\n$vg-&gt;fill();\n</code></pre>","location":"user-guide/vector-graphics/images.html#scaling-a-paint"},{"title":"Preexisting Images (Context Sharing)","text":"<p>If you have a texture that is already uploaded to the GPU, you can create an image from it that can be used as a paint.</p> <pre><code>$glTexture; // the GL texture handle\n\n$vgImage = $vg-&gt;imageFromHandle($glTexture, $textureWidth, $textureHeight);\n$paint = $vgImage-&gt;makePaint(0, 0, $textureWidth, $textureHeight);\n</code></pre>","location":"user-guide/vector-graphics/images.html#preexisting-images-context-sharing"},{"title":"Shapes (Circle, Rectangle, Polygon, etc.)","text":"<p>A number of basic shapes can be drawn using helper functions.</p>  <p></p>  <p><code>rect()</code>, <code>roundedRect()</code>, <code>ellipse()</code>, <code>circle()</code>, <code>arc()</code></p>","location":"user-guide/vector-graphics/shapes.html"},{"title":"Rectangles","text":"<p>The <code>rect()</code> function draws a rectangle with the top-left corner at <code>(x, y)</code> and the specified <code>width</code> and <code>height</code>.</p> <pre><code>// rect(x, y, width, height)\n$vg-&gt;rect(10, 10, 100, 100);\n</code></pre>  <p></p>","location":"user-guide/vector-graphics/shapes.html#rectangles"},{"title":"Rounded Rectangles","text":"<p>The <code>roundedRect()</code> function draws a rectangle with rounded corners. The <code>radius</code> parameter specifies the radius of the corners.</p> <pre><code>// roundedRect(x, y, width, height, radius)\n$vg-&gt;roundedRect(10, 10, 100, 100, 10);\n</code></pre>  <p></p>","location":"user-guide/vector-graphics/shapes.html#rounded-rectangles"},{"title":"Circles","text":"<p>The <code>circle()</code> function draws a circle with the center at <code>(x, y)</code> and the specified <code>radius</code>.</p> <pre><code>// circle(x, y, radius)\n$vg-&gt;circle(400, 200, 50);\n</code></pre>  <p></p>","location":"user-guide/vector-graphics/shapes.html#circles"},{"title":"Ellipses","text":"<p>The <code>ellipse()</code> function draws an ellipse with the center at <code>(x, y)</code> and the specified <code>radiusX</code> and <code>radiusY</code>.</p> <pre><code>// ellipse(x, y, radiusX, radiusY)\n$vg-&gt;ellipse(400, 200, 50, 100);\n</code></pre>  <p></p>","location":"user-guide/vector-graphics/shapes.html#ellipses"},{"title":"Arcs","text":"<p>I've honestly only used arcs to draw pie charts, so thats what im going to focus on in this example. </p> <pre><code>// arc(cx, cy, radius, startAngle, endAngle, direction)\n// CCW = Counter Clockwise\n$vg-&gt;arc(700, 200, 50, 0, 3.14, VGContext::CCW);\n</code></pre> <p>Again this can be utilized to draw pies! Here is an example of how to draw a circular progress indicator.</p> <pre><code>$cx = 400;\n$cy = 200;\n$radius = 50;\n$progress = 0.5; // 50%\n$startAngle = -M_PI * 0.5; \n$endAngle = $startAngle + (M_PI * 2 * $progress);\n\n$vg-&gt;beginPath();\n$vg-&gt;moveTo($cx, $cy);\n$startX = $cx + $radius * cos($startAngle);\n$startY = $cy + $radius * sin($startAngle);\n$vg-&gt;lineTo($startX, $startY);\n$vg-&gt;arc($cx, $cy, $radius, $startAngle, $endAngle, VGContext::CW);\n$vg-&gt;closePath();\n$vg-&gt;fillColor(VGColor::green());\n$vg-&gt;fill();\n</code></pre>  <p></p>","location":"user-guide/vector-graphics/shapes.html#arcs"},{"title":"Polygons","text":"<p>If you want to draw a custom shape you can simply issue a series of <code>moveTo()</code> and <code>lineTo()</code> commands to draw a polygon.</p> <p>This will allow you to draw basically any shape you want. Here is an example of how to draw a star.</p>  <p></p>  <pre><code>$vg-&gt;beginPath();\n$vg-&gt;moveTo(400, 100);\n$vg-&gt;lineTo(450, 200);\n$vg-&gt;lineTo(550, 200);\n$vg-&gt;lineTo(475, 250);\n$vg-&gt;lineTo(500, 350);\n$vg-&gt;lineTo(400, 300);\n$vg-&gt;lineTo(300, 350);\n$vg-&gt;lineTo(325, 250);\n$vg-&gt;lineTo(250, 200);\n$vg-&gt;lineTo(350, 200);\n$vg-&gt;closePath();\n$vg-&gt;fillColor(VGColor::yellow());\n$vg-&gt;fill();\n\n// draw some eyes\n$vg-&gt;beginPath();\n$vg-&gt;circle(400 - 30, 230, 10);\n$vg-&gt;circle(400 + 30, 230, 10);\n$vg-&gt;fillColor(VGColor::black());\n$vg-&gt;fill();\n</code></pre>","location":"user-guide/vector-graphics/shapes.html#polygons"},{"title":"Text &amp; Fonts","text":"<p>Rendering text is a fundamental aspect of many graphics applications, from displaying user interface elements to showing in-game information. However, implementing custom text rendering can be complex and time-consuming, especially when dealing with various font styles and sizes. PHP-GLFW's Vector Graphics API allows you the use of TrueType Font (TTF) files.</p>  <p> </p> Run this <code>php examples/vg/text_intro.php</code>","location":"user-guide/vector-graphics/text.html"},{"title":"Loading Fonts","text":"<p>First you need to load a font file. You can do this by calling the <code>createFont()</code> method on the <code>VectorGraphics</code> context object. </p> <ul> <li>The first parameter is the name of the font, which you can use to reference the font later. </li> <li>The second parameter is the path to the font file.</li> </ul> <pre><code>$fontHandle = $vg-&gt;createFont('myfont', __DIR__ . '/path/to/my/Font.ttf');\n</code></pre> <p>The returned integer is the font handle. The function will return <code>-1</code> if the font could not be loaded.</p>  <p>Note</p> <p><code>0</code> is a valid handle, so you should check for <code>-1</code> specifically.</p>  <p>If your font file contains multiple fonts faces, you can specify which one to load by passing the font face index.</p> <pre><code>$fontHandle = $vg-&gt;createFontAtIndex('myfont', __DIR__ . '/path/to/my/Font.ttf', 0);\n</code></pre>","location":"user-guide/vector-graphics/text.html#loading-fonts"},{"title":"Rendering Text","text":"<p>With the font loaded, you can now set it as the current font.</p> <pre><code>$vg-&gt;fontFaceId($fontHandle);\n</code></pre> <p>Now you to render text:</p> <pre><code>$vg-&gt;beginPath();\n$vg-&gt;fontSize(20);\n$vg-&gt;fillColor(VGColor::green());\n\n// text(x, y, string)\n$vg-&gt;text(50, 50, 'Hello World!');\n</code></pre>  <p></p>  <p>You do not have to set the font size every time you render text. The Vector Graphics API behaves like a state machine, so the font size will be remembered until you change it again.</p>","location":"user-guide/vector-graphics/text.html#rendering-text"},{"title":"Text Alignment","text":"<p>You can change the text alignment by calling the <code>textAlign()</code> method. </p>  <p> </p> Run this <code>php examples/vg/text_alignment.php</code>  <ul> <li> <p>Horizontal alignment, which can be one of the following constants:</p> <ul> <li><code>VGAlign::LEFT</code></li> <li><code>VGAlign::CENTER</code></li> <li><code>VGAlign::RIGHT</code></li> </ul> </li> <li> <p>Vertical alignment, which can be one of the following constants:</p> <ul> <li><code>VGAlign::TOP</code></li> <li><code>VGAlign::MIDDLE</code></li> <li><code>VGAlign::BOTTOM</code></li> <li><code>VGAlign::BASELINE</code></li> </ul> </li> </ul> <pre><code>$vg-&gt;textAlign(VGAlign::CENTER | VGAlign::MIDDLE);\n</code></pre>","location":"user-guide/vector-graphics/text.html#text-alignment"},{"title":"Text Boxes","text":"<p>You can render text inside a box by calling the <code>textBox()</code> method. This method will automatically wrap the text to fit inside of a given width.</p>  <p> </p> Run this <code>php examples/vg/text_boxes.php</code>  <p>The <code>textBox()</code> method works very similar to the <code>text()</code> method, except it takes an additional parameter for the width of the box.</p> <pre><code>// textBox(x, y, width, string)\n$vg-&gt;textBox(50, 50, 200, 'Hello World!');\n</code></pre>","location":"user-guide/vector-graphics/text.html#text-boxes"},{"title":"Text Metrics","text":"<p>When working with text, you will pretty quickly end up in a situation where you need to know the size of the text you are rendering.</p>","location":"user-guide/vector-graphics/text.html#text-metrics"},{"title":"X Advance","text":"<p> </p> Run this <code>php examples/vg/text_color_words.php</code>  <p>For exmaple, lets say we want to render a sentence where each word is a different color. The <code>text</code> function will actually return the x position + width of the text it rendered. So we can use this to render the next word at the correct position.</p> <pre><code>$x = 50;\nforeach(['Hey ', 'How ', 'Are ', 'You? '] as $word) {\n    $vg-&gt;fillColor(VGColor::random());\n    $x = $vg-&gt;text($x, 50, $word); \n}\n</code></pre>","location":"user-guide/vector-graphics/text.html#x-advance"}]}